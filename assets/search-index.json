{
  "generated_at": "2026-01-26T14:05:35.978658+00:00",
  "document_count": 44,
  "documents": [
    {
      "title": "[다이내믹] 가장 큰 증가하는 부분수열-백준 11055번",
      "subtitle": "전형적인 DP, 가장 큰 증가하는 부분수열",
      "description": null,
      "url": "/codingtest/2026-01-26-[다이내믹]-가장-큰-증가하는-부분-수열-백준-11055번/",
      "collection": "codingtest",
      "relative_path": "2026-01-26-[다이내믹]-가장-큰-증가하는-부분-수열-백준-11055번",
      "date": "2026-01-26T12:21:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "수열"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "문제 수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다. 입력 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,0…",
      "search_text": "[다이내믹] 가장 큰 증가하는 부분수열-백준 11055번 전형적인 dp, 가장 큰 증가하는 부분수열 동적 프로그래밍 dp 백준 알고리즘 수열 codingtest codingtest algorithm-dp 문제 수열 a가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오. 예를 들어, 수열 a = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 a = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다. 입력 첫째 줄에 수열 a의 크기 n (1 ≤ n ≤ 1,000)이 주어진다. 둘째 줄에는 수열 a를 이루고 있는 ai가 주어진다. (1 ≤ ai ≤ 1,0… \n\n## 문제\n\n수열 a가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 a = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가하는 부분 수열은 a = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 이고, 합은 113이다.\n\n## 입력\n\n첫째 줄에 수열 a의 크기 n (1 ≤ n ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 a를 이루고 있는 ai가 주어진다. (1 ≤ ai ≤ 1,000)\n\n## 출력\n\n첫째 줄에 수열 a의 합이 가장 큰 증가하는 부분 수열의 합을 출력한다.\n\n## 예제 입력 1\n\n```\n\n10\n1 100 2 50 60 3 5 6 7 8\n\n```\n\n## 예제 출력 1\n\n```\n\n113\n\n```\n\n## 출처\n\n- 문제를 만든 사람: baekjoon  \n- 데이터를 추가한 사람: gee308, gomyk12, mohana9  \n\n## 비슷한 문제\n\n- 11053번. 가장 긴 증가하는 부분 수열  \n- 11054번. 가장 긴 바이토닉 부분 수열  \n- 11722번. 가장 긴 감소하는 부분 수열  \n- 12015번. 가장 긴 증가하는 부분 수열 2  \n- 12738번. 가장 긴 증가하는 부분 수열 3  \n- 14002번. 가장 긴 증가하는 부분 수열 4  \n- 14003번. 가장 긴 증가하는 부분 수열 5  \n\n## 알고리즘 분류\n\n- 다이나믹 프로그래밍\n\n\n## 풀이\n\n이제 좀 심화 dp 느낌이 날듯말듯 한다. 이것은 단순한 길이 재기보다 더 까다로운 조건을 따른다.\n그 까닭은 명확하다. 이번에는 실제 원본 수열에서 값을 현명하게 뽑아서 dp 배열에 어떻게 넣어 주느냐가 중요하기 때문이다.\n즉 dp 배열과 원본 수열을 잘 생각하면서 **과거와 현재**의 분기점을 만드는 방식을 사용한다고 보면 된다.\n\n반복문 안의 이 부분을 얼마나 정밀하게 보는지가 핵심이다.\n```c\n            if(a[i] < a[k]) dp[k] = max(dp[k], a[k] + dp[i]);\n```\n\n이것은 결과적으로 현재 위치에 대해 누적된 수들의 합이, 현재 것과 현재 것 이전을 색인하다 찾은 합을 더한 것보다 작느냐? 그렇다면 합을 그것으로 갱신하라는 논리를 따르게 된다.\n이러한 논리는 직관적이지만 처음 볼 때 생각하기 어렵다. 물론 백준의 문제 난이도 티어를 올릴 정도는 아니지만 이제서야 실전 dp에 조금이나마 가까운 문제를 푼다는 감각이다.\n\n이제 실전적인 풀이를 보면서 다시 한 번 정리해 볼 필요가 있다.\n\n## 코드\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define max(x, y) (((x) > (y)) ? (x) : (y))\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int *a = calloc(n, sizeof(int));\n    int *dp = calloc(n, sizeof(int));\n    \n    for(int i = 0; i < n; i++) {\n        // if you prefer unary,\n        // \n        // scanf(\"%d\", &a[i]);\n        scanf(\"%d\", a + i);\n    }\n    \n    int result = 0;\n    for(int k = 0; k < n; k++) {\n        dp[k] = a[k];\n        for(int i = 0; i < k; i++) {\n            // here's the main point.\n            if(a[i] < a[k]) dp[k] = max(dp[k], a[k] + dp[i]);\n        }\n        result = max(result, dp[k]);\n    }\n    \n    \n    printf(\"%d\", result);\n    \n    free(a);\n    free(dp);\n    \n    return 0;\n   \n}\n```\n"
    },
    {
      "title": "[다이내믹] 상자넣기-백준 1965번",
      "subtitle": "전형적인 DP, 가장 긴 증가하는 부분수열",
      "description": null,
      "url": "/codingtest/2026-01-26-[다이내믹]-상자넣기-백준-1965번/",
      "collection": "codingtest",
      "relative_path": "2026-01-26-[다이내믹]-상자넣기-백준-1965번",
      "date": "2026-01-26T12:21:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "수열"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "상자넣기 | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 | |------------|--------------|--------|--------|------------|------------| | 2 초 | 128 MB | 27372 | 13756 | 11525 | 50.872% | 문제 정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을…",
      "search_text": "[다이내믹] 상자넣기-백준 1965번 전형적인 dp, 가장 긴 증가하는 부분수열 동적 프로그래밍 dp 백준 알고리즘 수열 codingtest codingtest algorithm-dp 상자넣기 | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 | |------------|--------------|--------|--------|------------|------------| | 2 초 | 128 mb | 27372 | 13756 | 11525 | 50.872% | 문제 정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을… \n\n# 상자넣기\n\n| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞힌 사람 | 정답 비율 |\n|------------|--------------|--------|--------|------------|------------|\n| 2 초       | 128 mb       | 27372  | 13756  | 11525      | 50.872%    |\n\n## 문제\n\n정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다.  \n예를 들어 앞에서부터 순서대로 크기가 (1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.\n\n상자의 크기가 주어질 때, 한 번에 넣을 수 있는 최대의 상자 개수를 출력하는 프로그램을 작성하시오.\n\n## 입력\n\n파일의 첫 번째 줄은 상자의 개수 n (1 ≤ n ≤ 1000)을 나타낸다.  \n두 번째 줄에는 각 상자의 크기가 순서대로 주어진다. 상자의 크기는 1,000을 넘지 않는 자연수이다.\n\n## 출력\n\n첫째 줄에 한 줄에 넣을 수 있는 최대의 상자 개수를 출력한다.\n\n## 예제 입력 1\n\n```\n\n8\n1 6 2 5 7 3 5 6\n\n```\n\n## 예제 출력 1\n\n```\n\n5\n\n```\n\n## 예제 입력 2\n\n```\n\n10\n1 2 3 4 5 6 7 8 9 10\n\n```\n\n## 예제 출력 2\n\n```\n\n10\n\n```\n\n## 출처\n\n- 잘못된 데이터를 찾은 사람: tncks0121  \n- 빠진 조건을 찾은 사람: luniro  \n\n## 알고리즘 분류\n\n- 다이나믹 프로그래밍  \n- 가장 긴 증가하는 부분 수열 문제  \n\n## 풀이\n\n이 문제의 풀이는 간단하다. 이것은 **특정 상자 이전에 있는** 그 상자보다 작은 것을 for문으로 순회하면서 그러한 상태를 발견하면 **현재 상자** 위치의 상자 수보다 **이전 상자 위치의 상자 수 + 1** 이 더 큰지 확인 후 최대를 골라 상태를 업데이트한다.\n아래 코드를 보면 아주 명확하게 나와 있다.\n이러한 조건은\n- 상자들을 순회해야 하니 전범위 인덱싱\n  - 상자들보다 이전에 있는 것을 순회해야 하니 부분 인덱싱\n  - 조건에 맞는 처리\n\n를 하는 것이 중요하다. 비슷한 유형의 문제를 풀어 보는 것이 중요하고, 이런 유형의 수열 문제는 템플릿으로 암기하는 것 역시 권장한다.\n\n## 코드\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define max(x, y) ((x) > (y)) ? (x): (y)\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n\n    int *arr = malloc(sizeof(int) * n);\n    int boxes = 0;\n    int *total_boxes = calloc(n, sizeof(int));\n\n    for(int i = 0; i < n; i++) {\n        scanf(\"%d\", arr + i);\n    }\n\n    for(int k = 0; k < n; k++) {\n        for(int i = 0; i < k; i++) {\n            if(arr[i] < arr[k]) {\n                total_boxes[k] = max(total_boxes[i] + 1, total_boxes[k]);\n            }\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        boxes = max(total_boxes[i], boxes);\n    }\n    ++boxes;\n    printf(\"%d\", boxes);\n    free(total_boxes);\n    free(arr);\n    return 0;\n}\n```\n"
    },
    {
      "title": "[다이내믹] 가장 긴 감소하는 부분 수열-백준 11053번",
      "subtitle": "전형적인 DP, 가장 긴 감소하는 부분수열",
      "description": null,
      "url": "/codingtest/2026-01-26-[다이내믹]-가장-긴-감소하는-부분-수열-백준-11053번/",
      "collection": "codingtest",
      "relative_path": "2026-01-26-[다이내믹]-가장-긴-감소하는-부분-수열-백준-11053번",
      "date": "2026-01-26T12:20:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "수열"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "가장 긴 감소하는 부분 수열 --- 시간 제한 / 메모리 제한 / 제출 / 정답 / 맞힌 사람 / 정답 비율 | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 | | ----- | ------ | ----- | ----- | ----- | ------- | | 1 초 | 256 MB | 43934 | 27067 | 22278 | 62.538% | --- 문제 수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {…",
      "search_text": "[다이내믹] 가장 긴 감소하는 부분 수열-백준 11053번 전형적인 dp, 가장 긴 감소하는 부분수열 동적 프로그래밍 dp 백준 알고리즘 수열 codingtest codingtest algorithm-dp 가장 긴 감소하는 부분 수열 --- 시간 제한 / 메모리 제한 / 제출 / 정답 / 맞힌 사람 / 정답 비율 | 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 | | ----- | ------ | ----- | ----- | ----- | ------- | | 1 초 | 256 mb | 43934 | 27067 | 22278 | 62.538% | --- 문제 수열 a가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 a = {… \n\n### 가장 긴 감소하는 부분 수열\n\n---\n\n### 시간 제한 / 메모리 제한 / 제출 / 정답 / 맞힌 사람 / 정답 비율\n\n| 시간 제한 | 메모리 제한 | 제출    | 정답    | 맞힌 사람 | 정답 비율   |\n| ----- | ------ | ----- | ----- | ----- | ------- |\n| 1 초   | 256 mb | 43934 | 27067 | 22278 | 62.538% |\n\n---\n\n## 문제\n\n수열 a가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 a = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분 수열은 a = {10, 30, 10, 20, 20, 10} 이고, 길이는 3이다.\n\n---\n\n## 입력\n\n첫째 줄에 수열 a의 크기 n (1 ≤ n ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 a를 이루고 있는 ai가 주어진다. (1 ≤ ai ≤ 1,000)\n\n---\n\n## 출력\n\n첫째 줄에 수열 a의 가장 긴 감소하는 부분 수열의 길이를 출력한다.\n\n---\n\n## 예제 입력 1\n\n```text\n6\n10 30 10 20 20 10\n```\n\n## 예제 출력 1\n\n```text\n3\n```\n\n---\n\n## 출처\n\n문제를 만든 사람: baekjoon\n\n---\n\n## 비슷한 문제\n\n* 11053번. 가장 긴 증가하는 부분 수열\n* 11054번. 가장 긴 바이토닉 부분 수열\n* 11055번. 가장 큰 증가하는 부분 수열\n* 12015번. 가장 긴 증가하는 부분 수열 2\n* 12738번. 가장 긴 증가하는 부분 수열 3\n* 14002번. 가장 긴 증가하는 부분 수열 4\n* 14003번. 가장 긴 증가하는 부분 수열 5\n\n---\n\n## 알고리즘 분류\n\n* 다이나믹 프로그래밍\n\n## 풀이\n이것은 간단한 원리로 구현을 할 수 있다.\n- 각 인덱스를 순회를 돈다\n  - 현재 인덱스보다 이전에 놓여있으면서 그 값이 지금 인덱스보다 크면 길이를 1 증가\n\n최종적으로 나온 길이들 중 최댓값을 찾고, 1을 더하며 바로 정답이다.\n1을 더하는 까닭은 입력이 없는 경우가 문제에서 없으니 길이가 0인 경우가 없기 때문이다.\n여기까지의 모든 설명을 보면 가장 긴 증가하는 부분 수열과의 차이는 값이 지금 인덱스보다 클 때, 작을 때 조건 방향일 뿐이다.\n이것과 정확히 같은 방식으로 하되 부등호만 바꾸면 백준 상자넣기나 가장 긴 증가하는 부분 수열을 풀 수 있다.\n그러나 가장 긴 증가하는 부분수열 2와 같은 것은 dp가 아닌 이분탐색을 이용하기 때문에 풀 수 없다.\n\n## 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define max(x, y) ((x) > (y)) ? (x):(y)\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int *a  = calloc(n, sizeof(int));\n    int *dp = calloc(n, sizeof(int));\n\n    for(int i = 0; i < n; i++) scanf(\"%d\", a + i);\n\n    for(int k = 0; k < n; k++) {\n        for(int i = 0; i < k; i++) {\n            if(a[i] > a[k]) dp[k] = max(dp[i] + 1, dp[k]);\n        }\n    }\n    int result = 0;\n    for(int i = 0; i < n; i++) {\n        result = max(result, dp[i]);\n\n    }\n\n    result++; // minimum: 1\n    printf(\"%d\", result);\n    return 0;\n\n}\n``\n"
    },
    {
      "title": "[다이내믹] 가장 긴 증가하는 부분 수열-백준 11053번",
      "subtitle": "전형적인 DP, 가장 긴 증가하는 부분수열",
      "description": null,
      "url": "/codingtest/2026-01-26-[다이내믹]-가장-긴-증가하는-부분-수열-백준-11053번/",
      "collection": "codingtest",
      "relative_path": "2026-01-26-[다이내믹]-가장-긴-증가하는-부분-수열-백준-11053번",
      "date": "2026-01-26T12:20:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "수열"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "문제 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다. 입력 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000) 출력 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를…",
      "search_text": "[다이내믹] 가장 긴 증가하는 부분 수열-백준 11053번 전형적인 dp, 가장 긴 증가하는 부분수열 동적 프로그래밍 dp 백준 알고리즘 수열 codingtest codingtest algorithm-dp 문제 수열 a가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 a = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 a = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다. 입력 첫째 줄에 수열 a의 크기 n (1 ≤ n ≤ 1,000)이 주어진다. 둘째 줄에는 수열 a를 이루고 있는 ai가 주어진다. (1 ≤ ai ≤ 1,000) 출력 첫째 줄에 수열 a의 가장 긴 증가하는 부분 수열의 길이를… \n\n## 문제\n\n수열 a가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.\n\n예를 들어, 수열 a = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 a = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.\n\n## 입력\n\n첫째 줄에 수열 a의 크기 n (1 ≤ n ≤ 1,000)이 주어진다.\n\n둘째 줄에는 수열 a를 이루고 있는 ai가 주어진다. (1 ≤ ai ≤ 1,000)\n\n## 출력\n\n첫째 줄에 수열 a의 가장 긴 증가하는 부분 수열의 길이를 출력한다.\n\n## 예제 입력 1\n\n```\n\n6\n10 20 10 30 20 50\n\n```\n\n## 예제 출력 1\n\n```\n\n4\n\n```\n\n## 출처\n\n- 문제를 만든 사람: baekjoon  \n- 데이터를 추가한 사람: harinboy  \n\n## 비슷한 문제\n\n- 11054번. 가장 긴 바이토닉 부분 수열  \n- 11055번. 가장 큰 증가하는 부분 수열  \n- 11722번. 가장 긴 감소하는 부분 수열  \n- 12015번. 가장 긴 증가하는 부분 수열 2  \n- 12738번. 가장 긴 증가하는 부분 수열 3  \n- 14002번. 가장 긴 증가하는 부분 수열 4  \n- 14003번. 가장 긴 증가하는 부분 수열 5  \n\n## 알고리즘 분류\n\n- 다이나믹 프로그래밍 \n\n## 풀이\n이것은 간단한 원리로 구현을 할 수 있다.\n- 각 인덱스를 순회를 돈다\n  - 현재 인덱스보다 이전에 놓여있으면서 그 값이 지금 인덱스보다 작으면 길이를 1 증가\n\n최종적으로 나온 길이들 중 최댓값을 찾고, 1을 더하며 바로 정답이다.\n1을 더하는 까닭은 입력이 없는 경우가 문제에서 없으니 길이가 0인 경우가 없기 때문이다.\n이것들을 기반하여 코드를 작성해 보자.\n*보다 나은 수준의 설명은 아래로 내려서 관련 문서에서 상자 비유로 확인해 보도록 하자.*\n\n## 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n#define max(x, y) ((x) > (y)) ? (x):(y)\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int *a  = calloc(n, sizeof(int));\n    int *dp = calloc(n, sizeof(int));\n\n    for(int i = 0; i < n; i++) scanf(\"%d\", a + i);\n\n    for(int k = 0; k < n; k++) {\n        for(int i = 0; i < k; i++) {\n            if(a[i] < a[k]) dp[k] = max(dp[i] + 1, dp[k]);\n        }\n    }\n    int result = 0;\n    for(int i = 0; i < n; i++) {\n        result = max(result, dp[i]);\n\n    }\n\n    result++; // minimum: 1\n    printf(\"%d\", result);\n    return 0;\n\n}\n```\n"
    },
    {
      "title": "Personal Software From AI Sketch to Usable Software",
      "subtitle": null,
      "description": null,
      "url": "/devnote/2026-01-26-Personal-Software-From-AI-Sketch-to-Usable-Software/",
      "collection": "devnote",
      "relative_path": "2026-01-26-Personal-Software-From-AI-Sketch-to-Usable-Software",
      "date": "2026-01-26T12:00:00+09:00",
      "updated": null,
      "keywords": [
        "AI Coding",
        "Software Development",
        "Personal Project"
      ],
      "categories": [
        "devnote"
      ],
      "taxonomy": {
        "category": "devnote",
        "subcategory": "general",
        "order": 1
      },
      "difficulty": "easy",
      "excerpt": "Is AI Coding bad for you? In many cases, AI Coding is not beneficial to you, if you don't try to read your code and just abandon what you've done. If you are struggling with a language that you don't know, there will be no way to manually debug, and reproduce what bugs are happen…",
      "search_text": "personal software from ai sketch to usable software ai coding software development personal project devnote devnote general is ai coding bad for you? in many cases, ai coding is not beneficial to you, if you don't try to read your code and just abandon what you've done. if you are struggling with a language that you don't know, there will be no way to manually debug, and reproduce what bugs are happen… \n\n## is ai coding bad for you?\n\nin many cases, ai coding is not beneficial to you, if you don't try to read your code and just abandon what you've done.\nif you are struggling with a language that you don't know, there will be no way to manually debug, and reproduce what bugs are happening.\n\ni'll introduce two opposite tasks: ssh-chatter, and chatter-web.\n\n## ssh-chatter\n\nssh-chatter is a modern bbs written in c23, with ai copilot.\ni completed this project just within 6 months with ai, but there were more than just prompting.\nai produces many c codes that cause memory leaks, double free, null pointer dereference, and so on.\n\nin these cases, a developer faces three choices depending on what actually happened to the project.\n\n## chatter web\n\nchatter web was a front-end application for ssh-chatter written in javascript.\nat first, i was planning to release qt frontend of my bulletin board(which was quite successful).\nbut it is hard to 'persuade' people to install the application, i planned to switch a board to the website.\n\nthere were problems while i try this project, which eventually led me to abandon this.\n\nhere are the reasons why i quit this project.\n- i am not good at front-end development\n- i don't know anything about xterm.js\n- it was hard to accurately handle tcp echo back with node.js\n  - and i am not good at javascript when compared to my ability to program in c/c++.\n\n## how to refactor bugs with ai coding tools?\nin many cases, people use ai copilots/coding tools to find, and resolve bugs on their software; but it doesn't work well for machine-friendly languages like c, c++, rust, zig.\nbut this doesn't mean there are no benefits when developing with machine-friendly languages.\nwhen you develop with those sorts of languages, you should notice which tools are available.\nin my case, when i develop in c, i use valgrind to check memory leaks.\nthen when i give a prompt to an ai copilot, it is natural to notice that valgrind is available on my system.\n\n*(here i use \"machine-friendly\" to mean high-level languages that still\nexpose the machine model directly, such as c, rust, and zig)*\n\nalso, you should plan what to do after noticing what kinds of bugs are in your source code.\n\n### case 1. typical bugs\n\nthis kind of bug is easy to solve with ai. if a developer tells to ai that it can debug a program with `valgrind`(or provides log.txt to solve), ai will scan many codes and point where was the problem.\nif the program is okay with this step, you can go on.\n\n### case 2. ai's solution is too complex\n\nsometimes, ai does not delete the problem; it overwrites problematic actions by other safe codes.\nwhen you fall into this step, you must check where is the location that produces certain amounts of bugs, and tackle down each problem while scrolling down a hierarchy.\n\nthis is a demo problem that can be easily caused by ai copilots.\n\n```c\nint func1(char r, char *msg) {\n    // point 1: no null check\n    msg[0] ^= r;\n \n}\n \nint func2(char *msg) {\n    // do_some_tasks\n    free(msg);\n    return 0;\n \n}\n    \nint func3(char *msg) {\n    // do_some_tasks\n    func2(msg);\n    // do_some_tasks\n    \n    // point 2: msg is null!\n    func1((char) 233, msg);\n    // point 3: double free\n    free(msg);\n```\n\nat first, valgrind will detect func3's null pointer dereference.\nthen you shall remove `point 2` to solve the problem.\nnow, this is the problem: 'point 1 and point 3'.\nwhen you just remove `point 1` and `point 3` without following a context, msg is never freed on your program.\nso what you need to trace is a context:\n\n- func3 is called by another function\n  - read a bug `null pointer dereference` on line xx\n    - check `free`\n  - trace a function or a macro on line xx\n    - check `free`\n  - trace a function before line xx\n    - check `free`\n  - check `free` on current function\n- draw a sequential context\n- specify when is the end of your variable's lifecycle\n- check and remove duplicate `free` calls that do not fit in the variable’s lifecycle\n\n\n## how to code a prompt\n\nmany people would not agree that `prompting is similar to traditional context/structure engineering`.\nhowever, ai definitely needs `what is specifically required` to make a code that you would expect.\nin other words, **do not order a code that you will never imagine**.\n\n### good prompting\n\n```text\nyou are a junior engineer at low-level software development.\nyou are developming a minimal text editor without lsp/treesitter that is expected to run inside of docker/lxc.\nyou must develop a simple bracket parser with a simple rule:\n- when opening brace, indent next line.\n- when closing brace, deindent next line.\n- do not touch closed brackets.\n\nyou may match each braces using a stack in this order:\n    - push an opening brace\n    - pop after reading closing brace\n\nyou must not attach external lsp/treesitter to implement this feature, since it must be portable on a specific environment such as `musl-based container os'.\nadd a comment on each step and make a documentation about functions at docs as a form of markdown.\n```\n\nthis prompt shows 'what to implement' in english, which is preferable for ai prompting.\nalso, this feature does not require destructive action when coding, the prompt should not declare a copilot as a senior engineer.\nif you are trying to handle special types of environment which does not use standard glibc, you should tell what is actually used while clarifying keywords like `musl`.\n\n\n### bad prompting\n\n```text\nimplement a bracket parser for this editor. this must be okay with docker compose.\n```\n\n\nthis does not show what is required for which container's compatibility.\nai copilot would imply that the target container image is ubuntu/xx.xx format(which uses glibc), as a result the output may not work in a good manner when compiled using musl target.\nalso, there is no steps to teach 'how to write'.\nthis means you cannot expect ai copilot's result.\n\n## what is sustainable structure?\n\nunlike famous open source projects, your own projects are prone to specification changes, library version up, and numerous external pressure when continuing it.\nif it is a personal software and you cannot handle massive changes, you should *keep it simple*.\n\ni keep these concepts to code my own projects:\n\n- functions should be kept in a small behavior\n- when a project is forked from origin, be sure to 'extend' it over rewriting whole base.\n- hidden structures are not preferable for long-term maintenance\n- use a language that you can do well\n\n## why personal tools matter even 'more' in the age of ai\n\nfirst-class chefs grind one's own knife to cook better.\nalso, first-class programmers write one's own program to code better.\n\nhowever, contrary to well-ground knives, various kinds of personal software are usually considered as `unnecessarily complex chores`.\nmany coding tools like vscode, vim, emacs, codex cli...all of them are well-ground knives **from mass-production factories**.\nthis means when you grind them properly, you may get benefits while programming.\n\nin my case, text editors matter when i write code.\ni started developing my own editor with `torvalds/uemacs` base; and surprisingly, the result that i obtained was quite different from original microemacs maintained by linus torvalds.\nevery developers have their own patterns when reading, and writing what they aim for.\n\ni am pretty sure developing your own software to benefit your workflows will help.\n\n## ai opened a new era: diy, personalized tools\n\nwhen using ai copilots, you can even develop your own tools within few months.\ncontrary to 2010s, many kinds of bugs are well-trained inside of ai weights. consequently, needs of debugging whole codes like playing a one-man show, can be easily replaced by global ai models.\nalthough there are many side-effects while including legal conflicts, ai is good news for lonely amateurs who work for themselves.\n\nin 2010s, making their own tools to enhance ux just for themselves was challenging; so if they pay a same amount of attention to their 'starred' project to fill their portfolio, they could code a whole website.\nbut in 2020s, people just can 'order' a tiny tools when they need. this is a huge change since the industrial revolution.\n\ni am pretty sure this technology may change the way we develop more and more.\n\nwe can simply consume ai-generated products if we choose to.\nbut in this paradigm, we can also reproduce them, as long as we can imagine.\n\nso, to cope with these changes, make your own stuff and enjoy, even if it never gets github stars from others.\n"
    },
    {
      "title": "[다이내믹] 정수 삼각형-백준 1932번",
      "subtitle": "동적 프로그래밍에 그리디 알고리즘을 더해 보자.",
      "description": null,
      "url": "/codingtest/2026-01-25-[다이내믹]-정수-삼각형-백준-1932번/",
      "collection": "codingtest",
      "relative_path": "2026-01-25-[다이내믹]-정수-삼각형-백준-1932번",
      "date": "2026-01-25T15:00:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "그리디"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "정수 삼각형 위 그림은 크기가 5인 정수 삼각형의 한 모습이다. 맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽 에 있는 것 중에서만 선택할 수 있다. 삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다. --- 입력 첫째 줄에 삼각형의 크기…",
      "search_text": "[다이내믹] 정수 삼각형-백준 1932번 동적 프로그래밍에 그리디 알고리즘을 더해 보자. 동적 프로그래밍 dp 백준 알고리즘 그리디 codingtest codingtest algorithm-dp 정수 삼각형 위 그림은 크기가 5인 정수 삼각형의 한 모습이다. 맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽 에 있는 것 중에서만 선택할 수 있다. 삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다. --- 입력 첫째 줄에 삼각형의 크기… \n\n# 정수 삼각형\n\n위 그림은 크기가 5인 정수 삼각형의 한 모습이다.\n\n```\n7\n3   8\n8   1   0\n2   7   4   4\n4   5   2   6   5\n```\n맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때,  \n이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라.  \n\n아래층에 있는 수는 현재 층에서 선택된 수의 **대각선 왼쪽 또는 대각선 오른쪽**에 있는 것 중에서만 선택할 수 있다.\n\n삼각형의 크기는 1 이상 500 이하이다.  \n삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.\n\n---\n\n## 입력\n\n첫째 줄에 삼각형의 크기 `n` (1 ≤ n ≤ 500)이 주어지고,  \n둘째 줄부터 `n+1`번째 줄까지 정수 삼각형이 주어진다.\n\n---\n\n## 출력\n\n첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.\n\n---\n\n## 예제 입력 1\n\n```\n5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n\n```\n\n## 예제 출력 1\n\n```\n30\n```\n\n---\n\n## 출처\n\n- olympiad > international olympiad in informatics > ioi 1994 > day 1 1번  \n- olympiad > usa computing olympiad > 2005-2006 season > usaco december 2005 contest > bronze ?번  \n- olympiad > usa computing olympiad > 1999-2000 season > usaco fall 1999 contest > gold 1번  \n\n문제의 오타를 찾은 사람: apjw6112, martian, paranocean  \n잘못된 데이터를 찾은 사람: thanatos0128  \n잘못된 조건을 찾은 사람: djm03178  \n데이터를 추가한 사람: eunhyekim1223, hwangtmdals  \n\n---\n\n## 알고리즘 분류\n\n- 다이나믹 프로그래밍\n\n\n\n## 문제 풀이\n\n오늘 간만에 다이내믹 프로그래밍, 즉 동적 계획법을 다룬다.\n쉬운 동적 계획법 문제들은 대체로 그냥 무작정 앞에 것에 뒤에 것을 더하는 방식으로 진행되는 경우가 잦다.\n그러나 중급 난이도에서는 반드시 생각해야 할 것이 있다.\n\n- 상향식 vs 하향식\n- 현재 줄 vs 다음 줄\n- 현재 줄에 더함 vs 다음 줄에 더함\n- 그리디 범위\n  - 둘 혹은 여럿 중 하나를 더할지 말지 조건이 복잡한 그리디\n  - 둘 혹은 여럿 중 최대/최소/평균처럼 명확한 조건으로 더하는 그리디\n    - 이 때는 바로 조건문 걸기 전에 `max`, `min`, `sum(arr) / arr_len`\n    - 그래도 안 될 느낌일 때 조건문 분기\n\n이러한 방향으로 사고 체계를 잡아야 한다.\n\n이 문제는 삼각형에서 규칙을 따라 올라갔을 때의 최대 합을 구하는 것이다.\n이 경로를 구하는 방법은 조금 사고력이 필요하다.\n\n### 접근법\n\n맨 아랫줄 **바로 이전부터 시작한다.**\n\n- 맨 아랫줄 바로 이전 특정 칸 ㄱ에서\n  - 맨 아랫줄의 움직일 수 있는 칸에 쓰인 값 중 최대를 찾는다.\n  - 최대를 현재 칸 ㄱ에 더해 준다.\n\n이러한 가벼운 형태의 그리디로 동작한다.\n이런 코드 유형은 그다지 암기할 것도 아니고 기억 및 숙달만 간단히 해 주면 익힐 수 있다.\n\n다시 한 번 말하지만 접근법을 손보단 머리가 기억하고 있어야 한다.\n\n다른 모든 방법들보다 좋은 것은 직접 작성해 보는 것이다. 실제 구현된 c언어 답안을 보면서 따라가자.\n\n## c언어 답안\n\n```c\n#include <stdio.h>\n#include <string.h>\n\n#define max(x, y) (((x) > (y)) ? (x) : (y))\n\ntypedef struct position {\n    int x;\n    int y;\n} pos_t;\n\n// when solving a coding test, clarifying each boundaries are important.\n// declare get_l_pos and get_r_pos to prevent spaghetti code.\n\n// move a position(leftwards, strictly down)\npos_t get_l_pos(pos_t p) {\n    pos_t l_pos = p;\n    // only increases y, so it can drop down vertically\n    l_pos.y++;\n    return l_pos;\n}\n\n// move a position(rightwards, horizontally move after stepping down a location.)\n\npos_t get_r_pos(pos_t p) {\n    pos_t r_pos = get_l_pos(p);\n    // step a. get_l_pos to drop a row.\n    // step b. increment x variable to move right.\n    r_pos.x++;\n    return r_pos;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    // an array to hold 'an integer triangle'\n    long arr[n+1][n+1]; // 1 <= n <= 500, max size == (500 * 500) / 2 == 125000 (unit: 64-bit integer)\n    memset(arr, 0, sizeof(arr));\n    // in this scenario, this uses 1-based index.\n    // max size is 251001 * 8 byte, 2008008 byte. near 2-2.5 mb(approx.)\n    for(int i = 1; i <= n; i++) {\n        for(int j = 1; j <= i; j++) {\n            scanf(\"%ld\", &arr[i][j]);\n        }\n    }\n\n    // exclude last line, last line has no route\n    for(int i = n - 1; i >= 1; i--) {\n        for(int j = i; j >= 1; j--) {\n            pos_t p;\n            p.x = j; // col\n            p.y = i; // row\n            pos_t l_pos = get_l_pos(p); // get left move\n            pos_t r_pos = get_r_pos(p); // get right move\n\n            // implement 'greedy' method\n            // if this cannot traverse full directions, just add current value to next position.\n            // greedy was selected to prevent potential weight contamination\n            long l_pos_new_val = arr[l_pos.y][l_pos.x] + arr[p.y][p.x];\n            long r_pos_new_val = arr[r_pos.y][r_pos.x] + arr[p.y][p.x];\n\n            arr[p.y][p.x] = max(l_pos_new_val, r_pos_new_val);\n\n        }\n    }\n\n    // prints max value\n    printf(\"%ld\", arr[1][1]);\n\n    return 0;\n\n}\n```\n\n코드 역시 주석을 상세하게 달아 두었다. 이것으로 복습은 충분할 것이다.\n\n## p.s\n\n이 게시물은 현재 활발하게 개발 중인 nanox 에디터로 작성되었다.\n아래 링크를 참고하기 바란다.\n\n[nanox editor](https://github.com/gg582/nanox)\n"
    },
    {
      "title": "[벨만포드] 벨만포드 알고리즘을 외워 보자",
      "subtitle": "코드 암기는 언제나 구조적으로",
      "description": null,
      "url": "/codingtest/2026-01-24-[벨만포드]-벨만포드-알고리즘을-외워보자/",
      "collection": "codingtest",
      "relative_path": "2026-01-24-[벨만포드]-벨만포드-알고리즘을-외워보자",
      "date": "2026-01-24T14:35:00+09:00",
      "updated": null,
      "keywords": [
        "벨만포드",
        "그래프 탐색",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-bellman-ford",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "--- 왜 암기를 하죠? 물론 필자는 수학 공부를 그렇게 열심히 하지는 않았으나, 중고등학교 수학에 비유해 보도록 하겠다. 이 글을 읽는 사람들 대부분이 과정을 따라가면 피타고라스 정리의 공식을 구할 수 있다. 그러나 한 번 도출된 공식이 있으면 그것을 암기해서 사용하지 삼각형부터 그리고 보지는 않는다. 여기서 보통 사람들은 정석적인 유클리드의 방식을 따라가서 피타고라스 정리를 외운다. 그런 방식으로 외우는 것이 정석이니까 다들 그렇게 하였다. 그러나 필자는 수학에 아주 약하기 때문에 직관적으로…",
      "search_text": "[벨만포드] 벨만포드 알고리즘을 외워 보자 코드 암기는 언제나 구조적으로 벨만포드 그래프 탐색 백준 알고리즘 codingtest codingtest algorithm-bellman-ford --- 왜 암기를 하죠? 물론 필자는 수학 공부를 그렇게 열심히 하지는 않았으나, 중고등학교 수학에 비유해 보도록 하겠다. 이 글을 읽는 사람들 대부분이 과정을 따라가면 피타고라스 정리의 공식을 구할 수 있다. 그러나 한 번 도출된 공식이 있으면 그것을 암기해서 사용하지 삼각형부터 그리고 보지는 않는다. 여기서 보통 사람들은 정석적인 유클리드의 방식을 따라가서 피타고라스 정리를 외운다. 그런 방식으로 외우는 것이 정석이니까 다들 그렇게 하였다. 그러나 필자는 수학에 아주 약하기 때문에 직관적으로… \n\n---\n\n## 왜 암기를 하죠?\n\n물론 필자는 수학 공부를 그렇게 열심히 하지는 않았으나, 중고등학교 수학에 비유해 보도록 하겠다.\n이 글을 읽는 사람들 대부분이 과정을 따라가면 피타고라스 정리의 공식을 구할 수 있다.\n그러나 한 번 도출된 공식이 있으면 그것을 암기해서 사용하지 삼각형부터 그리고 보지는 않는다.\n\n여기서 보통 사람들은 정석적인 유클리드의 방식을 따라가서 피타고라스 정리를 외운다.\n\n그런 방식으로 외우는 것이 정석이니까 다들 그렇게 하였다.\n그러나 필자는 수학에 아주 약하기 때문에 직관적으로 이해할 수 있는 방식으로 바스카라의 정리(바스카라에 정리되기 전부터 인도에 널리 퍼져 있던 방식이고, 후일 중국에서도 구고현의 정리가 같은 방식으로 이 공식을 증명한다)를 사용했다.\n\n그러나 거시적인 내용은 비슷한 시기의 서로 다른 대륙들의 정리 역시 같고, 결국 `a^2 + b^2 == c^2`으로 귀결된다.\n\n이것과 정확히 동일하게 여기서는 **아주 쉽게** 단일 소스 최소 경로(sssp) 문제를 위한 벨만포드 알고리즘을 구현하고 외우도록 하겠다.\n\n## 구조화해서 외우자\n\n### 삼항연산자는 죄가 없다\n\n의외로 한 번 정도의 간단한 조건을 암기할 때 삼항연산자는 크게 도움이 되고, 블럭 형태로 잘 들여쓰기하면 가독성도 무난하다.\n\n\n예를 들어서, `a+b < c`일 때 `c = a+b`를 한다고 해 보자. 여기서 자연어에 대응하면서 비교해 볼 것이다.\n\n### if문\n\n```c\n\n```\n\n한국어로 하면 아래와 같다.\n**만약** *a + b* 가 c*보다 작다면* **c는 a+b이다.**\n\n너무 말을 풀어 쓰니 조건 반영이 눈에 띄게 구조적이지 못하다.\n\n### 삼항연산자\n\n```c\nc = (a + b) < c ?\n    (a + b) : c ;\n```\n\nc는 ** a + b **보다 c가 작을 때** **a + b**, 아니면 **c값 그대로이다.**\n\n말이 길어 보이지만 확실히 구조적으로 인지 가능하고, 부등호 조건에서 min일 때 **a < b**꼴로, max일 때 **a > b** 꼴로 쓰면 아래가 기억이 안 나도 **a : b;**로 끝내 버리면 된다.\n**즉 외워야 할 포인트가 반토막난다.**\n\n### 삼항연산자 + 매크로\n\n```c\n#define min(x, y) (((x) < (y)) ? \\\n                   (x) :  (y))\n#define max(x, y) (((x) > (y)) ? \\\n                   (x) :  (y))\n\nc = min(a + b, c);\n```\n\n\n상단에 매크로만 추가하고 나면 아주 명료하다,\n\nc는 **a + b와 c 중에 작은 것이다**.\n\n그야말로 더 불평할 것이 없는 수준에 이르렀다.\n\n이제 이와 같이 코드 작성을 해 보자. 아래의 벨만포드는 최대한 암기하기 쉽게 정리했으니 잘 생각하고 외워야 한다.\n\n\n##벨만 포드 알고리즘\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define min(x, y) (((x) < (y)) ? (x) : (y))\n\ntypedef long long ll;\n\ntypedef struct {\n    int u, v;\n    ll w;\n} edge;\n\n#define inf (llong_max / 4)\n\nint bellman_ford_sssp(int n, int m, const edge *edges, int src, ll *dist) {\n    for (int i = 0; i < n; i++) dist[i] = inf;\n    dist[src] = 0;\n\n    for (int i = 0; i < n - 1; i++) {\n        int updated = 0;\n        for (int j = 0; j < m; j++) {\n\n            if (dist[edges[j].u] == inf) continue;\n\n            int current_update = (int)((_bool)((dist[edges[j].u] + edges[j].w) < dist[edges[j].v]));\n\n            updated |= current_update;\n\n            dist[edges[j].v] = min(\n                dist[edges[j].u] + edges[j].w,\n                dist[edges[j].v]\n            );\n        }\n        if (!updated) break;\n    }\n\n    // negative cycle detection (usually unnecessary in coding tests)\n    for (int k = 0; k < m; k++) {\n        if (dist[edges[k].u] == inf) continue;\n        if (dist[edges[k].u] + edges[k].w < dist[edges[k].v]) {\n            return 0; // negative cycle reachable\n        }\n    }\n    return 1;\n}\n\nint main(void) {\n    int n, m;\n    if (scanf(\"%d %d\", &n, &m) != 2) return 0;\n\n    edge *edges = (edge *)malloc((size_t)m * sizeof(edge));\n    if (!edges) return 0;\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %lld\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    int src;\n    scanf(\"%d\", &src);\n\n    ll *dist = (ll *)malloc((size_t)n * sizeof(ll));\n    if (!dist) {\n        free(edges);\n        return 0;\n    }\n\n    if (!bellman_ford_sssp(n, m, edges, src, dist)) {\n        puts(\"negative_cycle\");\n    } else {\n        for (int i = 0; i < n; i++) {\n            if (dist[i] >= inf / 2) printf(\"inf\\n\");\n            else printf(\"%lld\\n\", dist[i]);\n        }\n    }\n\n    free(dist);\n    free(edges);\n    return 0;\n}\n```\n\n이 방식대로 외우면 플로이드 워셜로 풀 수 없으나 다익스트라를 잊어먹어도 풀 수 있는 문제들에서 꽤 효율적이다.\nn이 500-800 사이인 그래프 탐색 문제에서 푼다면 아슬아슬하게 공간복잡도와 시간복잡도 역시 통과할 수 있다.\n"
    },
    {
      "title": "[다익스트라] 다익스트라 알고리즘을 외워 보자",
      "subtitle": "중견 기업 코딩 테스트까지 노려 보자",
      "description": null,
      "url": "/codingtest/2026-01-24-[다익스트라]-다익스트라-알고리즘을-외워보자/",
      "collection": "codingtest",
      "relative_path": "2026-01-24-[다익스트라]-다익스트라-알고리즘을-외워보자",
      "date": "2026-01-24T13:00:00+09:00",
      "updated": null,
      "keywords": [
        "다익스트라",
        "그래프 탐색",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dijkstra",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "--- 이 게시물부터 보는 사람은 반드시 스크롤을 내려서 이전 게시물의 \"왜 암기를 하죠?\" 부분을 잘 읽고 오기 바란다. 다익스트라를 암기해 보자 드디어 정리해도 어렵고 또 어려운 대망의 다익스트라이다. 대기업이나 중견기업 코딩 테스트에서 수험자를 죽이려고 마구마구 찍어내는 지옥 난이도 문제들은 보통 \"다익스트라 + 비트마스킹 + DP + 그리디 + 파싱\"같은 조합을 쓰고, 일단 다익스트라부터 구현하고 DP나 그리디 구조 파악, 비트마스킹/파싱같은 자잘한 디테일을 잡아가는 방식을 취한다. 물론…",
      "search_text": "[다익스트라] 다익스트라 알고리즘을 외워 보자 중견 기업 코딩 테스트까지 노려 보자 다익스트라 그래프 탐색 백준 알고리즘 codingtest codingtest algorithm-dijkstra --- 이 게시물부터 보는 사람은 반드시 스크롤을 내려서 이전 게시물의 \"왜 암기를 하죠?\" 부분을 잘 읽고 오기 바란다. 다익스트라를 암기해 보자 드디어 정리해도 어렵고 또 어려운 대망의 다익스트라이다. 대기업이나 중견기업 코딩 테스트에서 수험자를 죽이려고 마구마구 찍어내는 지옥 난이도 문제들은 보통 \"다익스트라 + 비트마스킹 + dp + 그리디 + 파싱\"같은 조합을 쓰고, 일단 다익스트라부터 구현하고 dp나 그리디 구조 파악, 비트마스킹/파싱같은 자잘한 디테일을 잡아가는 방식을 취한다. 물론… \n\n---\n\n*이 게시물부터 보는 사람은 반드시 스크롤을 내려서 이전 게시물의 \"왜 암기를 하죠?\" 부분을 잘 읽고 오기 바란다.*\n\n## 다익스트라를 암기해 보자\n\n드디어 정리해도 어렵고 또 어려운 대망의 다익스트라이다.\n대기업이나 중견기업 코딩 테스트에서 수험자를 죽이려고 마구마구 찍어내는 지옥 난이도 문제들은 보통 \"다익스트라 + 비트마스킹 + dp + 그리디 + 파싱\"같은 조합을 쓰고, 일단 다익스트라부터 구현하고 dp나 그리디 구조 파악, 비트마스킹/파싱같은 자잘한 디테일을 잡아가는 방식을 취한다. 물론 내가 풀 수 있는 유형은 아니지만 보통은 그렇다. 그도 그럴 것이 그걸 풀 수 있었으면 인생이 달랐을지도 모르니까 말이다.\n\n어디까지나 나의 방법론은 **범부를 위한 코더 가이드**에 가깝다. 현학적이고 학구적인 태도에 내 방식은 정면으로 배치되는 것을 알아 뒀으면 좋겠다.\n\n## 암기 포인트\n\n- 애써서 힙을 구현하려 하지 말자\n  - 만약 당신이 고지능의 수재라면 직접 구현해서 성능을 뽑아도 된다\n- 현재 노드를 거쳐서 다음 노드로 가는게 기존 방법보다 빠르면\n  - 그 방식의 가중치로 업데이트한다.\n  - 이것을 `min`을 쓴다고 생각해서 단순하게 외우자\n- v, w같은 추상적인 축약은 쓰면 안 된다\n  - 반드시 vertex, weight로 다 써서 헷갈림을 방지하자\n\n지능이 높은 사람들의 특징이 추상화에 강한 것이다. 그러한 사람들은 u, v, w가 편하겠지만 우리에게는 아니다.\n이것은 평범하거나 그보다 못한 재능에서 출발한 내가 지키는 3원칙이다.\n\n- 변수명은 반드시 구체적이어야 한다\n- 코드에서 주석을 떼도 어느 정도 이해되어야 한다\n- 주석은 코드의 흐름을 따라야 한다\n\n이러한 3원칙을 어느 정도 지키며 작성된 다익스트라 알고리즘의 코드를 **주석을 잘 보면서** 따라오길 바란다.\n\n## 코드\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\n\ntypedef long long ll;\n\ntypedef struct {\n    int vertex;\n    ll  weight;\n} edge;\n\ntypedef std::pair<ll,int> pll;\ntypedef std::priority_queue<pll, std::vector<pll>, std::greater<pll>> pq_ll; // do not manually implement heap!!\n                                                                             // since importing external libraries in c is not allowed, using c++ instead, is much better for coding test\n\n#define inf (llong_max / 4)\n\nvoid dijkstra_sssp(int n, const std::vector<std::vector<edge>> &g, int src, std::vector<ll> &dist) {\n    dist.assign(n, inf);\n    dist[src] = 0;\n\n    pq_ll pq;\n    pq.push(pll(0, src)); // current distance is zero(before start: status zero), starting point is src\n\n    while (!pq.empty()) {\n        ll current_dist = pq.top().first;\n        int current_node = pq.top().second;\n        pq.pop(); // till here, same as bfs\n \n        if (current_dist != dist[current_node]) continue; // something like softer version of assert(current_dist == dist[currunt_size]), so current_dist must be dist[current_size] to apply for distance recheck/calculation\n\n        for (int i = 0; i < (int)g[current_node].size(); i++) {\n            // be sure to memorize this part\n            int next_node = g[current_node][i].vertex;\n            ll edge_weight = g[current_node][i].weight;\n\n            //  if getting next_node through current_node, update distance to current_dist + edge_weight;\n            int current_update = (int)((current_dist + edge_weight) < dist[next_node]);\n            dist[next_node] = std::min(current_dist + edge_weight, dist[next_node])   ;\n\n            if (current_update) pq.push(pll(dist[next_node], next_node)); // only if it is an update target\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int n, m;\n    std::cin >> n >> m;\n\n    std::vector<std::vector<edge>> g(n);\n\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        ll c;\n        std::cin >> a >> b >> c;     // 0-indexed: a -> b with weight c\n        g[a].push_back((edge){b, c}); // if directed, it's fine with this single line; but\n                                      // if undirected, also add below\n     // g[b].push_back((edge){a, c});\n    }\n\n    int src;\n    std::cin >> src;\n\n    std::vector<ll> dist;\n    dijkstra_sssp(n, g, src, dist);\n\n    for (int i = 0; i < n; i++) {\n        if (dist[i] >= inf / 2) std::cout << \"-1\\n\"; // no ways to arrive dist[i]\n        else std::cout << dist[i] << \"\\n\";\n    }\n    return 0;\n}\n```\n**주석 친 포인트가 중요하다. 확실히 보고 기억해야 한다.**\n\n## 소감\n\n이걸 외울 수 있을지 모르겠다. 빌 게이츠가 코드 검수할 때 종이에 출력해서 했다던데, 프린트해서 봐야 하나?\n책 10쪽을 외우는 것보다 이것 하나를 외우는 것이 더 고통스러울지도 모르는 일이다.\n열심히 해 보는 수밖에는 없지 않을까.\n"
    },
    {
      "title": "[시뮬레이션] 스위치 켜고 끄기-백준 1244번",
      "subtitle": "방심하지 말고 출력에 주의하자",
      "description": null,
      "url": "/codingtest/2026-01-22-[시뮬레이션]-스위치-켜고-끄기-백준-1244번/",
      "collection": "codingtest",
      "relative_path": "2026-01-22-[시뮬레이션]-스위치-켜고-끄기-백준-1244번",
      "date": "2026-01-22T16:22:00+09:00",
      "updated": null,
      "keywords": [
        "백준",
        "알고리즘",
        "시뮬레이션"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-simulation",
        "order": 1
      },
      "difficulty": "easy",
      "excerpt": "--- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 MB 94366 22036 16592 21.508% --- [백준] 1244번: 스위치 켜고 끄기 문제 1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. 에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성…",
      "search_text": "[시뮬레이션] 스위치 켜고 끄기-백준 1244번 방심하지 말고 출력에 주의하자 백준 알고리즘 시뮬레이션 codingtest codingtest algorithm-simulation --- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 128 mb 94366 22036 16592 21.508% --- [백준] 1244번: 스위치 켜고 끄기 문제 1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. 에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성… \n\n---\n\n<table>\n  <thead>\n    <tr>\n      <th>시간 제한</th>\n      <th>메모리 제한</th>\n      <th>제출</th>\n      <th>정답</th>\n      <th>맞힌 사람</th>\n      <th>정답 비율</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>2 초</td>\n      <td>128 mb</td>\n      <td>94366</td>\n      <td>22036</td>\n      <td>16592</td>\n      <td>21.508%</td>\n    </tr>\n  </tbody>\n</table>\n\n---\n\n# [백준] 1244번: 스위치 켜고 끄기\n\n## 문제\n\n1부터 연속적으로 번호가 붙어있는 스위치들이 있다. 스위치는 켜져 있거나 꺼져있는 상태이다. <그림 1>에 스위치 8개의 상태가 표시되어 있다. ‘1’은 스위치가 켜져 있음을, ‘0’은 꺼져 있음을 나타낸다. 그리고 학생 몇 명을 뽑아서, 학생들에게 1 이상이고 스위치 개수 이하인 자연수를 하나씩 나누어주었다. 학생들은 자신의 성별과 받은 수에 따라 아래와 같은 방식으로 스위치를 조작하게 된다.\n\n남학생은 스위치 번호가 자기가 받은 수의 배수이면, 그 스위치의 상태를 바꾼다. 즉, 스위치가 켜져 있으면 끄고, 꺼져 있으면 켠다. <그림 1>과 같은 상태에서 남학생이 3을 받았다면, 이 학생은 <그림 2>와 같이 3번, 6번 스위치의 상태를 바꾼다.\n\n여학생은 자기가 받은 수와 같은 번호가 붙은 스위치를 중심으로 좌우가 대칭이면서 가장 많은 스위치를 포함하는 구간을 찾아서, 그 구간에 속한 스위치의 상태를 모두 바꾼다. 이때 구간에 속한 스위치 개수는 항상 홀수가 된다.\n\n| 스위치 번호 | ① | ② | ③ | ④ | ⑤ | ⑥ | ⑦ | ⑧ |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 스위치 상태 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 |\n\n**<그림 1>**\n\n예를 들어 <그림 2>에서 여학생이 3을 받았다면, 3번 스위치를 중심으로 2번, 4번 스위치의 상태가 같고 1번, 5번 스위치의 상태가 같으므로, <그림 3>과 같이 1번부터 5번까지 스위치의 상태를 모두 바꾼다. 만약 <그림 2>에서 여학생이 4를 받았다면, 3번, 5번 스위치의 상태가 서로 다르므로 4번 스위치의 상태만 바꾼다.\n\n| 스위치 번호 | ① | ② | ③ | ④ | ⑤ | ⑥ | ⑦ | ⑧ |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 스위치 상태 | 0 | 1 | 1 | 1 | 0 | 1 | 0 | 1 |\n\n**<그림 2>**\n\n| 스위치 번호 | ① | ② | ③ | ④ | ⑤ | ⑥ | ⑦ | ⑧ |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 스위치 상태 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |\n\n**<그림 3>**\n\n입력으로 스위치들의 처음 상태가 주어지고, 각 학생의 성별과 받은 수가 주어진다. 학생들은 입력되는 순서대로 자기의 성별과 받은 수에 따라 스위치의 상태를 바꾸었을 때, 스위치들의 마지막 상태를 출력하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에는 스위치 개수가 주어진다. 스위치 개수는 100 이하인 양의 정수이다. 둘째 줄에는 각 스위치의 상태가 주어진다. 켜져 있으면 1, 꺼져있으면 0이라고 표시하고 사이에 빈칸이 하나씩 있다. 셋째 줄에는 학생수가 주어진다. 학생수는 100 이하인 양의 정수이다. 넷째 줄부터 마지막 줄까지 한 줄에 한 학생의 성별, 학생이 받은 수가 주어진다. 남학생은 1로, 여학생은 2로 표시하고, 학생이 받은 수는 스위치 개수 이하인 양의 정수이다. 학생의 성별과 받은 수 사이에 빈칸이 하나씩 있다.\n\n## 출력\n\n스위치의 상태를 1번 스위치에서 시작하여 마지막 스위치까지 한 줄에 20개씩 출력한다. 예를 들어 21번 스위치가 있다면 이 스위치의 상태는 둘째 줄 맨 앞에 출력한다. 켜진 스위치는 1, 꺼진 스위치는 0으로 표시하고, 스위치 상태 사이에 빈칸을 하나씩 둔다.\n\n## 예제 입력 1\n\n```text\n8\n0 1 0 1 0 0 0 1\n2\n1 3\n2 3\n\n```\n\n## 예제 출력 1\n\n```text\n1 0 0 0 1 1 0 1\n\n```\n\n## 출처\n\n* olympiad > 한국정보올림피아드 > koi 2000 > 초등부 2번\n\n## 알고리즘 분류\n\n* 구현\n* 시뮬레이션\n\n## 풀이\n말 그대로 써 주면 된다. 그러나 여학생이 어떻게 스위치를 끄는지에서 중앙을 중심으로 어떻게 나아갈지에 대해 당연히 헷갈릴 수밖에 없다.\n모든 조건을 깔끔하게 정리해 쓸 필요는 없다. 조건을 벗어나는 지점을 잡은 후 그 때에 더 이상 스위치를 끄거나 하지 못하게 막아 주면 된다.\n\n스위치를 키고 끄는 반복문 부분에서 아래와 같이 해 주면 된다.\n\n```c\nfor(int i = 1; i < switch_len; i++) {\n\n  // calculates  center.\n  // calculates left and right.\n  int left   =  center - i;\n  int right  = center + i;\n  if(\n     (left < 0)\n  || (right >= switch_len)\n  ) break;\n// 후략...\n}\n```\n\n마찬가지로 주의해야 할 것은 20글자씩 끊는 것이다.\n결과 스위치의 인덱스 나머지를 통한 접근을 생각해 냈다면 이것을 주의하자.\n\n아래와 같이 `(i != 0)` 조건을 검사해야 한다.\n이것을 하지 않으면 첫 줄에 개행이 끼어서 정답을 맞출 수 없다.\n\n```c\nfor(int i = 0; i < switch_len; i++) {\n  if(!(i%20) && (i != 0)) printf(\"%c\", '\\n');\n  printf((i%20) == 19? \"%d\":\"%d \",switch_status[i]);\n}\n```\n\n\n## 코드\n\n```c\n#include <stdio.h>\nint main()  {\n\n  // read switch len, switch_len <= 100, assigning int(int, 32-bit, signed) since index defaults to int\n  int switch_len;\n  scanf(\"%d\", &switch_len);\n\n  // read switch status\n  // input form distinguishes each button with ' '\n  // e.g,. 0 0 1 0 1 1 1\n  int switch_status[switch_len];\n  for(int i = 0; i < switch_len; i++) {\n    scanf(\"%d\", &switch_status[i]);\n  }\n\n  // scan population\n  int popluation_of_students;\n  scanf(\"%d\", &popluation_of_students);\n\n  // retrieve & immediately handle via for loop\n  for(int i = 0; i < popluation_of_students; i++) {\n    int sex, nr;\n    scanf(\"%d%d\", &sex, &nr);\n    // if a student is male\n    if(sex == 1) {\n      for(int i = 0; i < switch_len; i++) {\n        // if switch_nr % given_nr == 0\n        if(!((i+1) % nr)) {\n          switch_status[i] = !switch_status[i]; // using logical not\n        }\n      }\n    }\n    // if a student is female\n    else if(sex == 2) {\n      int center = nr - 1;\n      // toggles center outside of for loop, left index, right index, center are all same.\n      switch_status[center] = !switch_status[center];\n      for(int i = 1; i < switch_len; i++) {\n        // calculates  center.\n        // calculates left and right.\n        int left   =  center - i;\n        int right  = center + i;\n        if(\n           (left < 0)\n        || (right >= switch_len)\n        ) break;\n        // if leftward status == rightward status, toggle\n        if(switch_status[left] == switch_status[right]) {\n           switch_status[left]  = !switch_status[left] ; // using logical not\n           switch_status[right] = !switch_status[right]; // using logical not\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  // print each switches from 1 to last\n  // i == actual_switch_nr - 1\n  for(int i = 0; i < switch_len; i++) {\n    if(!(i%20) && (i != 0)) printf(\"%c\", '\\n');\n    printf((i%20) == 19? \"%d\":\"%d \",switch_status[i]);\n  }\n  return 0;\n}\n```\n\n## 결론\n\n코딩 테스트에서 마지막 줄의 추가 개행 정도는 보통 봐 주지만, 첫 줄의 추가 개행을 봐 주지 않는다.\n또한 조건이 복잡할 시 반복문 검사에서 다 해내려고 하지 말고 일부를 그 안에서 검사 후 빠져나오게 하자.\n특히 이것이 범위에 대한 검사라면 반복문 안에서 검사하는 것이 끝까지 범위를 명시적으로 훑을 수 있기 때문에 주의해야 한다.\n"
    },
    {
      "title": "[정렬] [최적화] C언어는 어디까지 최적화가 가능할까(백준 10825번)",
      "subtitle": "백준 10825번과 함께하는 C언어 최적화",
      "description": null,
      "url": "/codingtest/2026-01-22-[정렬]-[최적화]-C언어는-어디까지-최적화가-가능할까(백준-10825번)/",
      "collection": "codingtest",
      "relative_path": "2026-01-22-[정렬]-[최적화]-C언어는-어디까지-최적화가-가능할까(백준-10825번)",
      "date": "2026-01-22T16:00:00+09:00",
      "updated": null,
      "keywords": [
        "정렬",
        "백준",
        "최적화",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-sorting",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "--- [백준] 10825번: 국영수 이 문제를 최적화하면서 공부해 볼 것이다. 간단한 문제이지만 최적화에 따라 메모리 사용량과 실행 시간 등이 크게 달라진다. 진행할 최적화 유형은 아래와 같다. mmap을 통한 커널 직접 호출 기수정렬 구현을 통한 정렬 성능 최적화 정렬할 요소 크기에 따른 정렬 알고리즘 변경 AMD64에서 진행하는 SIMD 최적화 SIMD 부분은 ARM64 SIMD 관련 문서를 참고하면 같은 맥락이다. mmap을 통한 호출은 아직 다룬 적이 없었는데, BMP 관련 공부를 할 때…",
      "search_text": "[정렬] [최적화] c언어는 어디까지 최적화가 가능할까(백준 10825번) 백준 10825번과 함께하는 c언어 최적화 정렬 백준 최적화 알고리즘 codingtest codingtest algorithm-sorting --- [백준] 10825번: 국영수 이 문제를 최적화하면서 공부해 볼 것이다. 간단한 문제이지만 최적화에 따라 메모리 사용량과 실행 시간 등이 크게 달라진다. 진행할 최적화 유형은 아래와 같다. mmap을 통한 커널 직접 호출 기수정렬 구현을 통한 정렬 성능 최적화 정렬할 요소 크기에 따른 정렬 알고리즘 변경 amd64에서 진행하는 simd 최적화 simd 부분은 arm64 simd 관련 문서를 참고하면 같은 맥락이다. mmap을 통한 호출은 아직 다룬 적이 없었는데, bmp 관련 공부를 할 때… \n\n---\n\n# [백준] 10825번: 국영수\n\n이 문제를 최적화하면서 공부해 볼 것이다. 간단한 문제이지만 최적화에 따라 메모리 사용량과 실행 시간 등이 크게 달라진다.\n\n진행할 최적화 유형은 아래와 같다.\n\n* mmap을 통한 커널 직접 호출\n* 기수정렬 구현을 통한 정렬 성능 최적화\n  * 정렬할 요소 크기에 따른 정렬 알고리즘 변경\n* amd64에서 진행하는 simd 최적화\n\nsimd 부분은 arm64 simd 관련 문서를 참고하면 같은 맥락이다.\nmmap을 통한 호출은 아직 다룬 적이 없었는데, bmp 관련 공부를 할 때 해 보면 좋을 것이다.\n\n## 문제\n\n도현이네 반 학생 n명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로그램을 작성하시오.\n\n1. 국어 점수가 감소하는 순서로\n2. 국어 점수가 같으면 영어 점수가 증가하는 순서로\n3. 국어 점수와 영어 점수가 같으면 수학 점수가 감소하는 순서로\n4. 모든 점수가 같으면 이름이 사전 순으로 증가하는 순서로 (단, 아스키 코드에서 대문자는 소문자보다 작으므로 사전순으로 앞에 온다.)\n\n## 입력\n\n첫째 줄에 도현이네 반의 학생의 수 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 한 줄에 하나씩 각 학생의 이름, 국어, 영어, 수학 점수가 공백으로 구분해 주어진다. 점수는 1보다 크거나 같고, 100보다 작거나 같은 자연수이다. 이름은 알파벳 대소문자로 이루어진 문자열이고, 길이는 10자리를 넘지 않는다.\n\n## 출력\n\n문제에 나와있는 정렬 기준으로 정렬한 후 첫째 줄부터 n개의 줄에 걸쳐 각 학생의 이름을 출력한다.\n\n## 예제 입력 1\n\n```text\n12\njunkyu 50 60 100\nsangkeun 80 60 50\nsunyoung 80 70 100\nsoong 50 60 90\nhaebin 50 60 100\nkangsoo 60 80 100\ndonghyuk 80 60 100\nsei 70 70 70\nwonseob 70 70 90\nsanghyun 70 70 80\nnsj 80 80 80\ntaewhan 50 60 90\n\n```\n\n## 예제 출력 1\n\n```text\ndonghyuk\nsangkeun\nsunyoung\nnsj\nwonseob\nsanghyun\nsei\nkangsoo\nhaebin\njunkyu\nsoong\ntaewhan\n\n```\n\n## 출처\n\n* 문제를 만든 사람: baekjoon\n* 데이터를 추가한 사람: alssel2525\n* 빠진 조건을 찾은 사람: djm03178\n\n## 알고리즘 분류\n\n* 정렬\n\n## 정렬 알고리즘의 한계를 넘어서: 52ms에서 8ms까지\n\n동일한 정렬 문제에서 라이브러리 수준의 최적화를 넘어 시스템 아키텍처와 알고리즘의 특성을 극한으로 활용했을 때 발생하는 성능 차이를 분석한다.\n\n### 1. 기존 구현 (baseline: 52ms)\n\n초기 구현은 표준 라이브러리(`scanf`, `qsort`, `printf`)에 의존한다.\n\n* **i/o 병목:** `scanf`와 `printf`는 가변 인자 파싱과 버퍼링 오버헤드로 인해 대량의 데이터 처리 시 심각한 지연을 발생시킨다.\n* **비교 기반 정렬:** `qsort`는 $o(n \\log n)$의 시간 복잡도를 가지며, 매 비교마다 함수 포인터를 통한 오버헤드가 발생한다.\n* **데이터 구조:** 16바이트 정렬은 되어 있으나, 데이터 접근 패턴이 캐시 효율을 극대화하지 못한다.\n\n### 2. 최적화 구현 (advanced: 8ms)\n\n성능을 결정짓는 세 가지 핵심 요소(i/o, 메모리 아키텍처, 알고리즘)를 전면 개편하였다.\n\n#### a. zero-copy i/o 및 고속 파싱\n\n표준 입출력 스트림 대신 리눅스 커널의 `mmap` 시스템 콜을 사용한다. 파일 캐시를 유저 공간에 직접 매핑하여 메모리 복사 횟수를 제로(zero-copy)에 수렴하게 한다. 또한, `next_int` 매크로를 통해 정수 파싱 과정에서 발생하는 상태 머신 오버헤드를 제거하였다.\n\n#### b. 데이터 레이아웃 최적화 (key packing)\n\n국어(내림), 영어(오름), 수학(내림) 점수를 하나의 24비트 정수 `key`로 압축하였다.\n\n* 내림차순 정렬이 필요한 과목은 `255 - 점수`를 적용하여 모든 조건이 정수 오름차순 정렬로 귀결되도록 설계하였다.\n* 이를 통해 복잡한 분기 조건문 없이 단순 산술 비교만으로 정렬 우선순위를 판단할 수 있다.\n\n#### c. radix sort의 도입\n\n비교 기반 정렬의 하한선인 $o(n \\log n)$을 탈피하기 위해 **lsd(least significant digit) radix sort**를 구현하였다.\n\n* 24비트 키를 8비트씩 3번의 패스(pass)로 처리하여 $o(n)$의 시간 복잡도를 달성한다.\n* radix sort는 안정 정렬(stable sort)이므로, 과목 점수가 동일한 경우 발생하는 타이 브레이크(tie-break) 처리에 유리하다.\n\n#### d. 하이브리드 타이 브레이킹 (tie-breaking)\n\n점수 키가 완전히 일치하는 그룹에 대해서만 이름순 정렬을 수행한다.\n\n* 그룹의 크기가 작은 경우(32 이하)는 데이터 이동이 적은 **insertion sort**를 사용한다.\n* 그룹의 크기가 큰 경우에만 `qsort`를 호출하여 불필요한 함수 호출 비용을 최소화한다.\n\n### 3. 실습 코드\n\n#### 표준적 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#define student_max_name_len 11\n\n// declare a student type\ntypedef struct student {\n  char name[student_max_name_len];\n  // uint8_t to save memory space\n  uint8_t  korean ;\n  uint8_t  english;\n  uint8_t  math   ;\n} student_t;\n\nint compare(const void *a, const void *b) {\n  const student_t *student_a = (const student_t *)a;\n  const student_t *student_b = (const student_t *)b;\n  // if korean score is not same\n  if(student_a->korean != student_b->korean) {\n    return student_b->korean - student_a->korean;\n  }\n  // if english score is not same\n  if(student_a->english != student_b->english) {\n    return student_a->english - student_b->english;\n  }\n  // if math score is not same\n  if(student_a->math != student_b->math) {\n    return student_b->math - student_a->math;\n  }\n  // else sort by name\n  return strncmp(student_a->name, student_b->name, student_max_name_len);\n};\n\nint main(void) {\n  int students_len;\n  int student_t_len = sizeof(student_t);\n  // scan how many students are in a class\n  scanf(\"%d\", &students_len);\n\n  // declare students as an array\n\n  // calloc(nr, size) to ensure \\0 escape\n  student_t *students = calloc(students_len, student_t_len);\n\n  for(int i = 0; i < students_len; i++) {\n    // name, korean, english, math order\n    // uint8_t is okay, 0 <= score <= 100\n    scanf(\"%s %hhu %hhu %hhu\", students[i].name, &students[i].korean, &students[i].english, &students[i].math);\n  }\n  // sort by declared compare function\n  qsort(students, students_len, student_t_len, compare);\n\n  // print(name only)\n  for(int i = 0; i < students_len; i++) {\n    printf(\"%s\\n\", students[i].name);\n  }\n\n  free(students);\n\n  return 0;\n}\n```\n\n\n### 튜닝한 코드\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define student_max_name_len 16\n\ntypedef struct student {\n    char name[student_max_name_len]; // zero-padded\n    uint32_t key;                    // packed sort key (24-bit used)\n} __attribute__((aligned(16))) student_t;\n\nstatic inline uint32_t make_key(uint8_t kor, uint8_t eng, uint8_t math) {\n    // desired order:\n    // korean desc, english asc, math desc\n    // encode to ascending integer key:\n    // (255-kor) asc, eng asc, (255-math) asc\n    return ((uint32_t)(uint8_t)(255u - kor) << 16) |\n           ((uint32_t)eng << 8) |\n           (uint32_t)(uint8_t)(255u - math);\n}\n\nstatic int compare_name_only(const void *a, const void *b) __attribute__((hot));\nstatic int compare_name_only(const void *a, const void *b) {\n    const student_t *sa = (const student_t *)a;\n    const student_t *sb = (const student_t *)b;\n    return memcmp(sa->name, sb->name, student_max_name_len);\n}\n\nstatic inline void insertion_sort_name(student_t *a, int n) {\n    for (int i = 1; i < n; i++) {\n        student_t x = a[i];\n        int j = i - 1;\n        while (j >= 0 && memcmp(a[j].name, x.name, student_max_name_len) > 0) {\n            a[j + 1] = a[j];\n            j--;\n        }\n        a[j + 1] = x;\n    }\n}\n\n/*\n  24-bit lsd radix sort, stable, 3 passes of 8 bits.\n\n  pass0 (shift 0):  arr -> tmp\n  pass1 (shift 8):  tmp -> arr\n  pass2 (shift 16): arr -> tmp\n  final: tmp holds sorted result, copy back to arr\n*/\nstatic inline void radix_sort_by_key_24(student_t *arr, student_t *tmp, int n) {\n    size_t count[256];\n\n    // pass 0 (shift 0): arr -> tmp\n    memset(count, 0, sizeof(count));\n    for (int i = 0; i < n; i++) count[arr[i].key & 0xffu]++;\n    size_t sum = 0;\n    for (int i = 0; i < 256; i++) { size_t c = count[i]; count[i] = sum; sum += c; }\n    for (int i = 0; i < n; i++) {\n        unsigned b = arr[i].key & 0xffu;\n        tmp[count[b]++] = arr[i];\n    }\n\n    // pass 1 (shift 8): tmp -> arr\n    memset(count, 0, sizeof(count));\n    for (int i = 0; i < n; i++) count[(tmp[i].key >> 8) & 0xffu]++;\n    sum = 0;\n    for (int i = 0; i < 256; i++) { size_t c = count[i]; count[i] = sum; sum += c; }\n    for (int i = 0; i < n; i++) {\n        unsigned b = (tmp[i].key >> 8) & 0xffu;\n        arr[count[b]++] = tmp[i];\n    }\n\n    // pass 2 (shift 16): arr -> tmp\n    memset(count, 0, sizeof(count));\n    for (int i = 0; i < n; i++) count[(arr[i].key >> 16) & 0xffu]++;\n    sum = 0;\n    for (int i = 0; i < 256; i++) { size_t c = count[i]; count[i] = sum; sum += c; }\n    for (int i = 0; i < n; i++) {\n        unsigned b = (arr[i].key >> 16) & 0xffu;\n        tmp[count[b]++] = arr[i];\n    }\n\n    memcpy(arr, tmp, (size_t)n * sizeof(student_t));\n}\n\nint main(void) {\n    // mmap for zero-copy input\n    struct stat st;\n    fstat(0, &st);\n    char *p = (char *)mmap(null, (size_t)st.st_size, prot_read, map_private, 0, 0);\n    char *end = p + st.st_size;\n\n    // fast parsing integer from mmap pointer\n    #define next_int(n) do { \\\n        unsigned _x = 0; \\\n        while (p < end && ((unsigned char)*p < '0' || (unsigned char)*p > '9')) p++; \\\n        while (p < end && ((unsigned char)*p >= '0' && (unsigned char)*p <= '9')) _x = _x * 10u + (unsigned)(*p++ - '0'); \\\n        (n) = _x; \\\n    } while (0)\n\n    unsigned students_len_u;\n    next_int(students_len_u);\n    int students_len = (int)students_len_u;\n\n    student_t *students = (student_t *)aligned_alloc(16, (size_t)students_len * sizeof(student_t));\n    if (!students) students = (student_t *)malloc((size_t)students_len * sizeof(student_t));\n    student_t *tmp = (student_t *)aligned_alloc(16, (size_t)students_len * sizeof(student_t));\n    if (!tmp) tmp = (student_t *)malloc((size_t)students_len * sizeof(student_t));\n    if (!students || !tmp) return 0;\n\n    for (int i = 0; i < students_len; i++) {\n        // parse name, zero-pad to 16\n        while (p < end && (unsigned char)*p <= ' ') p++;\n\n        char *dst = students[i].name;\n        char *dst_end = dst + student_max_name_len;\n        while (p < end && (unsigned char)*p > ' ' && dst < dst_end) *dst++ = *p++;\n        // consume rest of token if longer than buffer (shouldn't happen in this problem)\n        while (p < end && (unsigned char)*p > ' ') p++;\n\n        // zero pad remaining\n        while (dst < dst_end) *dst++ = 0;\n\n        unsigned kor_u, eng_u, math_u;\n        next_int(kor_u);\n        next_int(eng_u);\n        next_int(math_u);\n\n        students[i].key = make_key((uint8_t)kor_u, (uint8_t)eng_u, (uint8_t)math_u);\n    }\n\n    // radix sort by key (24-bit)\n    radix_sort_by_key_24(students, tmp, students_len);\n\n    // tie-break: same key => name asc (switch insertion/qsort by run length)\n    enum { insertion_threshold = 32 };\n\n    for (int i = 0; i < students_len; ) {\n        int j = i + 1;\n        uint32_t k = students[i].key;\n        while (j < students_len && students[j].key == k) j++;\n\n        int run_len = j - i;\n        if (run_len > 1) {\n            if (run_len <= insertion_threshold) {\n                insertion_sort_name(students + i, run_len);\n            } else {\n                qsort(students + i, (size_t)run_len, sizeof(student_t), compare_name_only);\n            }\n        }\n        i = j;\n    }\n\n    // output buffer\n    char *out_buf = (char *)malloc((size_t)students_len * 12);\n    char *q = out_buf;\n\n    for (int i = 0; i < students_len; i++) {\n        const char *s = students[i].name;\n        while (*s) *q++ = *s++;\n        *q++ = '\\n';\n    }\n\n    write(1, out_buf, (size_t)(q - out_buf));\n\n    free(tmp);\n    free(students);\n    free(out_buf);\n    return 0;\n}\n```\n\n### 4. 성능 비교 및 결론\n\n| 지표 | 기존 구현 | 최적화 구현 | 개선율 |\n| --- | --- | --- | --- |\n| **시간 복잡도** |  |  | - |\n| **i/o 방식** | `scanf` / `printf` | `mmap` / `write` | - |\n| **실행 시간** | **52ms** | **8ms** | **약 85% 단축** |\n| **메모리 점유** | **3852kb** | **10476kb** | **약 172% 악화** |\n\n이러한 방식은 메모리 정렬이 엄격하게 필요하기 때문에 커널 호출로 일부 성능 이점을 가지고 오더라도 메모리를 너무 낭비하게 된다.\n특수한 상황에서는 확실히 적용해 볼 만한 최적화이다.\n\n\n비유를 해 보자면, 색종이를 더럽게 잘라도 적게 쓰는 것과, 색종이를 깔끔하게 잘라서 빨리 자르지만 종이를 낭비하는 것이다.\n대부분의 경우 c언어를 사용하는 환경은 메모리가 제한되어 있기 때문에 깔끔하게 짜고 컴파일러를 믿는 것이 좋다.\n하지만 고도의 성능을 요구하는 일부 엔터프라이즈 환경에서는 **상사가 쓰라고 하면 쓰는** 정도는 될 수 있다.\n그러나 나의 판단으로 simd는 이미 널리 쓰이니 그렇다 치더라도 커널 호출을 굳이 하는 것은 권장할 바가 아니라고 생각한다.\n\n## 맺으며\n\n**당연한 소리지만, 실제 코딩 테스트에서 이런 짓을 하지는 말자. 시간이 모자란다.**\n"
    },
    {
      "title": "[큐] 요세푸스 문제-백준 1158번",
      "subtitle": "요세푸스 문제는 어떻게 하면 빨리 풀 수 있을까?",
      "description": null,
      "url": "/codingtest/2026-01-21-[큐]-요세푸스-문제-백준-1158번/",
      "collection": "codingtest",
      "relative_path": "2026-01-21-[큐]-요세푸스-문제-백준-1158번",
      "date": "2026-01-21T15:47:00+09:00",
      "updated": null,
      "keywords": [
        "큐",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-data-structure",
        "order": 1
      },
      "difficulty": "easy",
      "excerpt": "--- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 MB 141734 72142 50509 49.598% 요세푸스 문제 문제 요세푸스 문제는 다음과 같다. 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스…",
      "search_text": "[큐] 요세푸스 문제-백준 1158번 요세푸스 문제는 어떻게 하면 빨리 풀 수 있을까? 큐 백준 알고리즘 codingtest codingtest algorithm-data-structure --- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 2 초 256 mb 141734 72142 50509 49.598% 요세푸스 문제 문제 요세푸스 문제는 다음과 같다. 1번부터 n번까지 n명의 사람이 원을 이루면서 앉아있고, 양의 정수 k(≤ n)가 주어진다. 이제 순서대로 k번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 n명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (n, k)-요세푸스… \n\n---\n\n<table>\n  <thead>\n    <tr>\n      <th>시간 제한</th>\n      <th>메모리 제한</th>\n      <th>제출</th>\n      <th>정답</th>\n      <th>맞힌 사람</th>\n      <th>정답 비율</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>2 초</td>\n      <td>256 mb</td>\n      <td>141734</td>\n      <td>72142</td>\n      <td>50509</td>\n      <td>49.598%</td>\n    </tr>\n  </tbody>\n</table>\n\n# 요세푸스 문제\n\n## 문제\n\n요세푸스 문제는 다음과 같다.\n\n1번부터 n번까지 n명의 사람이 원을 이루면서 앉아있고, 양의 정수 k(≤ n)가 주어진다. 이제 순서대로 k번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 n명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (n, k)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.\n\nn과 k가 주어지면 (n, k)-요세푸스 순열을 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 n과 k가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ k ≤ n ≤ 5,000)\n\n## 출력\n\n예제와 같이 요세푸스 순열을 출력한다.\n\n## 예제 입력 1\n\n```\n\n7 3\n\n```\n\n## 예제 출력 1\n\n```\n\n<3, 6, 2, 7, 5, 1, 4>\n\n```\n\n## 출처\n\n문제를 만든 사람: author5\n\n## 알고리즘 분류\n\n- 구현\n- 자료 구조\n- 큐\n\n\n## 해설\n\n요세푸스 문제는 보통 전형적인 환형 큐 문제이다. 그렇지만 코딩 테스트의 시간 제한이 10분 정도일 경우 환형 큐를 다 구현하고 나면 시간이 빠듯하다. 이러한 문제를 짧게 푸는 법을 나의 4년 전 c코드와 방금 10분 안에 작성한 파이썬 코드를 비교하여 해설한다.\n\n### c 코드(주석 없음, 가독성 나쁨)\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\ntypedef struct _node {int key; struct _node *next;} node;\nnode *head;\nvoid insert_key(int k)\n{\n    int i;\n    node *t;\n    t=(node *)malloc(sizeof(node));\n    t->key=1;\n    head=t;\n    for(i=2;i<=k;i++)\n    {\n        t->next=(node *)malloc(sizeof(node));\n        t=t->next;\n        t->key=i;\n    }\n    t->next=head;\n}\nvoid delete_after(node *t)\n{\n    node *v;\n    v=t->next;\n    t->next=t->next->next;\n    free(v);\n}\nnode* find_key(int k)\n{\n    node *t;\n    t=head;\n    while(t->key!=k)\n        t=t->next;\n    return t;\n}\nvoid josephus()\n{\n    int n,k,i;\n    scanf(\"%d %d\", &n, &k);\n    insert_key(n);\n    putc('<', stdout);\n    node *t;\n    t=find_key(n);\n    while(t!=t->next)\n    {\n        for(i=0;i<k-1;i++)\n            t=t->next;\n        printf(\"%d, \", t->next->key);\n        delete_after(t);\n    }\n    printf(\"%d>\", t->key);\n}\nint main()\n{\n    josephus();\n}\n```\n\n코드 스타일이 못 봐줄 꼴인 것은 둘째 치고, 이 환형 큐를 다 구현하면 거의 15-20분을 잡아먹을 가능성이 크다.\n이런 상황을 타개하기 위해선 배열 기반으로 처리해야 하는데, `idx_to_delete = (idx_to_delete + k - 1) % survived_people`이라는 공식을 사용해 인덱스의 사람을 배열에서 뽑고 다시 돌리고, 살아 남은 사람 수로 나머지를 구한다. 부동소수점 오류를 피하기 위해 만약 살아 남은 사람 수가 0이면 바로 for문을 빠져나가야 한다.\nc로는 이거나 저거나 구현 난이도가 비슷하고, 그나마 환형 큐가 쉬울 것이다.\n\n이럴 때는 파이썬을 사용하거나 c++를 사용하면 쉽다.\n코딩 테스트 환경이라 루비, 루아 등은 못 쓰고, 시간이 빠듯한 경우를 고려할 것이기 때문에 파이썬을 쓰도록 하겠다.\n\n\n### 파이썬 코드\n\n```python \ndef main():\n    n, k = map(int, input().split())\n\n    survived = n\n    idx_to_remove = 0\n    lst = []\n    print(\"<\", end=\"\")\n    for i in range(n):\n        lst.append(i+1)\n    for i in range(n):\n        if survived == 0:\n            break\n        idx_to_remove = (idx_to_remove + k - 1) % survived\n        survived-=1\n        v = lst[idx_to_remove]\n        if i < n - 1:\n            print(v, end=\", \")\n        else:\n            print(v, end=\">\")\n        lst.remove(v)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n* 출력은 print의 end 인자로 정리\n* 죽은 사람은 리스트에서 제거\n* 살아남은 사람 수를 1씩 빼거나 survived 대신 len 사용\n* survived가 0으로 떨어지면(혹은 리스트가 비어있으면) 반복문 종료\n\n훨씬 짧은 코드이고 생각하는 시간을 포함해도 10분이면 충분하다.\n\n## 결론\n\n* 파이썬을 잘 익혀두자\n* c로 개인 프로젝트 개발을 해도 파이썬 복습은 중요하다\n* 그래도 생각이 안 나면 c++을 쓰자\n"
    },
    {
      "title": "[스택] 제로-백준 10773번",
      "subtitle": "간단한 스택 문제를 연습하자",
      "description": null,
      "url": "/codingtest/2026-01-21-[스택]-제로-백준-10773번/",
      "collection": "codingtest",
      "relative_path": "2026-01-21-[스택]-제로-백준-10773번",
      "date": "2026-01-21T15:00:00+09:00",
      "updated": null,
      "keywords": [
        "스택",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-data-structure",
        "order": 1
      },
      "difficulty": "easy",
      "excerpt": "문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자! 입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000) 이후 K개의 줄에 정수가 1…",
      "search_text": "[스택] 제로-백준 10773번 간단한 스택 문제를 연습하자 스택 백준 알고리즘 codingtest codingtest algorithm-data-structure 문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다. 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다. 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다. 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자! 입력 첫 번째 줄에 정수 k가 주어진다. (1 ≤ k ≤ 100,000) 이후 k개의 줄에 정수가 1… \n\n```html\n<table>\n  <thead>\n    <tr>\n      <th>시간 제한</th>\n      <th>메모리 제한</th>\n      <th>제출</th>\n      <th>정답</th>\n      <th>맞힌 사람</th>\n      <th>정답 비율</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1 초</td>\n      <td>256 mb</td>\n      <td>130025</td>\n      <td>89455</td>\n      <td>71884</td>\n      <td>68.769%</td>\n    </tr>\n  </tbody>\n</table>\n```\n\n## 문제\n\n나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n\n## 입력\n\n첫 번째 줄에 정수 k가 주어진다. (1 ≤ k ≤ 100,000)\n\n이후 k개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \"0\" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.\n\n정수가 \"0\"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n\n## 출력\n\n재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2^31-1보다 작거나 같은 정수이다.\n\n## 예제 입력 1\n\n```\n\n4\n3\n0\n4\n0\n\n```\n\n## 예제 출력 1\n\n```\n\n0\n\n```\n\n## 예제 입력 2\n\n```\n\n10\n1\n3\n5\n4\n0\n0\n7\n0\n0\n6\n\n```\n\n## 예제 출력 2\n\n```\n\n7\n\n```\n\n## 힌트\n\n예제 2의 경우를 시뮬레이션 해보면,\n\n```\n\n[1]\n[1,3]\n[1,3,5]\n[1,3,5,4]\n[1,3,5] (0을 불렀기 때문에 최근의 수를 지운다)\n[1,3] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)\n[1,3,7]\n[1,3] (0을 불렀기 때문에 최근의 수를 지운다)\n[1] (0을 불렀기 때문에 그 다음 최근의 수를 지운다)\n[1,6]\n\n```\n\n합은 7이다.\n\n## 출처\n\nolympiad > canadian computing competition & olympiad > 2015 > ccc 2015 senior division 1번\n\n문제를 번역한 사람: koosaga\n문제의 오타를 찾은 사람: busyhuman\n\n## 알고리즘 분류\n\n- 구현\n- 자료 구조\n- 스택\n\n---\n\n## 풀이\n단순히 0일 때 팝, 아닐 때 푸시한다.\nc로 구현하면 5-10분이면 끝난다.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* stack= null;\nint  top  = 0    ;\nint  size = 0    ;\n\nvoid alloc_stack() {\n    if(stack == null) {\n        stack = malloc(sizeof(int) * 100);\n        size = 100;\n    } else {\n        size *= 2;\n        stack = realloc(stack, sizeof(int) * size);\n    }\n}\n\nvoid push(int x) {\n    if(size == top) alloc_stack();\n    stack[top] = x;\n    top++;\n}\n\nvoid pop() {\n    top--;\n}\n\nint main() {\n    int k;\n    alloc_stack();\n    scanf(\"%d\", &k);\n\n    for(int i = 0; i < k; i++) {\n        int task;\n        scanf(\"%d\", &task);\n        if(task) push(task);\n        else pop();\n    }\n\n    long sum = 0;\n\n    for(int i = 0; i < top; i++) {\n        sum += stack[i];\n    }\n    printf(\"%ld\", sum);\n    free(stack);\n    return 0;\n}\n```\n\n## 첨언\n\n왜 갑자기 낮은 레벨 양치기를 하고 있냐면은, 160군데가 넘는 회사들을 돌렸더니 한 군데에서 코딩 테스트를 보자고 했다. 이 기업의 코딩 테스트는 낮음-중급 난이도를 극도로 빡빡한 시간 제한에서 풀게 한다. 한 문제 당 10분 정도 봐야 한다. 미친 듯이 풀어 봐야 한다.\n"
    },
    {
      "title": "[그리디] 사과 담기 게임-백준 2828번",
      "subtitle": "보이는대로 구현하면 되는 트릭 없는 그리디",
      "description": null,
      "url": "/codingtest/2026-01-21-[그리디]-사과-담기-게임-백준-2828번/",
      "collection": "codingtest",
      "relative_path": "2026-01-21-[그리디]-사과-담기-게임-백준-2828번",
      "date": "2026-01-21T15:00:00+09:00",
      "updated": null,
      "keywords": [
        "정렬",
        "그리디",
        "우선순위 큐",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-greedy",
        "order": 1
      },
      "difficulty": "easy",
      "excerpt": "--- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 MB 17427 9061 7022 52.821% 문제 상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 N칸으로 나누어져 있다. 스크린의 아래쪽에는 M칸을 차지하는 바구니가 있다. 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 M칸을 차지하고 있다. 스크린의 위에서 사과 여러 개가 떨어진다. 각 사…",
      "search_text": "[그리디] 사과 담기 게임-백준 2828번 보이는대로 구현하면 되는 트릭 없는 그리디 정렬 그리디 우선순위 큐 백준 알고리즘 codingtest codingtest algorithm-greedy --- 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 128 mb 17427 9061 7022 52.821% 문제 상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 n칸으로 나누어져 있다. 스크린의 아래쪽에는 m칸을 차지하는 바구니가 있다. 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 m칸을 차지하고 있다. 스크린의 위에서 사과 여러 개가 떨어진다. 각 사… \n\n\n---\n\n<table>\n  <thead>\n    <tr>\n      <th>시간 제한</th>\n      <th>메모리 제한</th>\n      <th>제출</th>\n      <th>정답</th>\n      <th>맞힌 사람</th>\n      <th>정답 비율</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1 초</td>\n      <td>128 mb</td>\n      <td>17427</td>\n      <td>9061</td>\n      <td>7022</td>\n      <td>52.821%</td>\n    </tr>\n  </tbody>\n</table>\n\n## 문제\n상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 n칸으로 나누어져 있다. 스크린의 아래쪽에는 m칸을 차지하는 바구니가 있다. `(m<n)` 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 m칸을 차지하고 있다.\n\n스크린의 위에서 사과 여러 개가 떨어진다. 각 사과는 n칸중 한 칸의 상단에서 떨어지기 시작하며, 스크린의 바닥에 닿을때까지 직선으로 떨어진다. 한 사과가 바닥에 닿는 즉시, 다른 사과가 떨어지기 시작한다.\n\n바구니가 사과가 떨어지는 칸을 차지하고 있다면, 바구니는 그 사과가 바닥에 닿을 때, 사과를 담을 수 있다. 상근이는 사과를 모두 담으려고 한다. 이때, 바구니의 이동 거리의 최솟값을 구하는 프로그램을 작성하시오.\n\n## 입력\n\n첫째 줄에 n과 m이 주어진다. `(1 ≤ m < n ≤ 10)`  \n둘째 줄에 떨어지는 사과의 개수 j가 주어진다. `(1 ≤ j ≤ 20)`\n다음 j개 줄에는 사과가 떨어지는 위치가 순서대로 주어진다.\n\n## 출력\n\n모든 사과를 담기 위해서 바구니가 이동해야 하는 거리의 최솟값을 출력한다.\n\n## 예제 입력 1\n\n```\n\n5 1\n3\n1\n5\n3\n\n```\n\n## 예제 출력 1\n\n```\n\n6\n\n```\n\n## 예제 입력 2\n\n```\n\n5 2\n3\n1\n5\n3\n\n```\n\n## 예제 출력 2\n\n```\n\n4\n\n```\n\n## 문제를 풀 때 중요한 점\n\n### 핵심 구조: 슬라이딩 윈도우\n\n### 바구니의 이동\n* 바구니의 양쪽 끝을 잡고 위치를 움직인다.\n\n\n### 사과 위치에 따른 대응\n\n* **오른쪽으로 벗어남 (`사과 > 오른쪽 끝`)**:\n* (사과 위치 - 오른쪽 끝)만큼 바구니를 오른쪽으로 민다.\n* 밀어낸 거리만큼 이동 거리에 더한다.\n\n---\n\n* **왼쪽으로 벗어남 (`사과 < 왼쪽 끝`)**:\n* (왼쪽 끝 - 사과 위치)만큼 바구니를 왼쪽으로 민다.\n* 밀어낸 거리만큼 이동 거리에 더한다.\n\n---\n\n* **범위 안 (`왼쪽 끝 <= 사과 <= 오른쪽 끝`)**:\n* 아무것도 하지 않는다.\n\n\n* 사람이 사고하는 방식 그대로 따라가라. 컴퓨터공학적 기교가 필요없다.\n* 바구니의 끝점을 사과에 맞춰서 **아슬하게 사과를 받는 것이 최적이다.**\n\n## 풀이\n\n```cpp\n#include <iostream>\n\nint main() {\n  int screen_width, basket_width;\n  std::cin >> screen_width >> basket_width;\n\n  int basket_startpoint = 1;\n  int answer = 0;\n\n  int apples_len;\n  std::cin >> apples_len;\n\n  for (int i = 0; i < apples_len; i++) {\n    int dest;\n    std::cin >> dest;\n\n    // current basket range\n    int basket_endpoint = basket_startpoint + basket_width - 1;\n\n    if (dest > basket_endpoint) {\n      // move right\n      int move = dest - basket_endpoint;\n      answer += move;\n      basket_startpoint += move;\n    }\n    else if (dest < basket_startpoint) {\n      // move left\n      int move = basket_startpoint - dest;\n      answer += move;\n      basket_startpoint -= move;\n    }\n    // in range -> skip\n  }\n\n  std::cout << answer;\n  return 0;\n}\n```\n\n## 결론\n\n이런 문제는 발상까지가 오래 걸리지 구현은 얼마 걸리지 않는다.\n그리디 특유의 단순하고 기교 없는 발상을 몸에 익히는 것은 마치 어린아이의 그림을 다시 배우는 것과 비슷하다.\n\n피카소가 어린아이처럼 다시 그리는데 수십 년이 걸렸다고 하지만, 이건 코드다. 어린아이의 코드처럼 짜는 것은 몇 주 단기 완성도 가능할 것이다.\n반복해서 사고방식을 따라가자.\n"
    },
    {
      "title": "[문자열] 신규 아이디 추천-프로그래머스-레벨1",
      "subtitle": "C++로 제한된 환경에서 C 빌려오기",
      "description": null,
      "url": "/codingtest/2026-01-20-[문자열]-신규-아이디-추천-프로그래머스-레벨1/",
      "collection": "codingtest",
      "relative_path": "2026-01-20-[문자열]-신규-아이디-추천-프로그래머스-레벨1",
      "date": "2026-01-20T21:52:00+09:00",
      "updated": null,
      "keywords": [
        "프로그래머스",
        "알고리즘",
        "문자열",
        "파싱"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-string",
        "order": 2
      },
      "difficulty": "beginner",
      "excerpt": "--- 문제 카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 규칙에 맞지 않는 아이디를 입력했을 때, 규칙에 맞는 새로운 아이디를 추천해주는 프로그램을 개발하는 것입니다. 카카오 아이디 규칙 아이디의 길이는 3자 이상 15자 이하 여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄( ), 마침표(.) 문자만 사용할 수 있습니다. 단, 마침표(.) 는 처음과 끝에 사용할 수 없으며…",
      "search_text": "[문자열] 신규 아이디 추천-프로그래머스-레벨1 c++로 제한된 환경에서 c 빌려오기 프로그래머스 알고리즘 문자열 파싱 codingtest codingtest algorithm-string --- 문제 카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 규칙에 맞지 않는 아이디를 입력했을 때, 규칙에 맞는 새로운 아이디를 추천해주는 프로그램을 개발하는 것입니다. 카카오 아이디 규칙 아이디의 길이는 3자 이상 15자 이하 여야 합니다. 아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄( ), 마침표(.) 문자만 사용할 수 있습니다. 단, 마침표(.) 는 처음과 끝에 사용할 수 없으며… \n\n---\n\n### 문제\n\n카카오에 입사한 신입 개발자 네오는 \"카카오계정개발팀\"에 배치되어, 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. \"네오\"에게 주어진 첫 업무는 규칙에 맞지 않는 아이디를 입력했을 때, 규칙에 맞는 새로운 아이디를 추천해주는 프로그램을 개발하는 것입니다.\n\n### 카카오 아이디 규칙\n\n* 아이디의 길이는 **3자 이상 15자 이하**여야 합니다.\n* 아이디는 **알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)** 문자만 사용할 수 있습니다.\n* 단, **마침표(.)**는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.\n\n### 아이디 추천 7단계 처리 과정\n\n1. **1단계**: `new_id`의 모든 대문자를 대응되는 소문자로 치환합니다.\n2. **2단계**: `new_id`에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\n3. **3단계**: `new_id`에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\n4. **4단계**: `new_id`에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\n5. **5단계**: `new_id`가 빈 문자열이라면, `new_id`에 \"a\"를 대입합니다.\n6. **6단계**: `new_id`의 길이가 16자 이상이면, 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다. 만약 제거 후 마침표(.)가 끝에 위치한다면 이를 제거합니다.\n7. **7단계**: `new_id`의 길이가 2자 이하라면, 마지막 문자를 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\n\n### 제한사항\n\n* `new_id`는 길이 1 이상 1,000 이하인 문자열입니다.\n* `new_id`는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.\n* `new_id`에 나타날 수 있는 특수문자는 `-_.~!@#$%^&*()=+[{]}:?,<>/` 로 한정됩니다.\n\n### 입출력 예\n\n<table>\n<thead>\n<tr>\n<th>no</th>\n<th>new_id</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>예1</td>\n<td>\"...!@bat#*..y.abcdefghijklm\"</td>\n<td>\"bat.y.abcdefghi\"</td>\n</tr>\n<tr>\n<td>예2</td>\n<td>\"z-+.^.\"</td>\n<td>\"z--\"</td>\n</tr>\n<tr>\n<td>예3</td>\n<td>\"=.=\"</td>\n<td>\"aaa\"</td>\n</tr>\n<tr>\n<td>예4</td>\n<td>\"123_.def\"</td>\n<td>\"123_.def\"</td>\n</tr>\n<tr>\n<td>예5</td>\n<td>\"abcdefghijklmn.p\"</td>\n<td>\"abcdefghijklmn\"</td>\n</tr>\n</tbody>\n</table>\n\n### 입출력 예에 대한 설명\n\n**입출력 예 #2**\n\n* 2단계: `\"z-+.^.\"` → `\"z-..\"`\n* 3단계: `\"z-..\"` → `\"z-.\"`\n* 4단계: `\"z-.\"` → `\"z-\"`\n* 7단계: `\"z-\"` → `\"z--\"`\n\n**입출력 예 #3**\n\n* 2단계: `\"=.=\"` → `\".\"`\n* 4단계: `\".\"` → `\"\"` (빈 문자열)\n* 5단계: `\"\"` → `\"a\"`\n* 7단계: `\"a\"` → `\"aaa\"`\n\n**입출력 예 #5**\n\n* 6단계: `\"abcdefghijklmn.p\"` → `\"abcdefghijklmn.\"` → `\"abcdefghijklmn\"`\n\n## 문제 풀이\n\n아...그냥 단계대로 빡구현이다. 이거는 뭔가 설명할 것은 없다.\n그래서 이번엔 c++에서 c를 훔쳐오는 것이 **잘만 사용하면** 문익점이 목화 씨를 빼돌리듯 알짜 기능들을 빼 올 수 있는 것을 소개하고자 한다.\n\n이번 문제 풀이에는 3가지 코드가 등장한다.\n\n- gemini 3.0 flash의 비교용 모범 c++ 코드\n- 내가 코딩 테스트 제출에 사용한 최적화가 부족한 코드\n- 성능을 깎고 깎아서 만들어낸 코드\n\n우선 모범 답안부터 보자.\n\n```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring solution(string new_id) {\n    // 1단계: 소문자 치환\n    for (char &c : new_id) c = tolower(c);\n\n    // 2단계: 허용되지 않는 문자 제거\n    string step2 = \"\";\n    for (char c : new_id) {\n        if (isalnum(c) || c == '-' || c == '_' || c == '.') {\n            step2 += c;\n        }\n    }\n\n    // 3단계: 마침표 연속 부분 압축\n    string step3 = \"\";\n    for (char c : step2) {\n        if (c == '.' && !step3.empty() && step3.back() == '.') continue;\n        step3 += c;\n    }\n\n    // 4단계: 처음이나 끝의 마침표 제거\n    if (!step3.empty() && step3.front() == '.') step3.erase(0, 1);\n    if (!step3.empty() && step3.back() == '.') step3.pop_back();\n\n    // 5단계: 빈 문자열 처리\n    if (step3.empty()) step3 = \"a\";\n\n    // 6단계: 길이 제한 및 끝 마침표 제거\n    if (step3.length() >= 16) {\n        step3 = step3.substr(0, 15);\n        if (step3.back() == '.') step3.pop_back();\n    }\n\n    // 7단계: 길이 보충\n    while (step3.length() < 3) {\n        step3 += step3.back();\n    }\n\n    return step3;\n}\n```\n아주 깔끔하다. 문제는 전형적인 **복잡한 테스트 케이스로 겁주기** 유형에 해당한다.\n\n나의 *통과되었지만 아직은 느린 코드*를 보도록 하겠다.\n\n```cpp\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <ctype.h>\n\nusing namespace std;\n\nvoid push_char(char **str, int *top, char c) {\n    char *s = *str;\n    (*top)++; \n    s[*top] = c;\n}\n\nvoid pop(char **str, int *top) {\n    if (*top < 0) return;\n    (*str)[*top] = '\\0';\n    (*top)--;\n}\n\nstring solution(string newid) {\n    \n    char *new_id   = (char *)newid.c_str()                           ;\n    char *answer   = (char *)calloc(newid.length() + 1, sizeof(char));\n    int top_answer = -1;\n    \n    for(int i = 0; i < strlen(new_id); i++) {\n        char c = tolower(new_id[i]);\n        if(\n            isdigit(c)\n            | (int)(c == '-')\n            | (int)(c == '_')\n            | (int)(c == '.') \n        ) {\n        if (\n            (c == '.')\n          & ((i == 0) | (i == (int)strlen(new_id) - 1))\n        ) continue;\n            push_char(&answer, &top_answer, c);\n        } else if(\n            ('a' <= c)\n         && ('z' >= c)\n        ) {\n             push_char(&answer, &top_answer, c);\n         }\n    }\n    \n    char * final_answer = (char *) calloc(newid.length() + 1, sizeof(char));\n    int    final_top    = -1;\n    \n    char *ans    = (char *) answer;\n    char *saveptr;\n    char *token  = strtok_r(ans, \".\", &saveptr);\n    \n    while(true) {\n        if(token == null) break;\n        for(char *c = token; *c != '\\0'; c++) push_char(&final_answer, &final_top, *c);\n        push_char(&final_answer, &final_top, '.');\n        token = strtok_r(null, \".\", &saveptr);\n    }\n    \n    if (final_top != -1) pop(&final_answer, &final_top);\n    \n    if (strlen(final_answer) > 15) {\n        int over = strlen(final_answer) - 15;\n        for(int i = 0; i < over; i++) {\n            pop(&final_answer, &final_top);\n        }\n    }    \n    if(strlen(final_answer) == 0) return \"aaa\";\n        \n    if(strlen(final_answer) < 3) {\n        char last = final_answer[final_top];\n        int count = 3 - strlen(final_answer);\n        for(int i = 0; i < count; i++) push_char(&final_answer, &final_top, last);\n    }\n    \n    if (final_answer[final_top] == '.') pop(&final_answer, &final_top);\n    string cpp_answer(final_answer);\n    \n    free(answer);\n    free(final_answer);\n    \n    return cpp_answer;\n}\n```\n\n여기서는 급하게 짠다고 비트 연산 등의 최적화가 있지만 `strlen`을 너무 과하게 호출한다.\n벤치 결과는 좋지 못하다.\n\nmetric               | c-style    | c++ style\n---------------------------------------------\naverage latency (ms) | 0.0208   | 0.0165\nmax latency (ms)     | 0.0600   | 0.0400\nefficiency gap       |   -20.37% slower\n\n\n<img src=\"/assets/images/solved_c_code_with_a_blunder.png\" style=\"max-width:70%; height: auto;\"/>\n\n이제 본격적인 최적화를 해 보자. 이 경우 `strlen`을 지역 변수에 적당히 쌓아 두고 쓸 것이다.\n\n```cpp\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <ctype.h>\n\nusing namespace std;\n\nvoid push_char(char **str, int *top, char c) {\n    char *s = *str;\n    (*top)++;\n    s[*top] = c;\n}\n\nvoid pop(char **str, int *top) {\n    if (*top < 0) return;\n    (*str)[*top] = '\\0';\n    (*top)--;\n}\n\nstring solution(string newid) {\n    int original_len = (int)   newid.length();\n    char *new_id     = (char *)newid.c_str() ;\n\n    int top_answer = -1;\n    char *answer     = (char *)calloc(original_len + 1, sizeof(char));\n\n    for(int i = 0; i < original_len; i++) {\n        char c = tolower(new_id[i]);\n        if(isdigit(c)\n           | (c == '-')\n           | (c == '_')\n           | (c == '.')) {\n\n            if ((c == '.') & \n             & ((i == 0)\n             | (i == original_len - 1))) continue;\n\n            push_char(&answer, &top_answer, c);\n        } else if(('a' <= c) && ('z' >= c)) {\n            push_char(&answer, &top_answer, c);\n        }\n    }\n\n    char * final_answer = (char *) calloc(original_len + 2, sizeof(char));\n    int    final_top    = -1;\n    char *saveptr;\n    char *token  = strtok_r(answer, \".\", &saveptr);\n\n    while(token != null) {\n        for(char *c = token; *c != '\\0'; c++)\n            push_char(&final_answer, &final_top, *c);\n        push_char(&final_answer, &final_top, '.');\n        token = strtok_r(null, \".\", &saveptr);\n    }\n\n    if (final_top != -1)\n        pop(&final_answer, &final_top);\n\n    int current_len = final_top + 1;\n\n    if (current_len > 15) {\n        int over = current_len - 15;\n        for(int i = 0; i < over; i++)\n            pop(&final_answer, &final_top);\n        current_len = 15;\n    }\n\n    if(current_len == 0) {\n        free(answer);\n        free(final_answer);\n        return \"aaa\";\n    }\n\n    if(current_len < 3) {\n        char last = final_answer[final_top];\n        int count = 3 - current_len;\n        for(int i = 0; i < count; i++)\n            push_char(&final_answer, &final_top, last);\n        current_len = 3;\n    }\n\n    if (final_answer[final_top] == '.')\n        pop(&final_answer, &final_top);\n\n    string cpp_answer(final_answer);\n    free(answer);\n    free(final_answer);\n\n    return cpp_answer;\n}\n```\n\n지역 변수에 길이 정보를 저장하니 가독성도 나아졌다. 또한, `if` 조건이 복잡할 때는 소괄호에서도 적재적소에 개행이나 공백을 넣어 프로그래밍적인 변경 없이 가독성을 챙길 수도 있다.\n\n물론 순수한 c++ 코드에 비해 좋지 않으나 성능 향상을 위해서 용납 가능한 수준이다.\n\nperformance metric        | c-style (opt)   | c++ (stl)\n-----------------------------------------------------------------\ntotal execution time (ms) | 0.39            | 0.43\naverage latency (ms)      | 0.0150          | 0.0165\nmax peak latency (ms)     | 0.03            | 0.04\nperformance lead          |          10.26% faster than stl\n\n\n<img src=\"/assets/images/solved_c_code_without_a_blunder.png\" style=\"max-width:70%; height: auto;\"/>\n\n그렇게 최적화가 잘 된 c++의 stl보다도 **10.26%** 빠르다.\n\n이러한 c기반 코드의 실무적 장점은 코딩 테스트보다 프로젝트 작업 시 더욱 빛을 발한다.\n\n### 압도적인 예측 가능성\n\nc는 화려하고 똑똑한 문법을 도입하지 않는 대신 **예측할 수 있는** 성능을 보여준다. 이러한 언어를 사용한다면 프로그램은 극도로 정제되어 늘 비슷한 실행 시간, 비슷한 cpu 점유율, 심지어는 파이프라이닝 타이밍까지도 편차가 적을 것이다.\n물론 c++ 역시 상당 부분 c를 대체할 수 있는 수준까지 왔으나, 도리어 그 로직의 복잡성이 증가할수록 잘 정리된 c++ 프로젝트와 잘 정리된 c 프로젝트 사이에서, 오히려 유지보수성의 일정 측면은 c가 우수한 경우도 있을 만큼 괜히 살아남은 언어가 아니다.\n\n아까 `strlen`으로 인한 성능 악화 역시 c이기 때문에 반복적인 변수 참조로 길이를 잰 것이 문제라고 드러난 것이지, 만약 웬만한 알고리즘들이 다 붙박이로 들어가 있는 c++이나 python 3, java같은 언어였다면 내장된 스트림이나 문자열 처리 함수에서 어떤 것이 문제인지 굳이 문서를 뒤져 봐야 한다.\n\n이러한 즉각적인 문제 인식과 수용이 가능하기에 아직도 c는 신생 프로젝트들이 태어나는 몇 안되는 원로급 언어로 자리잡은 것이다.\n\n### 약간의 성능 향상이 중요할 때\n\n금융 거래, 현물 투자 등의 상황에서는 밀리세컨드 단위의 성능 저하가 누적되어 사용자들이 불만을 느낄 수 있는 수준으로 늘어날 수도 있는데다, 1초의 지연으로 중요한 거래 도중 환율이 바뀌어 버린다던가 하는 사고가 날 수 있다.\n이러한 환경에서는 c++ 사이에 c를, 심한 경우 어셈블리를 박아넣기도 한다. 이러할 때 c를 보더라도 겁먹지 않으려면 이런 쉬운 문제들로 연습해 볼 필요가 있다.\n\n## 결론\n\n실전 코딩 테스트에서 c++에 익숙하다면 나의 방식은 권장할 것이 아니며, 이것보다 복잡한 자료 구조를 다룰 때는 더더욱 권장하지 않는다. 그러나 c++로 짰을 때 확실히 코드가 너무 추상적인 상황이 있다면 그 때 이러한 연습은 빛을 발할 것이다.\n\n만약 이 글을 읽는 당신이 대학교 1학년이라면 그 시점부터 이러한 연습을 충실하게 하여 향후 걸림이 없어야 한다. 기초를 다지는 것은 언제든 중요한 일이다.\n\n"
    },
    {
      "title": "[다익스트라] Network Delay Time-LeetCode",
      "subtitle": "다익스트라 알고리즘을 이용하는 그래프 탐색의 기초",
      "description": null,
      "url": "/codingtest/2026-01-20-[다익스트라]-Network-Delay-Time-LeetCode/",
      "collection": "codingtest",
      "relative_path": "2026-01-20-[다익스트라]-Network-Delay-Time-LeetCode",
      "date": "2026-01-20T12:53:00+09:00",
      "updated": null,
      "keywords": [
        "문자열",
        "다익스트라",
        "그래프"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dijkstra",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "문제 743. Network Delay Time Medium You are given a network of nodes, labeled from to . You are also given , a list of travel times as directed edges , where is the source node, is the target node, and is the time it takes for a signal to travel from source to target. We will send…",
      "search_text": "[다익스트라] network delay time-leetcode 다익스트라 알고리즘을 이용하는 그래프 탐색의 기초 문자열 다익스트라 그래프 codingtest codingtest algorithm-dijkstra 문제 743. network delay time medium you are given a network of nodes, labeled from to . you are also given , a list of travel times as directed edges , where is the source node, is the target node, and is the time it takes for a signal to travel from source to target. we will send… \n\n# 문제\n## 743. network delay time\n\n**medium**\n\nyou are given a network of `n` nodes, labeled from `1` to `n`. you are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nwe will send a signal from a given node `k`. return the minimum time it takes for all the `n` nodes to receive the signal. if it is impossible for all the `n` nodes to receive the signal, return `-1`.\n\n---\n\n### example 1:\n\n<div style=\"text-align: center; margin: 20px 0;\">\n<svg width=\"300\" height=\"150\" viewbox=\"0 0 300 150\" xmlns=\"[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)\">\n<circle cx=\"150\" cy=\"30\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" />\n<text x=\"150\" y=\"35\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\">2</text>\n\n<circle cx=\"50\" cy=\"120\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" />\n<text x=\"50\" y=\"125\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\">1</text>\n\n<circle cx=\"250\" cy=\"120\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" />\n<text x=\"250\" y=\"125\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\">3</text>\n\n<circle cx=\"250\" cy=\"40\" r=\"10\" fill=\"none\" opacity=\"0\" /> <circle cx=\"350\" cy=\"120\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" transform=\"translate(-100, 0)\" />\n<text x=\"250\" y=\"125\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\" transform=\"translate(0, 0)\">3</text>\n\n<circle cx=\"250\" cy=\"120\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" />\n<text x=\"250\" y=\"125\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\">3</text>\n\n<circle cx=\"350\" cy=\"120\" r=\"20\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\" />\n<text x=\"350\" y=\"125\" text-anchor=\"middle\" font-family=\"arial\" font-weight=\"bold\">4</text>\n\n<rect width=\"400\" height=\"150\" fill=\"white\"/>\n<circle cx=\"100\" cy=\"40\" r=\"18\" fill=\"white\" stroke=\"black\" stroke-width=\"2\"/>\n<text x=\"100\" y=\"45\" text-anchor=\"middle\" font-size=\"14\">2</text>\n<circle cx=\"40\" cy=\"110\" r=\"18\" fill=\"white\" stroke=\"black\" stroke-width=\"2\"/>\n<text x=\"40\" y=\"115\" text-anchor=\"middle\" font-size=\"14\">1</text>\n<circle cx=\"160\" cy=\"110\" r=\"18\" fill=\"white\" stroke=\"black\" stroke-width=\"2\"/>\n<text x=\"160\" y=\"115\" text-anchor=\"middle\" font-size=\"14\">3</text>\n<circle cx=\"250\" cy=\"110\" r=\"18\" fill=\"white\" stroke=\"black\" stroke-width=\"2\"/>\n<text x=\"250\" y=\"115\" text-anchor=\"middle\" font-size=\"14\">4</text>\n\n<path d=\"m 85,53 l 55,95\" stroke=\"black\" stroke-width=\"1.5\" marker-end=\"url(#arrow)\"/>\n<text x=\"60\" y=\"70\" font-size=\"12\" fill=\"red\">1</text>\n<path d=\"m 115,53 l 145,95\" stroke=\"black\" stroke-width=\"1.5\" marker-end=\"url(#arrow)\"/>\n<text x=\"140\" y=\"70\" font-size=\"12\" fill=\"red\">1</text>\n<path d=\"m 178,110 l 232,110\" stroke=\"black\" stroke-width=\"1.5\" marker-end=\"url(#arrow)\"/>\n<text x=\"205\" y=\"105\" font-size=\"12\" fill=\"red\">1</text>\n\n<defs>\n<marker id=\"arrow\" markerwidth=\"10\" markerheight=\"10\" refx=\"9\" refy=\"3\" orient=\"auto\" markerunits=\"strokewidth\">\n<path d=\"m0,0 l0,6 l9,3 z\" fill=\"black\" />\n</marker>\n</defs>\n</svg>\n</div>\n\n**input:** `times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2`\n\n**output:** `2`\n\n---\n\n### example 2:\n\n**input:** `times = [[1,2,1]], n = 2, k = 1`\n\n**output:** `1`\n\n---\n\n### example 3:\n\n**input:** `times = [[1,2,1]], n = 2, k = 2`\n\n**output:** `-1`\n\n---\n\n### constraints:\n\n* `1 <= k <= n <= 100`\n* `1 <= times.length <= 6000`\n* `times[i].length == 3`\n* `1 <= ui, vi <= n`\n* `ui != vi`\n* `0 <= wi <= 100`\n* all the pairs `(ui, vi)` are unique. (i.e., no multiple edges.)\n\n\n## 첫인상\n\n일단 첫인상을 말하겠다. **원래 책이나 문서 보고 읽으면서 구현하는 경우가 많은 것들을 실무랑 다르게 백지시험으로 즉석 구현하라는 과제를 내다니, 과거 시험이냐?**\n\n각설하고, 이 더럽고 짜증나는 다익스트라 구현을 외우는 방법을 고심해 보자.\n\n- 우선 순위 큐 구현하는 시간 아껴야 한다. c언어로 하기 힘들다.\n- 문제를 이해하고 그 자리에서 처음부터 발명할 생각은 하지 말자. dp나 그리디면 되겠지만 이런 유형에서 절대 안 된다.\n- 짜증나도 고등학교 공부하듯 달달달 외워야 한다. 핵심 규칙을 짚고 그걸 기점으로 미친듯이 외워야 한다.\n\n\n허어..참내, 일단 외울 궁리부터 해 보자.\n\n- 거리를 담을 배열을 정의한다.\n  - 이 녀석이 가중치(거리) 이러쿵저러쿵한 결과를 담을 거다.\n  - 거리값은 충분히 큰 값으로 채운다.\n- 노드 n에서 m으로 가는 길들을 담는 동적 배열을 만든다. 여기서 대충 `adj`라고 하자.\n- 가중치 우선 정렬되어야 하니 정수쌍의 첫째를 가중치, 둘째를 노드 번호로 담자.\n- a에서 어떠한 노드까지의 이러한 정수쌍을 다 계산해서 동적배열(c++ vector같은 것)에 때려넣자.\n- **우선순위 큐를 정의한다.**\n- 최종 목적지 k까지의 가중치를 0으로 초기화한다.(예: dist[k] = 0)\n- 우선순위 큐에 `{dist[k], k}` 쌍을 때려넣는다. \n  - 이 형태를 기억해야 한다. *1*이라고 하겠다.\n- 우선 순위 큐가 빌 때까지를 조건으로 반복문을 연다. 하위 내용 반복\n  - 우선 순위 큐의 top을 뽑고 가중치와 노드 번호를 추린다. 이걸 `current`라고 한다.\n  - 현재 노드의 `adj`를 돈다. for문에서의 이터레이터를 `next`라고 하자.\n    - 만약 `next의 가중치 + 현재 current의 거리값(dist) < next`의 거리값이면 그것으로 `next의 거리값(dist)`을 갱신하고 *1*의 형태로 `next`를 때려넣는다.\n\n\n....어이가 없다. 이걸 암송해야 한다. 책 안 보고 이걸 15-20분만에 완벽 구현 후 문제에 적용하는 데까지 10-15분 써야 한다. 이러니까 내가 it를 어느 순간부터 진지하게 생각해도 되나 의구심이 든 것이다.\n\n각설하고, 이 흐름을 따라가면서 코드를 봐야 한다. 솔직히 토나오게 길지만...\n\n## 풀이\n\n```cpp\n#include <climits>\n#include <queue>\n\ntypedef pair<int, int> pii; // first: weight, second: dest\n\nclass solution {\npublic:\n    int networkdelaytime(vector<vector<int>>& times, int n, int k) {\n        int dist[101];\n        for(int i = 0; i <= n; i++) dist[i] = int_max / 2;\n\n        vector<pii> adj[101]; // to be used like adj[u].first = weight; adj[u].second = dest;\n\n        for(auto v: times) {\n            pii p;\n            p.first  = v[2];\n            p.second = v[1];\n            adj[v[0]].push_back(p);\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n\n        dist[k] = 0;\n        pq.push({dist[k], k});\n\n        while(!pq.empty()) {\n            int current_node   = pq.top().second;\n            int current_weight = pq.top().first;\n\n            pq.pop();\n\n            if(current_weight > dist[current_node]) continue;\n\n            for(auto next: adj[current_node]) {\n                int next_node   = next.second;\n                int next_weight = next.first;\n\n                if((dist[current_node] + next_weight) < dist[next_node]) {\n                    dist[next_node] = dist[current_node] + next_weight;\n                    pq.push(make_pair(dist[next_node], next_node));\n                }\n            }\n        }\n\n        int max_dist = -1;\n        for(int i = 1; i <= n; i++) {\n            if(dist[i] == (int_max/ 2)) return -1;\n            max_dist = ((dist[i] > max_dist)) ?\n                         dist[i] : max_dist   ;\n        }\n        return max_dist;\n    }\n};\n```\n\n어....진짜 뭐라고 할 말이 없다. 놀라운 건 이 정도 문제면 대기업 공채 기출에서 `쉬움`이다.\n솔직히 말해서 이런 것들까지 다 잘 풀어도 어차피 실제 프로토콜 구현할 때는 유명한 구현체를 끌어 쓸 텐데, 왜 기합을 굳이 테스트하려는 것인지 모르겠다.\n\n...뭐라고 더 할 말이 없다.\n그냥 닥치고 이거라도 외우자.\n"
    },
    {
      "title": "Apple M1 (aarch64) NEON SIMD 벤치마크 스위트",
      "subtitle": "Asahi Linux 환경에서의 ARM NEON 성능 분석",
      "description": null,
      "url": "/blog/2026/01/19/apple-m1-aarch64-neon-simd.html",
      "collection": "posts",
      "relative_path": "_posts/2026-01-19-Apple-M1-(aarch64)-NEON-SIMD-벤치마크-스위트.md",
      "date": "2026-01-19T18:00:00+09:00",
      "updated": null,
      "keywords": [
        "M1",
        "ARM64",
        "SIMD",
        "NEON",
        "Linux",
        "Benchmark"
      ],
      "categories": [
        "blog"
      ],
      "taxonomy": {
        "category": "general",
        "subcategory": "general-system",
        "order": 3
      },
      "difficulty": "intermediate",
      "excerpt": "테스트 환경 OS : Fedora Linux Asahi Remix 43 (KDE Plasma Desktop Edition) Host : Apple MacBook Pro (13-inch, M1, 2020) Kernel : Linux 6.17.12-400.asahi.fc43.aarch64+16k Compiler : gcc (Fedora 15.0.0) with --- 벤치마크 결과 캐싱 노이즈를 최소화하고 순수 연산 처리량(Throughput)을 측정하기 위해 대규모 데이터 스케일로 진행한다. | 카테…",
      "search_text": "apple m1 (aarch64) neon simd 벤치마크 스위트 asahi linux 환경에서의 arm neon 성능 분석 m1 arm64 simd neon linux benchmark blog general general-system 테스트 환경 os : fedora linux asahi remix 43 (kde plasma desktop edition) host : apple macbook pro (13-inch, m1, 2020) kernel : linux 6.17.12-400.asahi.fc43.aarch64+16k compiler : gcc (fedora 15.0.0) with --- 벤치마크 결과 캐싱 노이즈를 최소화하고 순수 연산 처리량(throughput)을 측정하기 위해 대규모 데이터 스케일로 진행한다. | 카테… \n\n## 테스트 환경\n\n* **os**: fedora linux asahi remix 43 (kde plasma desktop edition)\n* **host**: apple macbook pro (13-inch, m1, 2020)\n* **kernel**: linux 6.17.12-400.asahi.fc43.aarch64+16k\n* **compiler**: gcc (fedora 15.0.0) with `-o3 -mcpu=apple-m1`\n\n---\n\n## 벤치마크 결과\n\n캐싱 노이즈를 최소화하고 순수 연산 처리량(throughput)을 측정하기 위해 대규모 데이터 스케일로 진행한다.\n\n| 카테고리 | 작업 내용 | scalar 시간 | neon 시간 | 속도 향상(speedup) |\n| :--- | :--- | :--- | :--- | :--- |\n| **arithmetic** | 1억 개 배열 덧셈 | 0.1252s | 0.0696s | **1.80x** |\n| **bitwise** | 100mb population count | 0.4119s | 0.0148s | **27.83x** |\n| **math (fpu)** | 표준 sqrtf | 0.0471s | 0.0084s | **5.55x** |\n| **math (fpu)** | fast inverse sqrt | 0.0471s | 0.0048s | **9.71x** |\n| **string** | 100mb 문자 스캐닝 | 0.0527s | 0.0304s | **1.73x** |\n| **branchless** | 5000만 개 데이터 필터링 | 0.9323s | 0.8887s | **1.05x** |\n\n<br>\n\n<div class=\"benchmark-visual-wrapper\" style=\"font-family: -apple-system, blinkmacsystemfont, 'segoe ui', roboto, helvetica, arial, sans-serif; max-width: 100%; margin: 2rem 0;\">\n    \n    <!-- speedup chart -->\n    <div style=\"background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px; margin-bottom: 20px;\">\n        <h3 style=\"margin-top: 0; font-size: 1.1em; color: #343a40; border-bottom: 2px solid #dee2e6; padding-bottom: 10px; margin-bottom: 15px;\">🚀 속도 향상 (speedup factor)</h3>\n        \n        <!-- bar item -->\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">bitwise (popcount)</span>\n                <span style=\"font-weight: bold; color: #d63384;\">27.83x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 100%; height: 100%; background: linear-gradient(90deg, #faa2c1, #d63384); border-radius: 6px;\"></div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">math (fast invsqrt)</span>\n                <span style=\"font-weight: bold; color: #d63384;\">9.71x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 34.89%; height: 100%; background: linear-gradient(90deg, #faa2c1, #d63384); border-radius: 6px;\"></div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">math (sqrt)</span>\n                <span style=\"font-weight: bold; color: #d63384;\">5.55x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 19.94%; height: 100%; background: linear-gradient(90deg, #faa2c1, #d63384); border-radius: 6px;\"></div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">arithmetic (array add)</span>\n                <span style=\"font-weight: bold; color: #d63384;\">1.80x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 6.47%; height: 100%; background: linear-gradient(90deg, #faa2c1, #d63384); border-radius: 6px;\"></div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">string (scanning)</span>\n                <span style=\"font-weight: bold; color: #d63384;\">1.73x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 6.21%; height: 100%; background: linear-gradient(90deg, #faa2c1, #d63384); border-radius: 6px;\"></div>\n            </div>\n        </div>\n\n        <div style=\"margin-bottom: 12px;\">\n            <div style=\"display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 4px;\">\n                <span style=\"font-weight: 600; color: #495057;\">branchless (filtering)</span>\n                <span style=\"font-weight: bold; color: #868e96;\">1.05x</span>\n            </div>\n            <div style=\"background-color: #e9ecef; height: 12px; border-radius: 6px; overflow: hidden;\">\n                <div style=\"width: 3.77%; height: 100%; background: #adb5bd; border-radius: 6px;\"></div>\n            </div>\n        </div>\n        <p style=\"font-size: 0.8em; color: #868e96; text-align: right; margin-top: 10px;\">* 막대 길이가 길수록 성능 향상 폭이 큼</p>\n    </div>\n\n    <!-- time comparison chart -->\n    <div style=\"background-color: #ffffff; border: 1px solid #e9ecef; border-radius: 8px; padding: 20px;\">\n        <h3 style=\"margin-top: 0; font-size: 1.1em; color: #343a40; border-bottom: 2px solid #dee2e6; padding-bottom: 10px; margin-bottom: 15px;\">⏱️ 실행 시간 비교 (execution time)</h3>\n        \n        <!-- legend -->\n        <div style=\"display: flex; gap: 15px; margin-bottom: 15px; font-size: 0.85em;\">\n            <div style=\"display: flex; align-items: center;\"><div style=\"width: 12px; height: 12px; background: #ced4da; margin-right: 5px; border-radius: 2px;\"></div> scalar (기본)</div>\n            <div style=\"display: flex; align-items: center;\"><div style=\"width: 12px; height: 12px; background: #339af0; margin-right: 5px; border-radius: 2px;\"></div> neon (최적화)</div>\n        </div>\n\n        <!-- row: bitwise -->\n        <div style=\"margin-bottom: 15px; border-bottom: 1px dashed #f1f3f5; padding-bottom: 10px;\">\n            <div style=\"font-weight: 600; font-size: 0.9em; margin-bottom: 6px; color: #495057;\">bitwise (popcount)</div>\n            <!-- scalar bar -->\n            <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 100%; height: 100%; background: #ced4da;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #343a40;\">0.4119s</span>\n                </div>\n            </div>\n            <!-- neon bar -->\n            <div style=\"display: flex; align-items: center;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 3.6%; height: 100%; background: #339af0; min-width: 2px;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #1864ab; font-weight: bold;\">0.0148s</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- row: math invsqrt -->\n        <div style=\"margin-bottom: 15px; border-bottom: 1px dashed #f1f3f5; padding-bottom: 10px;\">\n            <div style=\"font-weight: 600; font-size: 0.9em; margin-bottom: 6px; color: #495057;\">math (fast invsqrt)</div>\n            <!-- scalar bar -->\n            <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 100%; height: 100%; background: #ced4da;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #343a40;\">0.0471s</span>\n                </div>\n            </div>\n            <!-- neon bar -->\n            <div style=\"display: flex; align-items: center;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 10.2%; height: 100%; background: #339af0; min-width: 2px;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #1864ab; font-weight: bold;\">0.0048s</span>\n                </div>\n            </div>\n        </div>\n\n        <!-- row: branchless -->\n        <div style=\"margin-bottom: 15px; border-bottom: 1px dashed #f1f3f5; padding-bottom: 10px;\">\n            <div style=\"font-weight: 600; font-size: 0.9em; margin-bottom: 6px; color: #495057;\">branchless (filtering)</div>\n             <!-- scalar bar -->\n             <div style=\"display: flex; align-items: center; margin-bottom: 4px;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 100%; height: 100%; background: #ced4da;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #343a40;\">0.9323s</span>\n                </div>\n            </div>\n            <!-- neon bar -->\n            <div style=\"display: flex; align-items: center;\">\n                <div style=\"flex-grow: 1; background: #f1f3f5; height: 18px; border-radius: 4px; overflow: hidden; position: relative;\">\n                    <div style=\"width: 95.3%; height: 100%; background: #339af0;\"></div>\n                    <span style=\"position: absolute; left: 8px; top: 50%; transform: translatey(-50%); font-size: 0.75em; color: #fff; font-weight: bold; text-shadow: 0 0 2px rgba(0,0,0,0.5);\">0.8887s</span>\n                </div>\n            </div>\n        </div>\n        \n        <p style=\"font-size: 0.8em; color: #868e96; text-align: right; margin-top: 10px;\">* 시간이 짧을수록 성능이 좋음 (대표 케이스만 표시)</p>\n    </div>\n</div>\n\n---\n\n## 주목할 점\n\n### 1. 비트 연산의 압도적 효율성\n- population count에서 보여준 **27.83배**의 성능 향상\n`vcntq_u8` 및 `vaddvq_u8` intrinsics를 활용하여 `__builtin_popcount`의 직렬 병목 현상을 우회\n  - 사이클당 16바이트를 처리\n  - 고성능 데이터베이스 인덱싱 및 데이터 압축에서 핵심적인 역할\n\n### 2. 역제곱근(inverse square root) 최적화\n- 제곱근 연산에서 **9.71배**의 속도 향상을 기록\n`vrsqrteq_f32`(reciprocal square root estimate) 명령어의 효율성을 증명한다. 3d 물리 엔진이나 실시간 신호 처리 시뮬레이션에서 필수적인 최적화 기법이다.\n\n### 3. 분기(branching)와 필터링의 한계\n데이터 필터링 벤치마크는 **1.05배**에 그쳤다.\n이는 simd가 연산 능력은 뛰어나지만, 조건부 메모리 쓰기와 같은 데이터 의존적 분기 처리에서는 병렬 실행의 이점이 제한적임을 보여준다.\n이를 해결하기 위해 `vqtbl1q_u8` 등을 이용한 zero-copy 셔플 최적화가 필요할 수 있으나, 최적화 비용에 비해 얻는 이득이 낮다.\n\n---\n\n## 빌드 및 실행 방법\n\n대상 시스템이 neon을 지원하는 `aarch64` 아키텍처인지 확인해야 한다.\n실험은 apple m1(2020) 환경에서 이루어졌다.\n\n```bash\n# 레포지토리 클론\ngit clone https://github.com/gg582/m1-arm-linux-neon-simd-benchmark.git\ncd m1-arm-linux-neon-simd-benchmark\n\n# 최적화 플래그를 사용하여 빌드\nmake\n\n# 특정 벤치마크 실행\n./simd_popcount_bench\n\n# 전체 벤치마크 실행\nmake benchmark\n\n```\n\n### 권장 gcc 플래그\n\n```bash\ngcc -o3 -mcpu=apple-m1 -fsimd-cost-model=unlimited -march=armv8-a+simd\n\n```\n\n## 생각할 거리\n\n이러한 특정 아키텍처에서 지원되는 고성능 함수들은 판도라의 상자일지도 모른다. 타겟 아키텍처로 흔하게 사용되는 amd64, arm64, risc-v 등에 대한 아키텍처 종속적 최적화를 하는 것은 흔하게 보인다.\n하지만 잘 알려지지 않은 아키텍처(예를 들면 중화권에서 사용되는 룽손64) 등에 대해 모두 최적화 코드를 작성하기 시작하면 유지 보수 비용은 하늘을 뚫고 날아가 버린다.\n특히 많은 경우에 이런 최적화는 c언어에서 이렇게 간단하게 할 수 있는 것이 아닌 인라인 어셈블리를 요구하는데, 수십 개의 아키텍처에 대해서 비트를 하나하나 검증하는 것은 고문일 수 있다.\n\n그러나 아키텍처가 정해진 초고성능 데이터베이스 관리 시스템을 운용해야 하는데, rdbms가 어디에서나 다 돌아갈 만한 범용 함수들로만 짜여져 있다면 성능 병목이 빠르게 온다. 이러한 상황에서는 저수준 최적화를 하는 것이 하지 않는 것보다 유지 보수 비용, 관리 비용, 요구 하드웨어 등이 더욱 유리하다. 고성능 rdbms 서버라고 하면 끽해야 amd64, arm64, power, ia64 중에 있을 것이므로 안 하는 것이 손해이다.\n\n이러한 기술이 저지연 임베디드 기기, 고성능 서버, 게임 프로그래밍 등에서 자주 쓰인다는 점을 부정할 수 없다. 하지만 \"이런 저수준 최적화도 하지 않는 고수준 개발자들은 무능하다\"고 말해 버리는 것은 고수준 언어에 대한 이해를 하고자 하는 일말의 양심조차 없는 태도일지 모른다.\n\n기술자에게 성능은 매혹적인 주제이다. 하지만 이 모든 것을 책임질 수 있는 구조가 있는지, 구조는 얼마나 지탱될 수 있는지도 생각하지 않은 채 무작정 진행하는 최적화는 때로는 개악일 수 있다.\n\n나는 전문 기술자도 아닐 뿐더러 재미삼아 it를 훑고 지나갈 뿐이지만, 어셈블리 최적화, riir, 모던 c/c++이 무분별하게 남용되는 현 시점에서 한 번쯤은 짚어볼 필요가 있다고 생각한다.\n"
    },
    {
      "title": "[플로이드워셜][분기문] Find the City with the Smallest Number of Neighbors at a Threshold Distance-LeetCode",
      "subtitle": "플로이드-워셜 알고리즘과 조건 분기를 활용한 최단 경로 문제",
      "description": null,
      "url": "/codingtest/2026-01-19-[플로이드워셜][분기문]-Find-the-City-with-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance-LeetCode/",
      "collection": "codingtest",
      "relative_path": "2026-01-19-[플로이드워셜][분기문]-Find-the-City-with-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance-LeetCode",
      "date": "2026-01-19T12:53:00+09:00",
      "updated": null,
      "keywords": [
        "플로이드 워셜",
        "알고리즘",
        "LeetCode",
        "분기문"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-floyd-warshall",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "[플로이드워셜][분기문]-Find the City with the Smallest Number of Neighbors at a Threshold Distance Problem Statement There are cities numbered from to . Given the array where represents a bidirectional and weighted edge between cities and , and given the integer . Return the city with the…",
      "search_text": "[플로이드워셜][분기문] find the city with the smallest number of neighbors at a threshold distance-leetcode 플로이드-워셜 알고리즘과 조건 분기를 활용한 최단 경로 문제 플로이드 워셜 알고리즘 leetcode 분기문 codingtest codingtest algorithm-floyd-warshall [플로이드워셜][분기문]-find the city with the smallest number of neighbors at a threshold distance problem statement there are cities numbered from to . given the array where represents a bidirectional and weighted edge between cities and , and given the integer . return the city with the… \n\n# [플로이드워셜][분기문]-find the city with the smallest number of neighbors at a threshold distance\n\n## problem statement\n\nthere are `n` cities numbered from `0` to `n-1`. given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distancethreshold`.\n\nreturn the city with the **smallest number of cities** that are reachable through some path and whose distance is **at most** `distancethreshold`. if there are multiple such cities, return the city with the **greatest number**.\n\nnotice that the distance of a path connecting cities `i` and `j` is equal to the sum of the edges' weights along that path.\n\n---\n\n## examples\n\n### example 1\n\n**input:** `n = 4`, `edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]]`, `distancethreshold = 4`\n**output:** `3`\n\n<div>\n<svg width=\"260\" height=\"180\" viewbox=\"0 0 260 180\" xmlns=\"http://www.w3.org/2000/svg\">\n  <line x1=\"50\" y1=\"130\" x2=\"130\" y2=\"50\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"130\" y1=\"50\" x2=\"210\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"130\" y1=\"50\" x2=\"130\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"130\" y1=\"130\" x2=\"210\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\"/>\n  <text x=\"80\" y=\"85\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">3</text>\n  <text x=\"115\" y=\"100\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">1</text>\n  <text x=\"180\" y=\"85\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">4</text>\n  <text x=\"165\" y=\"150\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">1</text>\n  <circle cx=\"50\" cy=\"130\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"46\" y=\"135\" font-family=\"arial\" font-size=\"14\">0</text>\n  <circle cx=\"130\" cy=\"50\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"126\" y=\"55\" font-family=\"arial\" font-size=\"14\">1</text>\n  <circle cx=\"130\" cy=\"130\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"126\" y=\"135\" font-family=\"arial\" font-size=\"14\">2</text>\n  <circle cx=\"210\" cy=\"130\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"206\" y=\"135\" font-family=\"arial\" font-size=\"14\">3</text>\n</svg>\n</div>\n\n**explanation:** the neighboring cities at a `distancethreshold = 4` for each city are:\n- city 0 -> [city 1, city 2]\n- city 1 -> [city 0, city 2, city 3]\n- city 2 -> [city 0, city 1, city 3]\n- city 3 -> [city 1, city 2]\ncities 0 and 3 have 2 neighboring cities at a `distancethreshold = 4`, but we have to return city 3 since it has the greatest number.\n\n### example 2\n\n**input:** `n = 5`, `edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]]`, `distancethreshold = 2`\n**output:** `0`\n\n<div>\n<svg width=\"260\" height=\"180\" viewbox=\"0 0 260 180\" xmlns=\"http://www.w3.org/2000/svg\">\n  <line x1=\"40\" y1=\"40\" x2=\"110\" y2=\"40\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"40\" y1=\"40\" x2=\"40\" y2=\"140\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"110\" y1=\"40\" x2=\"180\" y2=\"40\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"110\" y1=\"40\" x2=\"40\" y2=\"140\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"180\" y1=\"40\" x2=\"180\" y2=\"140\" stroke=\"#999\" stroke-width=\"2\"/>\n  <line x1=\"180\" y1=\"140\" x2=\"40\" y2=\"140\" stroke=\"#999\" stroke-width=\"2\"/>\n  <text x=\"70\" y=\"35\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">2</text>\n  <text x=\"20\" y=\"100\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">8</text>\n  <text x=\"140\" y=\"35\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">3</text>\n  <text x=\"80\" y=\"100\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">2</text>\n  <text x=\"185\" y=\"100\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">1</text>\n  <text x=\"110\" y=\"155\" fill=\"#e74c3c\" font-weight=\"bold\" font-size=\"14\">1</text>\n  <circle cx=\"40\" cy=\"40\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"36\" y=\"45\" font-family=\"arial\" font-size=\"14\">0</text>\n  <circle cx=\"110\" cy=\"40\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"106\" y=\"45\" font-family=\"arial\" font-size=\"14\">1</text>\n  <circle cx=\"180\" cy=\"40\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"176\" y=\"45\" font-family=\"arial\" font-size=\"14\">2</text>\n  <circle cx=\"180\" cy=\"140\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"176\" y=\"145\" font-family=\"arial\" font-size=\"14\">3</text>\n  <circle cx=\"40\" cy=\"140\" r=\"18\" fill=\"#fff\" stroke=\"#333\" stroke-width=\"2\"/>\n  <text x=\"36\" y=\"145\" font-family=\"arial\" font-size=\"14\">4</text>\n</svg>\n</div>\n\n**explanation:** the neighboring cities at a `distancethreshold = 2` for each city are:\n- city 0 -> [city 1]\n- city 1 -> [city 0, city 4]\n- city 2 -> [city 3, city 4]\n- city 3 -> [city 2, city 4]\n- city 4 -> [city 1, city 2, city 3]\nthe city 0 has 1 neighboring city at a `distancethreshold = 2`.\n\n---\n\n## constraints\n\n- `2 <= n <= 100`\n- `1 <= edges.length <= n * (n - 1) / 2`\n- `edges[i].length == 3`\n- `0 <= fromi < toi < n`\n- `1 <= weighti, distancethreshold <= 10^4`\n- all pairs `(fromi, toi)` are distinct.\n\n\n## 문제 해석\n일단 이 문제는 분기문이 나오기 전까지는 완전히 플로이드워셜 문제이다.\n일단 플로이드 워셜부터 한번 짚고 넘어가보자. 알고리즘은 쉽지만 외우려면 잘 안 외워진다.\n### 플로이드워셜\n우선 이 순회를 돌리기 전에, 초기 거리값은 자기 자신인 `i == j`만 0으로 열외시키고 충분히 큰 값을 넣어 준다.\n`dist[i][k]+dist[k][j]`로 계산하니 만약 사용 자료형이 표준 자료형이라면 c로 따지면 `limits.h`같은 곳에서 최대값을 불러오고 2로 나눈 값으로 초기화해도 상관없다.\n```c\n    for(k = 0; k < nodes; k++) {\n        for(i = 0; k < nodes; i++) {\n            for(j = 0; j < nodes; j++) {\n                dist[i][j] = (dist[i][k]+dist[k][j]) < dist[i][j] ?\n                              dist[i][k]+dist[k][j]  ? dist[i][j] ;\n            }\n        }\n    }\n```\n\n이러한 알고리즘이다. `k우선, 안에 i, j`까지는 외우기 쉬우나 안의 삼항 내지는 `if`조건문으로 구현하는 부분이 굉장히 인덱스가 어렵다.\n이것을 쉽게 외우려면 옆나라 말을 빌려오자...\n상기된 어조도 \"이쿠죠오\" 라고 말할 때의 강세를 따라 로마자로 만들면 \"ikkujoooo\"이다.\n자음만 떼보자. **ikkj**이다. 좀 유치하긴 해도 이렇게 외우면 황당해서라도 머리에 남는다.\n\nk, i, j가 모두 노드 개수만큼 순회하고 이것은 모든 방향에 대한 최단거리를 구한다.\n복잡한 다익스트라보다 이게 더 외우기 쉽다. 코딩 테스트는 일단 푸는 게 중요하니 우열을 따지지 말고 플로이드워셜로 풀이를 써나간다.\n\n### 분기문\n\n문제가 겉보기에는 플로이드워셜 알고리즘만 충실하게 익히면 되는 문제지만 아주 무서운 조건이 숨어 있다.\n```\nreturn the city with the **smallest number of cities** that are reachable through some path and whose distance is **at most** `distancethreshold`. if there are multiple such cities, return the city with the **greatest number**.\n```\n\n이 분기문이 뜻하는 바는 `distancethresheld 이하의 거리로 가장 적은 도시에 닿을 수 있는 도시를 구하시오. 만약 조건을 충족하는 경우가 다수라면 가장 번호가 큰 도시를 구하시오.`이다.\n\n도시를 탐색할 때는 어차피 for문으로 순회한다. 가장 큰 도시를 구하기 위해 맵을 그려보고 `max`함수를 구현하거나 불러올 생각을 하면 이 문제를 풀 수 없다.\n\n그렇다면 i를 순회하면서 j를 도는 과정에서 `distancethreshold 이하의 거리 수`를 세아리고 순회 과정에서 그것과 작거나 같은 거리 수를 찾으면 덮어쓰면 된다.\n이 부분은 코드로 설명하는 것이 빠르다.\n\n```c\nint answer = 0  ;\nint min_cnt= n+1;\n\nfor(int i = 0; i < n; i++) {\n    int cnt = 0;\n    for(int j = 0; j < n; j++) {\n        if((j != i)\n        && (graph[i][j] <= distancethreshold)\n        ) {\n            cnt++;\n        }\n    }\n    if(cnt<=min_cnt) {\n        min_cnt = cnt;\n        answer = i;\n    }\n}\n```\n\n\n이런 흐름으로 작성해 주면 된다.\n\n\n## 풀이\n\n풀이는 정석적으로 플로이드워셜 후 분기문으로 업데이트, 반환 순으로 가겠다. 다익스트라에 익숙하다면 그것을 써도 상관없다.\n\n\n```c\n#include <string.h>\n#include <limits.h>\n\nint findthecity(int n, int** edges, int edgessize, int* edgescolsize, int distancethreshold) {\n    int graph[101][101];\n\n    for(int i = 0; i < 101; i++) {\n        for(int j = 0; j < 101; j++) {\n            graph[i][j] = i == j     ?\n                          0          :\n                          int_max / 2;\n        }\n    }\n\n    for(int i = 0; i < edgessize; i++) {\n        graph[edges[i][0]][edges[i][1]] = edges[i][2];\n        graph[edges[i][1]][edges[i][0]] = edges[i][2];\n    }\n\n    for(int k = 0; k < n; k++) {\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                graph[i][j] = (graph[i][k] + graph[k][j]) < graph[i][j] ?\n                              graph[i][k] + graph[k][j] : graph[i][j] ;\n            }\n        }\n    }\n\n    int answer = 0  ;\n    int min_cnt= n+1;\n\n    for(int i = 0; i < n; i++) {\n        int cnt = 0;\n        for(int j = 0; j < n; j++) {\n            if((j != i)\n            && (graph[i][j] <= distancethreshold)\n            ) {\n                cnt++;\n            }\n        }\n        if(cnt<=min_cnt) {\n            min_cnt = cnt;\n            answer = i;\n        }\n    }\n\n    return answer;\n}\n```\n\n\n## 소감\n\n카카오엔터프라이즈와 같은 회사들에서 영자 문제를 낸다고 들었다. 혹시 모를 상황에 대비해 리트코드를 풀고 있다.\n문제의 질이 백준보다 상식적이고 잡일이 적다는 느낌을 받게 한다. 그러나 국내 기업에선 많은 분기문, 복잡한 제약조건, 브루트 포스형 체력검정을 아주 선호하기 때문에 이런 깔끔하고 아름다운 문제가 나온다는 것은 상상할 수 없다. 기본기를 리트코드로 익히고 백준에 업로드된 문제들을 영어로 번역하고, 그것을 백준에 제출하는 식으로 최종 준비를 해야겠다.\n개인적인 소감으로는 국내 기업 시험들도 리트코드처럼 깔끔한 문제를 내 줄 수는 없는지? 라는 생각이 들었다.\n"
    },
    {
      "title": "[스택][문자열] Simplify Path-LeetCode",
      "subtitle": "유사 유닉스 스타일의 문자열을 파싱하자",
      "description": null,
      "url": "/codingtest/2026-01-19-[스택][문자열]-Simplify-Path-LeetCode/",
      "collection": "codingtest",
      "relative_path": "2026-01-19-[스택][문자열]-Simplify-Path-LeetCode",
      "date": "2026-01-19T12:53:00+09:00",
      "updated": null,
      "keywords": [
        "문자열",
        "알고리즘",
        "스택"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-data-structure",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "[LeetCode] 71. Simplify Path Problem Description You are given an absolute path for a Unix-style file system, which always begins with a slash . Your task is to transform this absolute path into its simplified canonical path . The rules of a Unix-style file system are as follows:…",
      "search_text": "[스택][문자열] simplify path-leetcode 유사 유닉스 스타일의 문자열을 파싱하자 문자열 알고리즘 스택 codingtest codingtest algorithm-data-structure [leetcode] 71. simplify path problem description you are given an absolute path for a unix-style file system, which always begins with a slash . your task is to transform this absolute path into its simplified canonical path . the rules of a unix-style file system are as follows:… \n\n## [leetcode] 71. simplify path\n\n### problem description\n\nyou are given an absolute path for a unix-style file system, which always begins with a slash `/`. your task is to transform this absolute path into its **simplified canonical path**.\n\nthe rules of a unix-style file system are as follows:\n\n* a single period `.` represents the current directory.\n* a double period `..` represents the previous/parent directory.\n* multiple consecutive slashes such as `//` and `///` are treated as a single slash `/`.\n* any sequence of periods that does not match the rules above should be treated as a valid directory or file name. for example, `...` and `....` are valid directory or file names.\n\nthe **simplified canonical path** should follow these rules:\n\n1. the path must start with a single slash `/`.\n2. directories within the path must be separated by exactly one slash `/`.\n3. the path must not end with a slash `/`, unless it is the root directory.\n4. the path must not have any single or double periods (`.` and `..`) used to denote current or parent directories.\n\n---\n\n### examples\n\n| input | output | explanation |\n| --- | --- | --- |\n| `\"/home/\"` | `\"/home\"` | trailing slash is removed. |\n| `\"/home//foo/\"` | `\"/home/foo\"` | consecutive slashes are replaced by a single one. |\n| `\"/home/user/documents/../pictures\"` | `\"/home/user/pictures\"` | `\"..\"` refers to the parent directory. |\n| `\"/../\"` | `\"/\"` | going up from the root is not possible. |\n| `\"/.../a/../b/c/../d/./\"` | `\"/.../b/d\"` | `\"...\"` is treated as a valid directory name. |\n\n---\n\n### constraints\n\n* `1 <= path.length <= 3000`\n* `path` consists of english letters, digits, period `.`, slash `/`, or underscore `_`.\n* `path` is a valid absolute unix path.\n\n---\n\n### visual logic: stack operations\n\nthe most efficient way to solve this is using a **stack** data structure.\n\n1. **tokenize**: split the string by `/`.\n2. **process**:\n* if token is `..`: `pop` from stack (if not empty).\n* if token is `.` or empty: `ignore`.\n* otherwise: `push` token to stack.\n\n\n3. **reconstruct**: join stack elements with `/`.\n\n---\n\n## 문제 분석\n\n실제 쉘에서는 예외 처리되는 ... 등을 여기서는 폴더명으로 허가하겠다고 했다.\n여기서 일반적인 유닉스, 리눅스 pc와 동일하게 작동하는 것은 `.`과 `..`뿐이다.\n그렇다면 폴더명은 푸시, `..`은 팝, `.`은 무시하면 그만이다.\n그러나 나는 복잡한 알고리즘 문제가 아니고서야 c++보다 c를 기준으로 보고 공부했다.\nc++의 스트링 함수, i/o 스트림 등을 위해 문서를 뒤질 시간에 직접 구현하면 된다.\n그것을 쉽게 하기 위해서 이번에는 strdup을 배워 보자.\n\n## strdup으로 시작하는 안전한 문자열 할당\nstrdup의 인자로 어떠한 문자열을 집어넣으면 공간을 알아서 동적 할당하고 복사까지 해서 시작 주소를 반환한다.\n구체적으로 예시를 들어 비교해보자.\n\n### 첫번째 방식\n```c\nchar *str1 = \"hello\"                 ;\nchar *str2 = malloc(strlen(str1) + 1); // char * should end with null escape\n\nmemset(str2, 0, sizeof(str1) + 1) ;\nstrncpy(str1, str2, strlen(hello));\n```\n\n### 두번째 방식\n```c\nchar *str1 = \"hello\"     ;\nchar *str2 = strdup(str1);\n```\n\n역시 strdup을 쓰면 코드가 보기 예쁘다. 이렇게 적용해서 쉬운 문자열 파싱을 하는 코드를 작성하자.\n\n## 풀이\n\n```c\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nchar* simplifypath(char* path) {\n    char* stack[3001];\n    int top = -1;\n\n    // tokenize using strtok\n    char* token = strtok(path, \"/\");\n    while (token != null) {\n        if (strcmp(token, \".\") == 0) {\n            // current directory. ignore\n        } else if (strcmp(token, \"..\") == 0) {\n            // parent directory. pop from stack if not empty\n            if (top >= 0) {\n                free(stack[top]); // always free unused memory\n                top--;\n            }\n        } else {\n            // normal directory. push to stack\n            top++;\n            stack[top] = strdup(token); // copy with strdup\n        }\n        token = strtok(null, \"/\");\n    }\n\n    // assemble the result string\n    if (top == -1) return strdup(\"/\");\n\n    char* res = (char*)calloc(3001, sizeof(char));\n    for (int i = 0; i <= top; i++) {\n        strcat(res, \"/\");\n        strcat(res, stack[i]);\n        free(stack[i]); // free memory while assembling\n    }\n\n    return res;\n}\n```\n\n여전히 어딘가 찜찜한 느낌이 있다. 코딩 테스트를 위한 코드라는 느낌이 너무 세다.\n정석적인 코드에서 주석만 코딩 테스트 스타일로 간단하게 해서 다시 써 보자.\n\n\n```c\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n// global stack\nchar* stack[3001];\nint top = -1;\n\nvoid push(char* token) {\n    top++;\n    stack[top] = strdup(token); // copy token\n}\n\nvoid pop() {\n    if (top >= 0) {\n        free(stack[top]); // free memory\n        top--;\n    }\n}\n\nchar* simplifypath(char* path) {\n    top = -1;\n    char* saveptr; // pointer for reentrant state\n\n    // tokenize by /\n    char* token = strtok_r(path, \"/\", &saveptr);\n    while (token != null) {\n        if (strcmp(token, \".\") == 0) {\n            // ignore current dir\n        } else if (strcmp(token, \"..\") == 0) {\n            // pop if not empty\n            pop();\n        } else {\n            // push directory\n            push(token);\n        }\n        token = strtok_r(null, \"/\", &saveptr);\n    }\n\n    if (top == -1) return strdup(\"/\");\n\n    // build result\n    char* res = (char*)calloc(3001, sizeof(char));\n    for (int i = 0; i <= top; i++) {\n        strcat(res, \"/\");\n        strcat(res, stack[i]);\n        free(stack[i]); // free after use\n    }\n\n    return res;\n}\n```\n\n`strtok_r`, 분리된 스택, 함수의 명확한 역할..\n역시 이래야 코드의 가독성이 좋다.\n이러한 문제는 짧으니 대략적으로 해도 좋으나 긴 문제에선 한 함수에 모든 것을 모는 것은 c에선 절대 지양하도록 하자.\n"
    },
    {
      "title": "[단조스택] Remove K Digits-LeetCode",
      "subtitle": "단조 스택을 활용한 숫자 최소화 문제",
      "description": null,
      "url": "/codingtest/2026-01-18-[단조스택]-Remove-K-Digits-LeetCode/",
      "collection": "codingtest",
      "relative_path": "2026-01-18-[단조스택]-Remove-K-Digits-LeetCode",
      "date": "2026-01-18T15:56:00+09:00",
      "updated": null,
      "keywords": [
        "단조스택",
        "스택",
        "LeetCode",
        "알고리즘",
        "그리디"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-data-structure",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "--- 문제 Problem Statement Given a string representing a non-negative integer, and an integer , return the smallest possible integer after removing digits from . Constraints consists of only digits. does not have any leading zeros except for the zero itself. --- Examples Example 1:…",
      "search_text": "[단조스택] remove k digits-leetcode 단조 스택을 활용한 숫자 최소화 문제 단조스택 스택 leetcode 알고리즘 그리디 codingtest codingtest algorithm-data-structure --- 문제 problem statement given a string representing a non-negative integer, and an integer , return the smallest possible integer after removing digits from . constraints consists of only digits. does not have any leading zeros except for the zero itself. --- examples example 1:… \n\n---\n\n## 문제\n\n### problem statement\n\ngiven a string `num` representing a non-negative integer, and an integer `k`, return *the smallest possible integer after removing `k` digits from `num`.*\n\n### constraints\n\n* \n* `num` consists of only digits.\n* `num` does not have any leading zeros except for the zero itself.\n\n---\n\n### examples\n\n**example 1:**\n\n> **input:** `num = \"1432219\"`, `k = 3`\n> **output:** `\"1219\"`\n> **explanation:** remove the three digits `4`, `3`, and `2` to form the new number `1219` which is the smallest.\n\n**example 2:**\n\n> **input:** `num = \"10200\"`, `k = 1`\n> **output:** `\"200\"`\n> **explanation:** remove the leading `1` and the number is `200`. note that the output must not contain leading zeroes.\n\n**example 3:**\n\n> **input:** `num = \"10\"`, `k = 2`\n> **output:** `\"0\"`\n> **explanation:** remove all the digits from the number and it is left with nothing which is `0`.\n\n---\n\n### 집중해야 할 부분\n\n일단 영어라서 읽는 데 시간은 더 들지도 모르지만 non-negative integer라고 본문에서 대놓고 말했다.\n이 문제는 항상 0 혹은 자연수를 반환한다.\n\n중요한 사실은 leading zero를 제거하라는 부분이다. 이것을 제거하는 것은 ltrim을 따로 함수로 짜면 어렵지 않고, 만약 우리가 실무 코드를 짠다면 데이터 노출 위험이 있는 포인터 연산을 피했겠지만 그런 상황이 아니니까 `while(*str != '0') str++; return str;`으로 간결한 처리를 해도 된다.\n\n그리고 여기서 단조스택(monotonic stack)이라는 것이 나온다. 우리에게 익숙한 단조는 접쇠를 만들어서 두드리는 것, 혹은 음악에서의 마이너 스케일이라 와닿지 않지만, 한자로 보면 `單調`이기 때문에 `mono / tonic`을 직역한 것이다.\n\n스택을 단조 스택으로서 활용하는 것은 패턴이 비슷하다.\n\n한국어로 이와 같은 과정을 거친다.\n```\n인덱스를 돌기 {\n    스택이 비지 않았으면서 스택의 top이 조건에 부합할 때까지 {\n        top을 가져와서 그 값으로 필요한 연산을 하고, 그 top은 스택에서 뽑아버린다.\n    }\n    스택에 현재 인덱스를 집어넣는다.\n}\n```\n\n과정이나 원리는 단순하지만 문제를 보자마자 단조 스택을 바로 발명할 수 있는 사람은 드물 것이다. 그렇기 때문에 특정 조건을 만족하는 문제가 전체에 일괄 규칙이 있는 것이 아니고 문맥 상에서 발생할 때, 특히나 이 문제와 판박이일 때는 단조 스택을 암기해 뒀다가 그대로 응용하면 된다.\n\n이 문제는 단조 스택과 인덱스를 활용한다는 데에 그 발상이 크게 연관되어 있다. 그러나 이러한 것을 날것의 인덱스/필요한 값으로 냅다 쓰면 코드를 짜다가 헷갈리기 좋다. c언어에선 구조체로, c++에서는 한 쌍의 묶음을 만들어 예쁘게 쓰는 것도 방법이다.\n\n아래의 풀이는 기본적으로 유사 객체 지향으로 진행된다. 풀이는 아래와 같다.\n\n### 풀이\n\n```c\n#include <string.h>\n\ntypedef struct character {\n    int index;\n    char c;\n} character;\n\ncharacter stack[100001];\nint top = -1;\n\nvoid push(character x) {\n    top++;\n    stack[top] = x;\n}\n\ncharacter pop() {\n    static character placeholder; // placeholder to prevent underflow\n    placeholder.index = -1      ;\n    placeholder.c     = '\\0'    ;\n\n    if(top == -1) return placeholder; // return placeholder here\n    character ret = stack[top];\n    top--;\n    return ret;\n}\n\nint stacking_location = -1;\nvoid stack_char(char *arr, char c) {\n    stacking_location++       ;\n    arr[stacking_location] = c;\n}\n\nchar *ltrim(char *str) {\n    while(*str == '0') {\n        str++;\n    }\n    return str;\n}\n\nchar* removekdigits(char* num, int k) {\n    static char answer[100001];\n    const size_t character_array_size = strnlen(num, 100001);\n    character numwithindex[character_array_size];\n\n    top = -1;\n    stacking_location = -1;\n    memset(answer, 0, sizeof(answer));\n\n    // assign char-index pair\n    for(int i = 0; i < character_array_size; i++) {\n        numwithindex[i].c     = num[i];\n        numwithindex[i].index = i     ;\n    }\n\n    int cnt = 0;\n    for(int i = 0; i < character_array_size; i++) {\n        while(top > -1 && stack[top].c > numwithindex[i].c && cnt < k) {\n            character c = pop()       ;\n            if(c.index == -1) continue;\n\n            num[c.index] = '\\0';\n            cnt++              ;\n        }\n        push(numwithindex[i]);\n    }\n\n    // reduce if cnt < k\n    while(cnt < k && top > -1) {\n        character c  = pop();\n        num[c.index] = '\\0';\n        cnt++;\n    }\n    for(int i = 0; i < character_array_size; i++) {\n        if(num[i] != '\\0') {\n            stack_char(answer, num[i]);\n        }\n    }\n    char *final_answer = ltrim(answer);\n    if(strlen(final_answer) == 0) {\n        return \"0\";\n    }\n    return final_answer;\n}\n```\n\n\n## 맺으며\n\n이러한 것을 발상만 알면 언제나 떠올릴 수 있다고 하는 것은 그들만의 리그이다. 나와 같은 평범한 학생들은 원리만 안다고 바로 떠오를 리가 없다.\n만약 누군가가 아주 비상한 지능을 가지고 있다면 그렇게 한다고 해도 괜찮다. 하지만 충분히 머리가 좋지 않다면 유형을 눈에 익혀두는 것이 중요하다.\n"
    },
    {
      "title": "[그래프] 가장-먼-노드-레벨3",
      "subtitle": "BFS를 활용한 최단 거리 탐색 문제",
      "description": null,
      "url": "/codingtest/2026-01-18-[그래프]-가장-먼-노드-레벨3/",
      "collection": "codingtest",
      "relative_path": "2026-01-18-[그래프]-가장-먼-노드-레벨3",
      "date": "2026-01-18T13:01:00+09:00",
      "updated": null,
      "keywords": [
        "그래프",
        "BFS",
        "최단거리",
        "프로그래머스",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-graph",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "--- 문제 n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드 란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항 노드의 개수 n은 2 이상 2…",
      "search_text": "[그래프] 가장-먼-노드-레벨3 bfs를 활용한 최단 거리 탐색 문제 그래프 bfs 최단거리 프로그래머스 알고리즘 codingtest codingtest algorithm-graph --- 문제 n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드 란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항 노드의 개수 n은 2 이상 2… \n\n---\n\n\n## 문제\n\nn개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. **가장 멀리 떨어진 노드**란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.\n\n노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.\n\n## 제한사항\n\n* 노드의 개수 n은 2 이상 20,000 이하입니다.\n* 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.\n* vertex 배열 각 행 `[a, b]`는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.\n\n## 입출력 예\n\n| n | vertex | return |\n| --- | --- | --- |\n| 6 | `[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]` | **3** |\n\n---\n\n## 입출력 예 설명\n\n예제의 그래프를 최단 경로 계층별로 시각화하면 다음과 같습니다.\n\n<div>\n<svg width=\"400\" height=\"300\" viewbox=\"0 0 400 300\" xmlns=\"[http://www.w3.org/2000/svg](http://www.w3.org/2000/svg)\">\n<line x1=\"200\" y1=\"50\" x2=\"130\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"200\" y1=\"50\" x2=\"270\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"130\" y1=\"130\" x2=\"270\" y2=\"130\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"130\" y1=\"130\" x2=\"60\" y2=\"230\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"130\" y1=\"130\" x2=\"160\" y2=\"230\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"270\" y1=\"130\" x2=\"160\" y2=\"230\" stroke=\"#999\" stroke-width=\"2\" />\n<line x1=\"270\" y1=\"130\" x2=\"300\" y2=\"230\" stroke=\"#999\" stroke-width=\"2\" />\n<circle cx=\"200\" cy=\"50\" r=\"20\" fill=\"#4a90e2\" stroke=\"#fff\" stroke-width=\"2\" />\n<text x=\"200\" y=\"55\" text-anchor=\"middle\" fill=\"#fff\" font-weight=\"bold\">1</text>\n<circle cx=\"130\" cy=\"130\" r=\"20\" fill=\"#fff\" stroke=\"#4a90e2\" stroke-width=\"2\" />\n<text x=\"130\" y=\"135\" text-anchor=\"middle\" fill=\"#4a90e2\" font-weight=\"bold\">3</text>\n<circle cx=\"270\" cy=\"130\" r=\"20\" fill=\"#fff\" stroke=\"#4a90e2\" stroke-width=\"2\" />\n<text x=\"270\" y=\"135\" text-anchor=\"middle\" fill=\"#4a90e2\" font-weight=\"bold\">2</text>\n<circle cx=\"60\" cy=\"230\" r=\"22\" fill=\"#ffedeb\" stroke=\"#ff5252\" stroke-width=\"2\" stroke-dasharray=\"4\" />\n<text x=\"60\" y=\"235\" text-anchor=\"middle\" fill=\"#ff5252\" font-weight=\"bold\">6</text>\n<circle cx=\"160\" cy=\"230\" r=\"22\" fill=\"#ffedeb\" stroke=\"#ff5252\" stroke-width=\"2\" stroke-dasharray=\"4\" />\n<text x=\"160\" y=\"235\" text-anchor=\"middle\" fill=\"#ff5252\" font-weight=\"bold\">4</text>\n<circle cx=\"300\" cy=\"230\" r=\"22\" fill=\"#ffedeb\" stroke=\"#ff5252\" stroke-width=\"2\" stroke-dasharray=\"4\" />\n<text x=\"300\" y=\"235\" text-anchor=\"middle\" fill=\"#ff5252\" font-weight=\"bold\">5</text>\n</svg>\n</div>\n\n1. **1번 노드와의 거리 1**: 2번, 3번 노드\n2. **1번 노드와의 거리 2**: 4번, 5번, 6번 노드\n\n1번 노드에서 가장 멀리 떨어진 노드는 **4, 5, 6번 노드**이므로, 총 **3**을 반환합니다.\n\n### 문제 풀이\n\n가장 먼 노드를 찾는 문제는 자료 구조 시간에 배우는 가장 정석적인 알고리즘이지만 여기서는 가장 먼 노드**들**을 찾는 문제이다.\n하나의 노드만을 찾는 것이 아니고 여럿을 찾아야 한다.\n이 때 bfs를 단순히 여러 번을 돌리면 bfs 탐색에 걸리는 시간 * 반복 횟수이기 때문에 문제의 노드 수를 봐서 시간 초과이다.\n이런 경우 영리한 전략을 세워야 한다.\n\nbfs에서 깊이는 기준점으로부터의 거리이다. 그 말은 문제에서 말한 1번 노드로부터 탐색하며 각 노드의 깊이를 기록해 가장 깊은 노드와 같은 깊이를 가진 노드를 찾으면 된다.\n사진학에서의 비유를 이용하자면 이것은 깊이보다 심도라고 칭하는 것이 더 정확하다. 말하자면, 현재 포커싱 존이 충분히 좁고 존으로부터 3m 떨어진 피사체가 있다고 하면 존으로부터 3미터 반경 내외의 피사체에 대한 심도는 동일한 것이다.\n\n그렇다면 일단 다음 노드가 무엇인지 간선 정보를 저장하는 `vector<int> *` 형으로 연속된 메모리 공간을 잡아 준다.\n가장 편하게 배열을 이용해서 메모리 공간을 잡아 주자.\n```cpp\nvector<int> nodes[20001];\n```\n과 같이 선언하면 스택 영역에 20001개의 연속된 정수 벡터가 생긴다.\nstl 타입들은 동적 할당 시에 c++ 스타일이고 c스타일을 선호하는 작업자에게는 호불호가 갈린다.\n이런 코딩 테스트에서는 자원을 많이 소모하지 않는다면 배열로 두는 것도 나쁘지 않다.\n\n다음으로 필요한 것들은 *depth와 *visited이다. 1-based index를 이용해 주기 위해서 입력받은 크기 n에 1을 더해서 `n+1`만큼 힙 영역에 동적 할당한다.\n메모리를 0으로 채우는 시간을 아끼기 위해 zero-fill을 위한 최적화가 잘 된 c의 `calloc`을 빌리도록 하자.\n\nbfs 코드에서 반드시 심도를 세어 줘야 한다. bfs 부분만을 떼서 작성하자면 아래와 같다.\n\n```cpp\nint bfs() { // return deepest depth from 1th node\n    queue<int> q;\n    q.push(1);\n    depth[1] = 1;\n    int max_depth    = 1   ;\n    int current_node = 1   ;\n    visited[1]       = true;\n    while(!q.empty()) {\n        if(!q.empty()) {\n            current_node = q.front();\n            q.pop();\n        } else {\n            break; // duplicate safe code; can be removed when developing production code?\n        }\n        \n        visited[current_node] = true;\n        \n        for(int i = 0; i < nodes[current_node].size(); i++) {\n            int next = nodes[current_node][i];\n            if(!visited[next]) {\n                visited[next] = true   ;\n                q.push (next)          ;\n                depth  [next] = \n                depth[current_node] + 1;    // 매우 중요한 부분. 심도를 센다.\n                max_depth     = max(max_depth,\n                                    depth[next]); // 심도만 센다고 되는 것이 아니다. 심도를 센 후 가장 깊은 심도라면 기록한다.\n            }\n        }\n        \n    }\n    return max_depth;\n}\n```\n이를 이용하면 가장 깊은 심도를 잴 수가 있다.\n\n```cpp\n    int depth_target = bfs();\n    \n    for(int i = 1; i <= n; i++) {\n        if(depth[i] == depth_target) answer++;\n    }\n```\n이를 이용하여 같은 심도를 가진 노드의 수를 세어 주면 정답이다.\n\n### 잡다한 노동에서 알아둘 점\n프로그래머스가 solution 함수만을 받는 이유는 함수가 자신들의 main 안에서 호출되고 변수들은 코드 맥락에서 재활용되게 하는 것을 유도하는 데에 있다.\n할당한 변수, 배열, 메모리 공간 등은 그때그때 비우거나 zero-fill한다. 그러나 c++ stl 등의 복잡한 자료들을 zero-fill로 처리한다고 생각하지 말자.\n또한, 이러한 코딩 테스트는 시간 복잡도를 중요하게 보지만, n이 십만이 넘더라도 단일 반복문까지 불가능한 문제는 굉장히 고난도 문제이다.\n웬만한 경우에는 `log(n)`만큼의 시간복잡도 추가에 관용적이다. 필요에 따라 다익스트라, a* 등의 높은 시간 복잡도를 가진 알고리즘을 사용해야 한다면 가능한 한 적은 횟수로 명시적 호출하도록 하자.\n\n### 완성된 풀이\n\n```cpp\n#include <string>\n#include <vector>\n#include <cstdlib> // to use calloc\n#include <cstring> // to use memset\n#include <queue>\n\nusing namespace std;\n\nvector<int> nodes[20001];\nint  *depth  ;\nbool *visited;\n\nint bfs() { // return deepest depth from 1th node\n    queue<int> q;\n    q.push(1);\n    depth[1] = 1;\n    int max_depth    = 1   ;\n    int current_node = 1   ;\n    visited[1]       = true;\n    while(!q.empty()) {\n        if(!q.empty()) {\n            current_node = q.front();\n            q.pop();\n        } else {\n            break; // duplicate safe code; can be removed when developing production code?\n        }\n        \n        visited[current_node] = true;\n        \n        for(int i = 0; i < nodes[current_node].size(); i++) {\n            int next = nodes[current_node][i];\n            if(!visited[next]) {\n                visited[next] = true   ;\n                q.push (next)          ;\n                depth  [next] = \n                depth[current_node] + 1;\n                max_depth     = max(max_depth,\n                                    depth[next]);\n            }\n        }\n        \n    }\n    return max_depth;\n}\n\nint solution(int n, vector<vector<int>> edge) {\n    int answer = 0;\n    \n    for(int i = 0; i < 20001; i++) {\n        nodes[i].clear();\n    }\n    depth   = (int *) calloc((size_t) n+1, sizeof(int ));\n    for(int i = 0; i <= n; i++) nodes[i].clear();\n    visited = (bool*) calloc((size_t) n+1, sizeof(bool ));\n    \n    for(auto e: edge) {\n        nodes[e[0]].push_back(e[1]);\n        nodes[e[1]].push_back(e[0]);\n    }\n    \n    int depth_target = bfs();\n    \n    for(int i = 1; i <= n; i++) {\n        if(depth[i] == depth_target) answer++;\n    }\n    \n    free(depth);\n    free(visited);\n    \n    return answer;\n}\n```\n"
    },
    {
      "title": "[그래프] 도넛과 막대 그래프-프로그래머스-레벨2",
      "subtitle": "그래프 탐색을 활용한 그래프 유형 판별 문제",
      "description": null,
      "url": "/codingtest/2026-01-17-[그래프]-도넛과-막대-그래프-프로그래머스-레벨2/",
      "collection": "codingtest",
      "relative_path": "2026-01-17-[그래프]-도넛과-막대-그래프-프로그래머스-레벨2",
      "date": "2026-01-17T18:01:00+09:00",
      "updated": null,
      "keywords": [
        "그래프",
        "탐색",
        "프로그래머스",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-graph",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "--- 문제 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다. 크기가 인 도넛 모양 그래프는 개의 정점과 개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다. n=1 n=2 n=3 n=4 크기가 인 막대 모양 그…",
      "search_text": "[그래프] 도넛과 막대 그래프-프로그래머스-레벨2 그래프 탐색을 활용한 그래프 유형 판별 문제 그래프 탐색 프로그래머스 알고리즘 codingtest codingtest algorithm-graph --- 문제 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다. 크기가 인 도넛 모양 그래프는 개의 정점과 개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다. n=1 n=2 n=3 n=4 크기가 인 막대 모양 그… \n\n---\n\n## 문제\n\n도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프들이 있습니다. 이 그래프들은 1개 이상의 정점과, 정점들을 연결하는 단방향 간선으로 이루어져 있습니다.\n\n크기가 인 도넛 모양 그래프는 개의 정점과 개의 간선이 있습니다. 도넛 모양 그래프의 아무 한 정점에서 출발해 이용한 적 없는 간선을 계속 따라가면 나머지 개의 정점들을 한 번씩 방문한 뒤 원래 출발했던 정점으로 돌아오게 됩니다. 도넛 모양 그래프의 형태는 다음과 같습니다.\n\n<div>\n<div>\n<svg width=\"80\" height=\"80\">\n<defs><marker id=\"arrow\" markerwidth=\"10\" markerheight=\"10\" refx=\"9\" refy=\"5\" orient=\"auto\"><path d=\"m0,0 l0,10 l10,5 z\" fill=\"#666\" /></marker></defs>\n<circle cx=\"40\" cy=\"40\" r=\"10\" fill=\"#4a90e2\" />\n<path d=\"m 50 40 a 12 12 0 1 1 49.9 40\" stroke=\"#666\" fill=\"none\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=1</text>\n</svg>\n</div>\n<div>\n<svg width=\"80\" height=\"80\">\n<circle cx=\"25\" cy=\"40\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"55\" cy=\"40\" r=\"8\" fill=\"#4a90e2\" />\n<path d=\"m 33 36 q 40 25 47 36\" stroke=\"#666\" fill=\"none\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 47 44 q 40 55 33 44\" stroke=\"#666\" fill=\"none\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=2</text>\n</svg>\n</div>\n<div>\n<svg width=\"80\" height=\"80\">\n<circle cx=\"40\" cy=\"25\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"60\" cy=\"55\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"20\" cy=\"55\" r=\"8\" fill=\"#4a90e2\" />\n<path d=\"m 45 28 l 54 46\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 52 55 l 28 55\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 23 46 l 35 28\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=3</text>\n</svg>\n</div>\n<div>\n<svg width=\"80\" height=\"80\">\n<circle cx=\"25\" cy=\"25\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"55\" cy=\"25\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"55\" cy=\"55\" r=\"8\" fill=\"#4a90e2\" />\n<circle cx=\"25\" cy=\"55\" r=\"8\" fill=\"#4a90e2\" />\n<path d=\"m 33 25 l 47 25\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 55 33 l 55 47\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 47 55 l 33 55\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 25 47 l 25 33\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=4</text>\n</svg>\n</div>\n</div>\n\n크기가 인 막대 모양 그래프는 개의 정점과 개의 간선이 있습니다. 막대 모양 그래프는 임의의 한 정점에서 출발해 간선을 계속 따라가면 나머지 개의 정점을 한 번씩 방문하게 되는 정점이 단 하나 존재합니다. 막대 모양 그래프의 형태는 다음과 같습니다.\n\n<div>\n<div>\n<svg width=\"80\" height=\"80\"><circle cx=\"40\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" /><text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=1</text></svg>\n</div>\n<div>\n<svg width=\"80\" height=\"80\">\n<circle cx=\"20\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" /><circle cx=\"60\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" />\n<line x1=\"28\" y1=\"40\" x2=\"52\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"40\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=2</text>\n</svg>\n</div>\n<div>\n<svg width=\"100\" height=\"80\">\n<circle cx=\"15\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" /><circle cx=\"50\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" /><circle cx=\"85\" cy=\"40\" r=\"8\" fill=\"#50e3c2\" />\n<line x1=\"23\" y1=\"40\" x2=\"42\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<line x1=\"58\" y1=\"40\" x2=\"77\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"50\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=3</text>\n</svg>\n</div>\n<div>\n<svg width=\"120\" height=\"80\">\n<circle cx=\"15\" cy=\"40\" r=\"7\" fill=\"#50e3c2\" /><circle cx=\"45\" cy=\"40\" r=\"7\" fill=\"#50e3c2\" /><circle cx=\"75\" cy=\"40\" r=\"7\" fill=\"#50e3c2\" /><circle cx=\"105\" cy=\"40\" r=\"7\" fill=\"#50e3c2\" />\n<line x1=\"22\" y1=\"40\" x2=\"38\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<line x1=\"52\" y1=\"40\" x2=\"68\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<line x1=\"82\" y1=\"40\" x2=\"98\" y2=\"40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"60\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=4</text>\n</svg>\n</div>\n</div>\n\n크기가 인 8자 모양 그래프는 개의 정점과 개의 간선이 있습니다. 8자 모양 그래프는 크기가 동일한 2개의 도넛 모양 그래프에서 정점을 하나씩 골라 결합시킨 형태의 그래프입니다. 8자 모양 그래프의 형태는 다음과 같습니다.\n\n<div>\n<div>\n<svg width=\"140\" height=\"80\">\n<circle cx=\"45\" cy=\"40\" r=\"15\" fill=\"none\" stroke=\"#666\" stroke-width=\"2\" />\n<circle cx=\"95\" cy=\"40\" r=\"15\" fill=\"none\" stroke=\"#666\" stroke-width=\"2\" />\n<circle cx=\"70\" cy=\"40\" r=\"8\" fill=\"#f5a623\" />\n<circle cx=\"30\" cy=\"40\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/><circle cx=\"110\" cy=\"40\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/>\n<text x=\"70\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=1</text>\n</svg>\n</div>\n<div>\n<svg width=\"180\" height=\"80\">\n<ellipse cx=\"50\" cy=\"40\" rx=\"30\" ry=\"15\" fill=\"none\" stroke=\"#666\" stroke-width=\"2\"/>\n<ellipse cx=\"130\" cy=\"40\" rx=\"30\" ry=\"15\" fill=\"none\" stroke=\"#666\" stroke-width=\"2\"/>\n<circle cx=\"90\" cy=\"40\" r=\"8\" fill=\"#f5a623\" />\n<circle cx=\"35\" cy=\"32\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/><circle cx=\"35\" cy=\"48\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/>\n<circle cx=\"145\" cy=\"32\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/><circle cx=\"145\" cy=\"48\" r=\"5\" fill=\"#f5a623\" opacity=\"0.6\"/>\n<text x=\"90\" y=\"75\" font-size=\"10\" text-anchor=\"middle\">n=2</text>\n</svg>\n</div>\n</div>\n\n도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프가 여러 개 있습니다. 이 그래프들과 무관한 정점을 하나 생성한 뒤, 각 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 임의의 정점 하나로 향하는 간선들을 연결했습니다. 그 후 각 정점에 서로 다른 번호를 매겼습니다. 이때 당신은 그래프의 간선 정보가 주어지면 생성한 정점의 번호와 정점을 생성하기 전 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 구해야 합니다.\n\n그래프의 간선 정보를 담은 2차원 정수 배열 `edges`가 매개변수로 주어집니다. 이때, 생성한 정점의 번호, 도넛 모양 그래프의 수, 막대 모양 그래프의 수, 8자 모양 그래프의 수를 순서대로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.\n\n### 제한사항\n\n*  `edges`의 길이 \n* `edges`의 원소는 `[a, b]` 형태이며, `a`번 정점에서 `b`번 정점으로 향하는 간선이 있다는 것을 나타냅니다.\n* \n* 문제의 조건에 맞는 그래프가 주어집니다.\n* 도넛 모양 그래프, 막대 모양 그래프, 8자 모양 그래프의 수의 합은 2이상입니다.\n\n### 입출력 예\n\n| edges | result |\n| --- | --- |\n| `[[2, 3], [4, 3], [1, 1], [2, 1]]` | `[2, 1, 1, 0]` |\n| `[[4, 11], [1, 12], [8, 3], [12, 7], [4, 2], [7, 11], [4, 8], [9, 6], [10, 11], [6, 10], [3, 5], [11, 1], [5, 3], [11, 9], [3, 8]]` | `[4, 0, 1, 2]` |\n\n### 입출력 예 설명\n\n**입출력 예 #1**\n주어진 그래프를 그림으로 나타내면 다음과 같습니다.\n\n<div>\n<svg width=\"250\" height=\"120\">\n<circle cx=\"50\" cy=\"40\" r=\"15\" fill=\"#ff8a80\" /><text x=\"50\" y=\"45\" font-size=\"12\" text-anchor=\"middle\" fill=\"white\">2</text>\n<circle cx=\"120\" cy=\"40\" r=\"15\" fill=\"#4a90e2\" /><text x=\"120\" y=\"45\" font-size=\"12\" text-anchor=\"middle\" fill=\"white\">1</text>\n<circle cx=\"50\" cy=\"90\" r=\"15\" fill=\"#50e3c2\" /><text x=\"50\" y=\"95\" font-size=\"12\" text-anchor=\"middle\" fill=\"white\">4</text>\n<circle cx=\"120\" cy=\"90\" r=\"15\" fill=\"#50e3c2\" /><text x=\"120\" y=\"95\" font-size=\"12\" text-anchor=\"middle\" fill=\"white\">3</text>\n<path d=\"m 65 40 l 105 40\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 50 55 l 50 75\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 65 90 l 105 90\" stroke=\"#666\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<path d=\"m 132 32 a 10 10 0 1 1 132 48\" stroke=\"#666\" fill=\"none\" stroke-width=\"2\" marker-end=\"url(#arrow)\"/>\n<text x=\"170\" y=\"45\" font-size=\"11\" fill=\"#666\">← 도넛(n=1)</text>\n<text x=\"140\" y=\"95\" font-size=\"11\" fill=\"#666\">← 막대(n=2)</text>\n<text x=\"10\" y=\"25\" font-size=\"11\" fill=\"#ff5252\">생성된 정점</text>\n</svg>\n</div>\n2번 정점이 생성한 정점이고 도넛 모양 그래프 1개, 막대 모양 그래프 1개가 존재합니다. 따라서 `[2, 1, 1, 0]`을 return 해야 합니다.\n\n**입출력 예 #2**\n주어진 그래프를 그림으로 나타내면 다음과 같습니다.\n(4번 정점이 생성한 정점이고 막대 모양 그래프 1개, 8자 모양 그래프 2개가 존재합니다. 따라서 `[4, 0, 1, 2]`를 return 해야 합니다.)\n\n<svg width=\"0\" height=\"0\"><defs><marker id=\"arrow\" markerwidth=\"10\" markerheight=\"10\" refx=\"9\" refy=\"5\" orient=\"auto\"><path d=\"m0,0 l0,10 l10,5 z\" fill=\"#666\" /></marker></defs></svg>\n\n## 문제 분석\n\n이 문제에서도 겁먹어서는 안 된다. 물론 저번에 안내한 문제와는 유형이 다르지만 이것도 알고 보면 쉬운 문제에 속한다.\n정점의 수를 보면 너무 많다. 이걸 그래프 탐색 및 분석으로 생각하면 안 된다.\n네트워크에 대해서 생각해 보면서 문제를 준비해 보자.\n당신은 l3 스위치, iot 무선망 등을 모뎀 하위로 연결할 것이다.\n이 때, 모뎀이 전체 장비를 그때그때 그래프를 따라 순회하지 않는다.\n보통은 라우팅, i/o 등에 대해 테이블을 만든다.\n우리에게 필요한 것은 노드의 입출력이다. i/o 테이블을 만든 후 입력과 출력의 정보를 토대로 그래프를 구분한다.\n그래프의 특징을 가장 잘 보여 주는 노드 하나만 있으면 그래프를 체크하고 다른 노드들은 신경쓰지 않아도 된다.\n\n\n### 전체 그래프 수\n\n문제의 조건에서도 그래프들을 잇는 정점을 만들 것이라고 하였다.\n이 경우 그림들을 보면 입력이 0개, 출력이 2개 이상인 곳은 그래프들을 잘 이어준다.\n이곳이 생성해야 하는 정점 위치이고, **여기의 출력 수는 곧 하위 그래프들의 총 개수이다.**\n\n### 8자형(체인형)\n\n8자형 그래프를 보자(후술하겠지만 난 이것을 체인형이라고 부르겠다).\n고리의 가운데를 보면 고립된 형태에서 크기와 상관없이 2개의 입력과 2개의 출력이 있다.\n루트를 만들어서 체결한다면, 입력이 2개 이상의 범위로 늘 수도 있어진다. 출력은 그대로 2개이고, 입력은 2개 이상이라고 조건을 잡으면 된다.\n\n### 막대형\n\n막대형과 도넛형을 변별하려면 막대형의 끝 노드는 단일 입력만 있고 출력이 없다는 것을 알아채면 된다.\n막대형을 잡아낼 수 있는 특징적인 부분은 루트와의 체결과 관련없는 노드이다.\n입력은 1, 출력은 0이다.\n\n\n### 도넛형\n\n전체 그래프의 개수에서 체인형(8자형)과 막대형을 빼 주고 나면 도넛형 그래프만이 남는다. 도넛형은 이렇게 간접적으로 구한다.\n\n## 풀이\n```c\n#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\nint iotable[1000001][2]; // i / o, i is zero\n\n// edges_rows는 2차원 배열 edges의 행 길이, edges_cols는 2차원 배열 edges의 열 길이입니다.\nint* solution(int** edges, size_t edges_rows, size_t edges_cols) {\n    // return 값은 malloc 등 동적 할당을 사용해주세요. 할당 길이는 상황에 맞게 변경해주세요.\n    int* answer = (int*)malloc(sizeof(int) * 4);\n    // 입출력 테이블을 0으로 채워서 불필요한 오류를 예방해 줍니다.\n    memset(iotable, 0, sizeof(iotable));\n    for(int i = 0; i < edges_rows; i++) {\n        /* 예를 들어, 3 2가 현재 분석하는 경로라고 합시다.     * \n         * 이 때에, 3->2로 해석됩니다.                     *\n         * 3은 나가는 경로 한 개를 가지고,                  *\n         * 2는 들어오는 경로 한 개를 가집니다.               *\n         * 그렇다면 3에 output이 있음을 기록                *\n         * 그리고는 2에  input이 있음을 기록                *\n         * 이후 그래프를 직접 분석하지 않고                  *\n         * 이 가공된 i/o 결과만을 가지고 진행합니다.          *\n         * 라우터, 스위치 등의 포트에 인터넷 선을 체결한다고    *\n         * 생각하고 접근해 주세요.                         */\n        iotable[edges[i][1]][0]++;\n        iotable[edges[i][0]][1]++;\n    }\n    \n    int full_graph = 0;\n    int chain      = 0; // eight이라는 변수명은 너무 일반적입니다. 체인 모양이니 이렇게 쓰도록 하겠습니다.\n    int stick      = 0;\n    int doughnut   = 0;  // full_graph - stick - chain == doughnut\n    int root       = 0;\n    \n    \n    for(int i = 1; i < 1000001; i++) {\n        if(iotable[i][0] == iotable[i][1] && iotable[i][0] == 0) continue;\n        // break를 하면 안 됩니다. memset으로 0이 채워진 플레이스홀더가 아닌 중간에 흐름이 끊기는 부분이 그래프에 없다고 보장할 수 없습니다. 이건 비유하자면 전원은 켜져 있는데 내부 네트워크 어디에도 체결되지 않은 스위칭 허브입니다.\n        if (iotable[i][0] == 0) {\n            full_graph = iotable[i][1] >= 2 ?\n                         iotable[i][1]      :\n                         full_graph         ; // 나가는 것 없이 들어오는 것만 있다는 것은 이것이 우리가 i/o만 기록하면서 드러난, 이 자리에 정점을 찍으면 그래프가 연결되는 자리입니다. 비유하자면 모뎀입니다. 그리고 체인, 막대형 등의 기존 그래프를 백본에 체결된 l3 스위치, iot 무선망 등의 하위 네트워크라고 생각해 주세요.\n            root       = iotable[i][1] >= 2 ?\n                         i                  :\n                         root               ;\n            // 조건이 겹칩니다. 이 부분은 필요하시다면 if문으로 치환하셔도 됩니다.\n            // 저는 이 부분은 삼항의 가독성이 낫다고 생각했습니다.\n        } else if ((iotable[i][0] >= 2)\n                && (iotable[i][1] == 2)) {\n            chain++; // 체인형의 가운데 부분은 매우 특이하게도 정점이 늘어도 input이 항상 2 이상, output이 항상 2입니다. 고립된 8자 모양 그래프를 한 번 봐 주세요. 아직 root에 연결하지 않은 상태의 기본값이 i == 2, o == 2입니다. 그렇다면 늘어나는 것은 input입니다. o는 그대로 2입니다.\n        } else if (iotable[i][1]  == 0) {\n            stick++; // 도넛과 막대형은 구분하기 어렵지만 막대형은 명시적으로 output이 0인 지점이 존재합니다. 막대형의 꼬리를 보면 막대형인지 아닌지 구분 가능합니다.\n        } else {\n            continue;\n        }\n    }\n    \n    doughnut = full_graph - chain - stick;  // 도넛은 분기문으로 특징을 가려내기 어렵습니다. 아까 비유한 대로, root에서 구한 full_graph는 하위 네트워크가 몇 개가 있는지 알 수 있는 셈입니다. 그 중에 체인형과 막대형을 제거하면 도넛형만이 남습니다.\n    \n    answer[0] = root      ;\n    answer[1] = doughnut  ;\n    answer[2] = stick     ;\n    answer[3] = chain     ;\n    \n    return answer;\n}\n```\n\n## 결론\n\n이와 같이 그래프 문제는 네트워크 시간을 떠올리면 쉽게 풀 수 있는 경우가 존재한다.\n따라서 ne/인프라 직군을 지원하려는 사람들에게 이런 실무를 연상하게 하는 문제를 1번 내지 2번 문제로 출제할 가능성이 매우 높다.\n이러한 문제를 쏙쏙 잘 발라 먹어야 엘리트가 아니고, 특줄나게 유능하지 않은 우리와 같은 사람들이 조금이나마 기회를 잡을 수 있다.\n블루스 작품에서의 비유를 가져오자면, \"저 자정 특급 기차가 내게 빛을 주기를\"처럼, 사면 기회가 생기는 셈이다.\n\n어떤 코딩 테스트 문제는 고도의 수학 능력을 요구한다.\n나처럼 서울 상위권 대학 출신의 엘리트가 아니거나 머리가 나쁜 사람들이 풀 수 있는 문제는 비교적 제한적이다.\n이러한 어려운 척 하지만 거저 주는 문제들을 잘 맞춰야 후반부의 실수를 만회할 수 있다.\n잘 참고하고 충분히 연습해 가야 한다.\n"
    },
    {
      "title": "[다이내믹] 내려가기-백준-2096번",
      "subtitle": "동적 프로그래밍을 활용한 최적화 문제 풀이",
      "description": null,
      "url": "/codingtest/2026-01-15-[다이내믹]-내려가기-백준-2096번/",
      "collection": "codingtest",
      "relative_path": "2026-01-15-[다이내믹]-내려가기-백준-2096번",
      "date": "2026-01-15T16:22:00+09:00",
      "updated": null,
      "keywords": [
        "동적 프로그래밍",
        "DP",
        "백준",
        "알고리즘",
        "최적화"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-dp",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "[다이내믹]-내려가기-백준-2096번 자원 제약 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 4 MB (하단 참고) 60,722 23,501 18,460 36.863% 문제 N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이…",
      "search_text": "[다이내믹] 내려가기-백준-2096번 동적 프로그래밍을 활용한 최적화 문제 풀이 동적 프로그래밍 dp 백준 알고리즘 최적화 codingtest codingtest algorithm-dp [다이내믹]-내려가기-백준-2096번 자원 제약 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 4 mb (하단 참고) 60,722 23,501 18,460 36.863% 문제 n줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다. 먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이… \n\n# [다이내믹]-내려가기-백준-2096번\n\n## 자원 제약\n\n<table>\n  <thead>\n    <tr>\n      <th>시간 제한</th>\n      <th>메모리 제한</th>\n      <th>제출</th>\n      <th>정답</th>\n      <th>맞힌 사람</th>\n      <th>정답 비율</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1 초</td>\n      <td>4 mb (하단 참고)</td>\n      <td>60,722</td>\n      <td>23,501</td>\n      <td>18,460</td>\n      <td>36.863%</td>\n    </tr>\n  </tbody>\n</table>\n\n## 문제\n\nn줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.\n\n먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.\n\n<div>\n  <table>\n    <tr>\n      <td><span>*</span></td>\n      <td></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n      <td><span style=\"color: #ef4444; font-weight: bold;\">x</span></td>\n    </tr>\n  </table>\n\n  <table>\n    <tr>\n      <td></td>\n      <td><span>*</span></td>\n      <td></td>\n    </tr>\n    <tr>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n    </tr>\n  </table>\n\n  <table>\n    <tr>\n      <td></td>\n      <td></td>\n      <td><span>*</span></td>\n    </tr>\n    <tr>\n      <td><span style=\"color: #ef4444; font-weight: bold;\">x</span></td>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n      <td><span style=\"color: #3b82f6; font-weight: bold;\">o</span></td>\n    </tr>\n  </table>\n</div>\n\n---\n\n별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.\n\n## 입력\n\n첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.\n\n## 출력\n\n\n\n첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.\n\n## 예제 입력 1\n\n```text\n3\n1 2 3\n4 5 6\n4 9 0\n```\n\n### 예제 출력 1\n\n```text\n18 6\n```\n\n## 예제 입력 2\n\n```text\n3\n0 0 0\n0 0 0\n0 0 0\n```\n\n### 예제 출력 2\n\n```text\n0 0\n```\n\n## 풀이\n\n문제에 주어진 그림을 통해서 `abs(k - j) <= 1` 이라는 이동 규칙을 찾아내는 것이 가장 어렵다.\n일단 되는 것과 안 되는 것을 비교해 보자. 안 되는 것부터 확인하는 것이 문제의 성패를 가른다. 실패 케이스부터 보자.\n\n## 안 되는 것\n```python\nabs(0 - 2) == 2\nabs(2 - 0) == 2\n```\n\n## 되는 것\n\n```\nabs(0 - 0) == 0\nabs(0 - 1) == 1\nabs(2 - 2) == 0\nabs(2 - 1) == 1\nabs(1 - 2) == 1\nabs(1 - 1) == 0\nabs(1 - 0) == 1\n```\n\n되는 것은 모두 절댓값이 1 이하이다.\n\n물론 조건 상 `abs(k - j) >= -1 and abs(k - j) && 1`도 상관없으나 코드 상 절댓값이 더 짧고, 어차피 음수로나 양수로나 0을 기점으로 대칭적으로 비교 범위가 있으니 그냥 절댓값 씌우자.\n\n이 문제의 n을 보면 최대 100000이고, 파이썬에선 최소 한 자릿수 숫자당 28바이트 이상을 쓴다.\n\n1.정수 객체 소모량: 300,000(개)×28(bytes)=8,400,000(bytes)\n\n2.리스트 내 포인터 소모량: 300,000(개)×8(bytes)=2,400,000(bytes)\n\n3.행 리스트 객체 오버헤드: 100,000(행)×64(bytes)=6,400,000(bytes)\n\n4.리스트 1세트 합계 (1+2+3): 17,200,000(bytes)≈16.4(mib)\n\n5.전체 리스트 3세트 (board, max, min): 17,200,000×3=51,600,000(bytes)≈49.2(mib)\n\n6.최종 합산 (5 + 파이썬 런타임 및 입력 버퍼): 51.6(mb)+7.5(mb)=59.1(mb)≈59,144(kb)\n\n###  틀린 코드 \n\n```python\ndef find_max_scores_via_dp(board):\n    startpoint = len(board) - 1\n    for i in range(startpoint, 0, -1):  # must reach i=1 to update row 0\n        prev_row = board[i-1][:]        # snapshot to avoid in-place contamination\n        next_row = board[i]             # row below (already dp-ed)\n\n        for k in range(3):\n            best = -10**18\n            for j in range(3):\n                if abs(k - j) <= 1: # should find move rules from a picture\n                    best = max(best, prev_row[k] + next_row[j])\n            board[i-1][k] = best\n    return max(board[0])\n\ndef find_min_scores_via_dp(board):\n    startpoint = len(board) - 1\n    for i in range(startpoint, 0, -1):  # must reach i=1 to update row 0\n        prev_row = board[i-1][:]        # snapshot to avoid in-place contamination\n        next_row = board[i]\n\n        for k in range(3):\n            best = 10**18\n            for j in range(3):\n                if abs(k - j) <= 1:\n                    best = min(best, prev_row[k] + next_row[j])\n            board[i-1][k] = best\n    return min(board[0])\n\ndef main():\n    board = []\n    rows = int(input())\n    for _ in range(rows):\n        a, b, c = map(int, input().split())\n        board.append([a, b, c])\n\n    # max/min must not share the same mutated board\n    board_for_max = [row[:] for row in board]\n    board_for_min = [row[:] for row in board]\n\n    print(find_max_scores_via_dp(board_for_max), end=\" \")\n    print(find_min_scores_via_dp(board_for_min), end=\"\")\n\nmain()\n```\n나름 dp 배열이 더러워지지 않게 하기 위한 안전장치도 넣었음에도 실패하였다.\n\n```bash\nyjlee@elegant:~/2096$ /usr/bin/time -v python3 wrong.py  < input.txt\n668205 231458   command being timed: \"python3 wrong.py\"\n        user time (seconds): 0.25\n        system time (seconds): 0.03\n        percent of cpu this job got: 98%\n        elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.28\n        average shared text size (kbytes): 0\n        average unshared data size (kbytes): 0\n        average stack size (kbytes): 0\n        average total size (kbytes): 0\n        maximum resident set size (kbytes): 59144\n        average resident set size (kbytes): 0\n        major (requiring i/o) page faults: 0\n        minor (reclaiming a frame) page faults: 13336\n        voluntary context switches: 1\n        involuntary context switches: 19\n        swaps: 0\n        file system inputs: 0\n        file system outputs: 0\n        socket messages sent: 0\n        socket messages received: 0\n        signals delivered: 0\n        page size (bytes): 4096\n        exit status: 0\n```\n실제로 확인된 결과를 보면 문제의 조건인 4mb에서 파이썬 특혜로 10mb정도 줘도 ps용으론 턱없이 모자람을 알 수 있다.\n\n여기서 우리는 영리하게 접근해야 한다.\n\n당장의 dp를 위해서 우리가 필요한 것은 **모든 것이 합류할 첫 줄의 상태**와 **대상이 될 줄의 상태**이다.\n\n이것을 유지하기 위해서 구조를 냉정히 쪼개 보자.\n\n- 첫번째 줄을 받는다.\n- 다음 줄을 받아서 최대를 찾아서, 둘째 줄과 더할 시 최대, 최소가 되는 수만 min이나 max로 집어서 각각의 dp배열에 집어넣는다.\n- 업데이트된 dp배열에 세번째 줄이 들어와도 최대와 최소가 갱신된다.\n- 끝줄까지 반복한다.\n\n\n이러면 결과적으로 이 dp는 가장 큰 값과 가장 작은 값만 가지게 된다.\n### 맞힌 코드\n```python\nimport sys\ndef main():\n    input = sys.stdin.readline\n    n = int(input().strip())\n\n    row = list(map(int, input().split()))\n    max_dp = row[:]\n    min_dp = row[:]\n\n    for _ in range(n - 1):\n        row = list(map(int, input().split()))\n        prev_max = max_dp\n        prev_min = min_dp\n\n        max_dp = [0, 0, 0]\n        min_dp = [0, 0, 0]\n\n        for k in range(3):\n            best_max = -10**18\n            best_min = 10**18\n            for j in range(3):\n                if abs(k - j) <= 1:\n                    best_max = max(best_max, prev_max[j])\n                    best_min = min(best_min, prev_min[j])\n            max_dp[k] = row[k] + best_max\n            min_dp[k] = row[k] + best_min\n\n    print(max(max_dp), min(min_dp))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n-(10^18)이나 10^18은 극단적인 값이기 때문에 문제의 입력 범위 안에서는 항상 저 값으로 떨어지지 않기 때문에 min, max를 저장하기 위한 변수들을 그러한 값으로 설정한다.\n\n이렇게 한 줄씩 고려하고 계산하면 9개의 수 안에서 4개 정도의 추가 정수만 사용해서 게임이 끝난 후의 값을 가지게 된다.\n보드의 끝에서 단순히 최대 최소를 찾아도 3개 뿐이므로 연산 비용이 낮다.\n그러니 min, max만 걸면 된다.\n\n이렇게 해서 `/usr/bin/time`으로 다시 재 보자.\n\n```bash\n        command being timed: \"python3 right.py\"\n        user time (seconds): 0.12\n        system time (seconds): 0.00\n        percent of cpu this job got: 100%\n        elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.12\n        average shared text size (kbytes): 0\n        average unshared data size (kbytes): 0\n        average stack size (kbytes): 0\n        average total size (kbytes): 0\n        maximum resident set size (kbytes): 9488\n        average resident set size (kbytes): 0\n        major (requiring i/o) page faults: 0\n        minor (reclaiming a frame) page faults: 925\n        voluntary context switches: 1\n        involuntary context switches: 4\n        swaps: 0\n        file system inputs: 0\n        file system outputs: 0\n        socket messages sent: 0\n        socket messages received: 0\n        signals delivered: 0\n        page size (bytes): 4096\n        exit status: 0\n```\n\n메모리 사용량이 9.4mb로 급감했다. 이 정도면 웬만한 ps사이트에선 통과한다.\n\n## 풀이에 대해 생각해 볼 것\n\nn이 큰 dp문제 중 게임판이나 지도가 제시되는 것은 탐색과 헷갈리기 좋다.\n이러한 것의 규칙을 찾아내는 것 역시 쉽지 않다.\n\n이러한 문제를 잘 찾아내기 위해서는 반복적으로 푸는 것 이상의 문제 해체가 필요하다.\n다음에는 이 문제를 해체 및 재조립해서, 3개가 아닌 5개를 위해 탐색하는 문제를 만들어 풀어 보도록 하겠다.\n"
    },
    {
      "title": "[정렬][그리디] 보석 도둑-백준-1202번",
      "subtitle": "정렬과 그리디 알고리즘을 활용한 최적화 문제",
      "description": null,
      "url": "/codingtest/2026-01-16-[정렬][그리디]-보석-도둑-백준-1202번/",
      "collection": "codingtest",
      "relative_path": "2026-01-16-[정렬][그리디]-보석-도둑-백준-1202번",
      "date": "2026-01-15T16:22:00+09:00",
      "updated": null,
      "keywords": [
        "정렬",
        "그리디",
        "우선순위 큐",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-greedy",
        "order": 1
      },
      "difficulty": "advanced",
      "excerpt": "--- 백준 1202번: 보석 도둑 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 MB 99,086 25,606 17,748 23.944% 문제 세계적인 도둑 상덕이는 보석점을 털기로 결심했다. 상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다. 상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그…",
      "search_text": "[정렬][그리디] 보석 도둑-백준-1202번 정렬과 그리디 알고리즘을 활용한 최적화 문제 정렬 그리디 우선순위 큐 백준 알고리즘 codingtest codingtest algorithm-greedy --- 백준 1202번: 보석 도둑 시간 제한 메모리 제한 제출 정답 맞힌 사람 정답 비율 1 초 256 mb 99,086 25,606 17,748 23.944% 문제 세계적인 도둑 상덕이는 보석점을 털기로 결심했다. 상덕이가 털 보석점에는 보석이 총 n개 있다. 각 보석은 무게 mi와 가격 vi를 가지고 있다. 상덕이는 가방을 k개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다. 상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그… \n\n\n---\n\n\n# 백준 1202번: 보석 도둑\n\n<div>\n  <table>\n    <thead>\n      <tr>\n        <th>시간 제한</th>\n        <th>메모리 제한</th>\n        <th>제출</th>\n        <th>정답</th>\n        <th>맞힌 사람</th>\n        <th>정답 비율</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>1 초</td>\n        <td>256 mb</td>\n        <td>99,086</td>\n        <td>25,606</td>\n        <td>17,748</td>\n        <td>23.944%</td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n## 문제\n\n세계적인 도둑 상덕이는 보석점을 털기로 결심했다.\n\n상덕이가 털 보석점에는 보석이 총 n개 있다. 각 보석은 무게 mi와 가격 vi를 가지고 있다. 상덕이는 가방을 k개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.\n\n상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.\n\n\n## 입력\n\n첫째 줄에 n과 k가 주어진다. (1 ≤ n, k ≤ 300,000)\n\n다음 n개 줄에는 각 보석의 정보 mi와 vi가 주어진다. (0 ≤ mi, vi ≤ 1,000,000)\n\n다음 k개 줄에는 가방에 담을 수 있는 최대 무게 ci가 주어진다. (1 ≤ ci ≤ 100,000,000)\n\n모든 숫자는 양의 정수이다.\n\n## 출력\n\n첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.\n\n## 예제 입력 1\n\n```text\n2 1\n5 10\n100 100\n11\n```\n\n### 예제 출력 1\n\n```text\n10\n```\n\n## 예제 입력 2\n\n```text\n3 2\n1 65\n5 23\n2 99\n10\n2\n```\n\n### 예제 출력 2\n\n```text\n164\n```\n\n## 풀이(아주 간단)\n\n우선 생각해야 할 것이, 이것은 절대로 냅색(knapsack) 알고리즘같은 것이 아니다.\n가방 문제 하면 가장 유명한 냅색 알고리즘이 튀어 나올 수 있지만, 제약 조건을 자세히 살피면 가방에는 단 한 개의 보석만을 넣을 수 있다.\n\n말만 들으면 냅색+제약에 맞는 구현 쪽인 난이도 높은 문제같지만, 이 문제를 풀 때만큼은 중고등학교 때 처음 코딩을 배울 때로 돌아가야 한다.\n\n1. 작은 가방에는 작은 돌이 들어간다.\n2. 작은 돌들 중 가장 비싼 것을 가져가야 돈을 많이 벌 수 있다.\n3. 말 그대로 정렬을 하자.\n3. 오름차순이면 가방 안에 들어가는 돌들을 반복문으로 추리고 그 중 가장 큰 것을 찾자. 수익에 가격표 반영.\n  3.1. 넣은 돌 다음으로 비싼 돌은 다음 차례 가방에 들어가면서도 들어갈 수 있는 돌일지도 모른다. 오름차순이니 크기 문제는 좀 더 느슨하게 생각해도 되니 남은 돌들은 일단 남겨 놓자.\n4. 다음 돌로 남은 돌 목록을 그대로 재활용해서 다시 3번 단계로 돌아간다.\n\n우선순위 큐, 정렬, 그리고 보이는대로 쑤셔넣기, 이것이 전부이다.\n그리디의 느낌은 분명 있지만, 가장 무식하게 그리디의 기초를 익힐 수 있는 방법이며,\n우선순위 큐를 중점적으로 쓴다기보단 그냥 그때그때 정렬 돌리면 자원 낭비라서 \"정렬된 상태\"를 유지하기 위한 방법이다. 내가 이것을 우선순위 큐 문제로 분류하지 않은 것도 이런 맥락이라고 보면 된다.\n\n### 주의할 점\n\n- 우선순위 큐가 비었을 때 `pop();`을 돌리면 그냥 죽는다. c++의 상대적으로 오래된 기능인 stl 라이브러리는 이러한 방어를 사용자의 책임으로 위임한다. 설계 철학을 따라서 `if(!pq.empty())`같은 것을 잘 하는 것은 c++ 개발자의 소양 중 하나다.\n- `int` 범위에서 계속 큰 수를 더할 수 있다는 게 문제 제약조건에서 암시되어 있다. 서서히 자료형을 늘려보자. 나의 경우에는 `long int`로 통과되었으며, 많은 코딩 테스트 플랫폼은 `64-bit, linux 4.x - 6.x, lp64, glibc 2.x` 환경이다. 이러한 g환경에서 `long int`는 내부적으로 `int64_t`이기 때문에 통과된다.\n  - (추가 팁) *(보통 나의 경우 이런 음수 없는 문제들에선 `int -> unsigned int -> long int-> unsigned long int -> long long -> unsigned long long` 순으로 따라간다. 이 문제의 경우 windows enterprise server + msvc 및 llp64 시스템 종류에서는 long long이 64-bit integer이다.)*\n- 보석더미를 처음부터 뒤지면 안 된다.\n  - i를 그때그때 뒤진다 하면 i가 이미 전단계에서 나아가면서 우선순위 큐에 집어 넣은 것들이다.\n    - 이미 들어간 것을 다시 넣는 중복 삽입은 메모리 낭비이다.\n  - 실제 구현 시 바뀌지 않는다는 것을 강조하려면 for문 밖에 이터레이터를, 권장되지 않으나 굳이 for문에서 사용한다는 것을 강조하려면 for문 안에 `static int`를 두면 누적해서 이터레이터가 전진한다.\n  - **이렇게 중간부터 보석을 뒤지는 방안을 활용하지 않은 풀이들은 사실상 통과하지 못한다.**\n- 우리가 알고 싶은 것은 보석의 가격 합이지, 무게 합이 아니다. 우선순위 큐에는 **가격만 넣어도 된다**.\n  - 이렇게 하면 두 개의 정수 쌍을 다 넣는 것보다 절반 정도의 메모리를 차지한다.\n\n\n## 풀이 코드\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> int_pair_t;\n\nint main() {\n\n  vector<int_pair_t> jewels; \n  vector<int>        bags;\n  int n, k;\n  cin >> n >> k;\n  for(int i = 0; i < n; i++) {\n    int weight, price;\n    cin >> weight >> price;\n    int_pair_t p = make_pair(weight, price); // tie the weight and price as a pair\n    jewels.push_back(p);\n  }\n  for(int i = 0; i < k; i++) {\n    int b;\n    cin >> b;\n    bags.push_back(b);\n  }\n\n  sort(bags.begin(), bags.end());     //sort, ascending\n  sort(jewels.begin(), jewels.end()); // ..\n\n  long int stolen_jewels_value = 0; // we only need sum of values\n\n  priority_queue<int, vector<int>, less<int>> pq;\n  int i = 0;\n  for(auto b: bags) {\n    for(;i < (int)jewels.size() && jewels[i].first <= b; i++) { // do not fully seek in every iteration\n      pq.push(jewels[i].second);\n    }\n\n    if(!pq.empty()) {\n      int jewel = pq.top();\n      stolen_jewels_value += jewel;\n      pq.pop();\n    }\n  }\n\n  cout << stolen_jewels_value;\n  return 0;\n}\n```\n\n\n원리를 알고 나면 어렵지 않은 풀이지만, 원리를 알기 전에는 굉장히 어려워 보인다.\n이러한 점을 유념해야 실전에서 더듬지 않을 수 있다.\n\n오륜서의 저자이자 병법가였던 미야모토 무사시의 나온 어투로 글을 맺어 보고 싶다.\n\n*원리가 손에 자연히 익혀질 때까지 반복적으로 훈련하지 않으면 안 된다. 이후는 구전한다.*\n\n\n## 결론\n\n이 문제의 본질은 어떻게 정렬하고, 어떻게 최대를 찾고, 어떻게 지우는지를 정렬과 우선순위 큐로 어떻게 해낼지를 짚는다. 이론적으로는 그리디 매칭 문제라고 부르지만, 나는 편의 상의 문제로 전문 용어 없이 정렬과 그리디를 어떻게 섞어내는 문제인지로 말하겠다.\n\n이러한 풀이는 겉으로 보기에는 무서운 기세이지만 막상 그 속을 파고들면 어린아이도 풀 수 있는 유형이다.\n코딩 테스트에서 나온다면 겁주기를 위한 문제일 수도 있고, 그것보다는 더 유형을 복잡하게 낼 수도 있다.\n\n이 유형은 복잡한 그리디도 어려운 정렬 구현도 요구하지 않는다. \"mi, vi, 보석점\"같이 난이도를 착각하게 만드는 갑옷 사이의 빈틈을 잘 노려 벗겨내면 사실은 부드러운 속살이 드러나는, 대게와 같은 문제이다. 유형을 반복 숙달하고, 내가 보석을 단순한 돌로 언급했듯 불필요하게 장식적인 말들을 걷어내어 문제를 분석해야 한다. 이런 문제를 잘 발라 먹으면 변별력 문제를 틀릴 때의 실점을 만회할 기반을 다질 수 있다.\n\n구전한다고 말했듯이, 이러한 유형의 문제를 블로그에서 집중적으로 다뤄볼 것이다. 이 과정을 잘 따라온다면 여러분도 알고리즘의 기초에 대해 공부할 수 있을 것이다.\n"
    },
    {
      "title": "Network Basics - How to Tune BBRv3",
      "subtitle": "TCP BBRv3 Congestion Control Tuning Guide",
      "description": null,
      "url": "/network/2026-01-15-Network-Basics-How-to-tune-BBRv3",
      "collection": "network",
      "relative_path": "2026-01-15-Network-Basics-How-to-tune-BBRv3",
      "date": "2026-01-15T12:30:00+09:00",
      "updated": null,
      "keywords": [
        "BBRv3",
        "TCP Congestion Control",
        "Algorithm Tuning",
        "Network Optimization",
        "BBR",
        "Kernel",
        "Performance",
        "Linux",
        "Latency",
        "Optimization"
      ],
      "categories": [
        "network"
      ],
      "taxonomy": {
        "category": "network",
        "subcategory": "network-protocol",
        "order": 2
      },
      "difficulty": "advanced",
      "excerpt": "Tuning the standard algorithm: Holy Grail shouldn't hold Coca-Cola Tuning the standard algorithm may sound dangerous and intriguing at the same time. As many sophisticated researchers have cross-checked the benefits of algorithms, some might think this is too controversial. But y…",
      "search_text": "network basics - how to tune bbrv3 tcp bbrv3 congestion control tuning guide bbrv3 tcp congestion control algorithm tuning network optimization bbr kernel performance linux latency optimization network network network-protocol tuning the standard algorithm: holy grail shouldn't hold coca-cola tuning the standard algorithm may sound dangerous and intriguing at the same time. as many sophisticated researchers have cross-checked the benefits of algorithms, some might think this is too controversial. but y… \n\n# tuning the standard algorithm: holy grail shouldn't hold coca-cola\n\ntuning the standard algorithm may sound dangerous and intriguing at the same time.\nas many sophisticated researchers have cross-checked the benefits of algorithms, some might think this is too controversial.\nbut you can compare these two: a latte mug and, yes--the holy grail.\n\nfirst, what is the benefit of a *latte mug*?\n\nthis is made under the shade of **modern industry**, which means it can perform well with any kind of soda.\nhowever, it cannot symbolize divinity on its own, nor can it bless someone who owns it.\n\nhow about the holy grail?\n\nthis was made when st. peter was still alive, which means it can be damaged by coca-cola.\nhowever, the holy grail can symbolize the sacrifice of jesus, and it can bless somebody who is sincere.\n\nthis is the difference in prestige.\n\nthen, let's think about standard bbrv3 and a tuned one.\n\nthe standard one is a latte mug.\nit can hold any sort of beverage, but it is hard to use when celebrating mass.\n\nthe tuned one is an imitation of the holy grail.\nif we define the holy grail as \"a flawless algorithm for specific problems,\" then this is an imitation of it.\nthis means it is good enough to hold wine and bread.\n\n## let's think about bbrv3: balance & options\n\nsimply, bbrv3 aims for **harmony**.\nthis means it will not aggressively scale its transmission rate only for itself.\n\n<img src=\"/assets/images/bbrv3_overview.png\" style=\"width: 70%; height: auto;\" alt=\"bbrv3's big picture\">\n\n### balance\n\nas you can see in the picture, the pacing engine controls the transmission pace using calculated metrics from the probing state machine.\nthis means the pacing engine will behave consistently based on the given metrics.\nif you are running a kubernetes cluster with this congestion control logic, this is ideal.\n\n### options\n\nhowever, if you are maintaining real-time game servers that must guarantee ha (high availability), there are some good points to tune.\n\nbbrv3 is still prone to sudden metric changes, although many experiments prove that it is much improved compared to legacy algorithms (like cubic or vegas), especially in worse cases.\n\ni will explain this with a friendly example: cars.\n\nbbrv3 is just like an f1 racing car from ferrari.\nit has a strong accelerator pedal and a brake pedal, but it will not provide intelligent deceleration for you.\nso, if you are driving this car on a track, it is the best fit.\nbut what would happen if you drive this car in rush-hour traffic in seoul?\nyou will have trouble controlling it.\n\nthen you will need intelligent features like ai deceleration, which are commonly found in modern sedans.\n\n### plan\n\nas a result, we can build a plan based on this metaphor.\n\n1. reduce cwnd (congestion window) when metrics get too bad.\n2. make a custom metric with previous bandwidth records.\n  2-1. use this metric to reduce pacing.\n\n## how can i implement this?\n\nsince the source of bbrv3 is simple and clear, we can easily plan how to implement it.\nwhen looking at the bit-field, there are unused bits.\nif we are planning to reduce cwnd, we need a switch bit to trigger it.\nso, we can use an additional 1 bit to mark this information.\n\n<table>\n  <thead>\n    <tr>\n      <th class=\"highlight-cell text-center\">reduce_cwnd</th>\n      <th>..</th>\n      <th>..</th>\n      <th>..</th>\n      <th>..</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>1 bit</td>\n      <td>-</td>\n      <td>-</td>\n      <td>-</td>\n      <td>-</td>\n    </tr>\n  </tbody>\n</table>\n\nalso, we must store a pacing-gain ratio to remember *how much we should reduce pacing*.\nas a result, we need a new member in `struct bbr`.\n\n```c\nstruct bbr {\n// ... other members\n    alpha_last_delivered_ce; // insert below this line!\n\tu32\tpacing_gain_extra;\n};\n```\n\nthen, we should define the thresholds to trigger `reduce_cwnd` and control pacing, which are applied inside the pacing engine.\n\n```c\n\t#define bw_delta_alpha        (bbr_unit / 2) // the ratio for limiting reduce logic: 50%. reduce 20% when throughput is 40% dropped\n\t#define bw_delta_ceiling      (bbr_unit / 4) // max pacing reduce ratio: 25%\n\t#define bw_delta_floor        (bbr_unit * 3 / 4) // when calculated pacing gain is dropped below 75%, turn on reduce_cwnd.\n```\n\nadd this to `bbr_init` to initialize the bit and variable.\n\n```c\n// ... rest of the codes are omitted...\n\t\tbbr->pacing_gain_extra = bbr_unit;\n\t\tbbr->reduce_cwnd = 0;\n// ...\n```\n\n### declaring functions (concept only)\nthis section is a conceptual sketch to explain the idea; refer to the repo commit for the actual 6.18 port.\n\nnames/fields may differ from upstream bbrv3 depending on kernel version.\n\n```c\n\tstatic void bbr_tweak_pacing_reduction(struct sock *sk, u32 sample_bw, u32 old_bw)\n\t{\n\t\tstruct bbr *bbr = inet_csk_ca(sk);\n\t\tu32 max_bw_val = bbr_max_bw(sk);\n\n\t\tif (!max_bw_val || sample_bw >= old_bw) {\n\t\t\tbbr->pacing_gain_extra = bbr_unit;\n\t\t\treturn;\n\t\t}\n\n\t\tu64 delta = ((u64)(old_bw - sample_bw) * bbr_unit) / max_bw_val;\n\t\tu64 reduction = (delta * bw_delta_alpha) >> bbr_scale;\n\n\t\tif (reduction > bw_delta_ceiling)\n\t\t\treduction = bw_delta_ceiling;\n\n\t\tbbr->pacing_gain_extra = bbr_unit - (u32)reduction;\n\t\tbbr->reduce_cwnd = 0;\n\n\t\tif (bbr->pacing_gain_extra < bw_delta_floor) {\n\t\t\tbbr->reduce_cwnd = 1;\n\t\t\tif (bbr->pacing_gain_extra < bbr_unit / 8)\n\t\t\t\tbbr->pacing_gain_extra = bbr_unit / 8;\n\t\t}\n\t}\n```\n\nfirst, this calculates whether to slow down or not.\n\nand apply this to `bbr_main`:\n\n```c\n// ... rest of the codes are omitted...\n\t\tif (rs->interval_us > 0 && rs->acked_sacked > 0) {\n\t\t\tif (!rs->is_app_limited || ctx.sample_bw >= bbr_max_bw(sk))\n\t\t\t\tbbr->bw_hi[1] = max(bbr->bw_hi[1], ctx.sample_bw);\n\n\t\t\tbbr_tweak_pacing_reduction(sk, ctx.sample_bw, old_bw); // this line has inserted to adjust pacing rate metric\n\n\t\t\tif (bbr->round_start) {\n\t\t\t\tbbr->bw_hi[0] = bbr->bw_hi[1];\n\t\t\t\tbbr->bw_hi[1] = 0;\n\t\t\t}\n\t\t}\n// ...\n```\n\nadd this to `bbr_set_cwnd`:\n\n```c\n// ... rest of the codes are omitted...\n\tif (!acked) goto done; // insert below this line\n\tif (bbr->reduce_cwnd) {\n\t\tcwnd = max_t(s32, cwnd - acked, 1);\n\t\tbbr->reduce_cwnd = 0;\n\t}\n// ...\n```\n## materials\n\na router is 100m full-duplex router (ssamji electronics, p405n), and 1000m full-duplex router(iptime be3600qca) on 500m full duplex wan.\nbbrv3 baseline commit hash is `90210de4b779d40496dee0b89081780eeddf2a60`.\nthe modified algorithm was ported from the base commit to linux 6.18(6.18.0 based, released as mountain kernel v0.3) and published at `https://github.com/gg582/linux-mountain` commit `c62bcddd7a829dec76ae2ef52b540cb86073e9c5`. the relevant sources are `net/ipv4/tcp_bbr3.c` and `net/ipv4/tcp_bbr3vanilla.c`.\nqdisc was forced to fq.\nsimple cpu load tool's code is uploaded with test scripts.\ntest scripts are at mountain_kernel_ping_test(commit hash `1b5950c7125b156b4adc66757487b1e807df6b79`).\n\nfor ping measurements, cpu load was forced to 100 percent while running the tests.\nfor iperf3 measurements, i kept my base cpu load to 1%-5%.\ni used two scripts: one is a public iperf3 cc switch benchmark that fixes a single best server for the whole session and runs forward and reverse iperf3 while pinging during load, and the other is the original ping-test template that runs long local and wan pings and optionally iperf3 and turbostat.\n\n### fairness and measurement rationale\n\nthis post compares two congestion control implementations under two different experimental goals:\n\n* **ping tests (bufferbloat / tail latency focus):** cpu load was intentionally forced to 100% to emulate a worst-case host contention scenario. the goal was to stress queueing and scheduling interactions that typically amplify rtt jitter under load, and to observe whether the modified logic reduces tail latency behavior in that environment.\n\n* **iperf3 tests (throughput / retransmission focus):** baseline cpu load was kept low (about 1% to 5%) to avoid turning the experiment into a cpu-bound benchmark. if the sender/receiver becomes cpu-limited, differences between congestion control algorithms can be masked or distorted by user-space overhead and scheduling artifacts rather than network control behavior.\n\n* same host hardware and os userspace for both kernels (only the cc implementation differed).\n* same nic, link, and physical path (same switch/router/cabling).\n* same queueing discipline: fq forced on the measured interface.\n* same baseline sysctls (tcp_ecn, tcp_timestamps, tcp_sack) and routing configuration.\n* same ping targets, sample size (n=1000), and ping interval/timeout settings.\n* same iperf3 parameters (duration, parallel streams, forward/reverse), with one server fixed per session after initial selection.\n* for the server-fixed iperf3 session, i only considered candidates that connected successfully without any transient failures, and then picked one of those stable candidates for the session.\n\n---\n* not fully controlled / known limitations (script-driven best effort):\n  * nic offload and low-level nic features were not explicitly toggled or verified (ethtool unavailable in this environment), so gso/gro/tso/lro behavior may differ from other hosts.\n  * cpu frequency scaling / governor, irq steering (irqbalance), and rps/xps settings were not pinned. under high load, these can affect rtt jitter via scheduling/interrupt locality, independent of cc logic.\n  * path variability outside the host was not controllable for wan tests (isp queueing, cross-traffic, upstream shaping, time-of-day effects). for wan, results should be read as \"under my path at that time\", not as a universal claim.\n  * iperf3 server-side load and policy are external variables. even with a fixed server per session, remote contention or rate limiting can influence throughput/retransmissions.\n\n* repetition and reporting policy:\n  * ping tests: each target was measured with n=1000 icmp samples per run. (if multiple runs were executed, the raw logs are preserved; the table values are taken from a single representative run unless otherwise stated.)\n  * iperf3 tests: forward and reverse runs were executed per cc setting in the same session, using identical duration/parallel parameters. retries were enabled to avoid aborting on transient server busy conditions.\n\n* server selection fairness (iperf3):\n  * the server was selected once at the beginning of the session and fixed for the entire cc sequence.\n  * during selection, i only considered candidates that connected successfully without transient failures (no immediate connect errors/timeouts), then chose one of those stable candidates (best rtt among them) for the session.\n\n* about the reverse table (why no extra analysis here):\n  * i will attach a reverse-direction table for completeness and reproducibility, but i will not add additional narrative analysis because reverse results are more sensitive to uncontrolled remote-side factors (server nic/cpu state, receive path scheduling, and cross-traffic near the server).\n  * in other words, the reverse table is provided as raw evidence/log-aligned data, while the conclusions in this post are intentionally based on the more controlled aspects of the experiment (host-side conditions + consistent session setup).\n\n---\n\nthe two test groups are not mixed; each is used for what it measures best. ping emphasizes latency/jitter sensitivity to queueing, while iperf3 emphasizes sustained transfer behavior (throughput and retransmissions) without an artificial cpu bottleneck.\n\n### absolute values and test conditions\n\nbelow are the concrete conditions used when producing the numbers shown in this post. these are listed to make the results reproducible and to clarify what was (and was not) controlled.\n\n### 1000m full duplex\n\n* targets:\n  * lan: ping 127.0.0.1\n      ... all same\n\n\n\n\n### 100m full duplex\n#### ping measurements (absolute values)\n\n* targets:\n\n  * lan: ping 127.0.0.1\n  * wan: ping 1.1.1.1\n* sample size: n = 1000 (per target)\n* metrics reported: avg rtt, mdev, p99, p99.9, max rtt, loss\n* host condition: cpu load forced to 100% during the ping tests\n* queueing discipline: qdisc forced to fq on the measured interface\n\n#### iperf3 measurements (absolute values)\n\n* measurement method: forward and reverse runs\n* a single server was selected once at the beginning (best rtt among reachable candidates) and fixed for the entire session\n* during each iperf3 run, ping was executed concurrently to the wan_ping_target to capture latency behavior under load\n* host condition: baseline cpu load kept low (about 1% to 5%) to reduce cpu-bound bias\n* queueing discipline: qdisc forced to fq on the measured interface\n* note: nic offload features were not explicitly toggled (ethtool unavailable)\n\n### environment\nserver environments are attached here.\n```bash\nyjlee@elegant:~$ ip -details link show dev enp5s0\n\n2: enp5s0: <broadcast,multicast,up,lower_up> mtu 1500 qdisc fq state up mode default group default qlen 1000\n    link/ether a8:a1:59:ea:cc:d7 brd ff:ff:ff:ff:ff:ff promiscuity 0 allmulti 0 minmtu 68 maxmtu 9194 addrgenmode none numtxqueues 1 numrxqueues 1 gso_max_size 64000 gso_max_segs 64 tso_max_size 64000 tso_max_segs 64 gro_max_size 65536 gso_ipv4_max_size 64000 gro_ipv4_max_size 65536 parentbus pci parentdev 0000:05:00.0\n    altname enxa8a159eaccd7\nyjlee@elegant:~$ lspci -nn | grep -i eth\n05:00.0 ethernet controller [0200]: realtek semiconductor co., ltd. rtl8111/8168/8211/8411 pci express gigabit ethernet controller [10ec:8168] (rev 15)\nroot@elegant:/home/yjlee# uname -a\ncat /etc/os-release\nsysctl net.ipv4.tcp_congestion_control\nsysctl net.core.default_qdisc\nsysctl net.ipv4.tcp_ecn\nsysctl net.ipv4.tcp_timestamps\nsysctl net.ipv4.tcp_sack\ntc -s qdisc show dev enp5s0\nip route show\nlinux elegant 6.18.0-mountain+ #6 smp preempt_dynamic tue jan 13 20:25:12 kst 2026 x86_64 gnu/linux\npretty_name=\"debian gnu/linux 13 (trixie)\"\nname=\"debian gnu/linux\"\nversion_id=\"13\"\nversion=\"13 (trixie)\"\nversion_codename=trixie\ndebian_version_full=13.2\nid=debian\nhome_url=\"https://www.debian.org/\"\nsupport_url=\"https://www.debian.org/support\"\nbug_report_url=\"https://bugs.debian.org/\"\nnet.ipv4.tcp_congestion_control = bbr3\nnet.core.default_qdisc = fq\nnet.ipv4.tcp_ecn = 2\nnet.ipv4.tcp_timestamps = 1\nnet.ipv4.tcp_sack = 1\nqdisc fq 8001: root refcnt 2 limit 10000p flow_limit 100p buckets 1024 orphan_mask 1023 bands 3 priomap 1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1 weights 589824 196608 65536 quantum 3028b initial_quantum 15140b low_rate_threshold 550kbit refill_delay 40ms timer_slack 10us horizon 10s horizon_drop offload_horizon 0us\n sent 1722142299 bytes 1492478 pkt (dropped 0, overlimits 0 requeues 0)\n backlog 0b 0p requeues 0\n  flows 66 (inactive 66 throttled 0) band0_pkts 0 band1_pkts 0 band2_pkts 0\n  gc 8 highprio 0 fastpath 427890 throttled 172135 latency 11.8us\ndefault via 192.168.168.1 dev enp5s0 proto dhcp src 192.168.168.102 metric 100\n192.168.168.0/24 dev enp5s0 proto kernel scope link src 192.168.168.102 metric 100\nroot@elegant:/home/yjlee#\n\n```\n\n\ni am embedding test scripts here to enhance accessibility.\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# public iperf3 cc switch benchmark: bbr3 -> bbr3vanilla -> bbr3\n# this script selects the best server once and fixes it for the entire session.\n# logs: iperf3 forward/reverse + ping during load (wan_ping_target)\n\n########################################\n# config (override via env vars)\n########################################\nwan_ping_target=\"${wan_ping_target:-8.8.8.8}\"\n\n# iperf3 parameters\nduration=\"${duration:-30}\"\nparallel=\"${parallel:-4}\"\nwarmup=\"${warmup:-3}\"\nmax_retries=5          # retries per direction if server is busy\nretry_delay=5         # seconds to wait between retries\n\n# ping parameters\nping_interval=\"${ping_interval:-0.2}\"\nping_timeout=\"${ping_timeout:-2}\"\n\n# cc sequence: bbr3 -> bbr3vanilla -> bbr3\ncc_seq=(\"bbr3\" \"bbr3vanilla\" \"bbr3\")\n\n# result directory\nresult_dir=\"${result_dir:-results_bbr_fixed_session}\"\nmkdir -p \"$result_dir\"\n\n########################################\n# server candidates (prioritizing kr/jp)\n########################################\nserver_candidates=(\n  \"146.56.145.150 5201 kr-oracle-seoul\"\n  \"kr.iperf.biz 5201 kr-community-node\"\n  \"iperf.idcf.jp 5201 jp-tokyo-idcf\"\n  \"speedtest.tokyo.linode.com 5201 jp-tokyo-linode\"\n#  \"speedtest.uztelecom.uz 5201 uz-tele\"\n  \"bouygues.iperf.fr 9201 fr-bytel-bbr\"\n  \"ping.online.net  5200 fr-scaleway\"\n  \"ping.online.net  5200 fr-moji\"\n)\n\n########################################\n# helpers\n########################################\nlog() { echo -e \"[$(date +'%h:%m:%s')] $1\"; }\n\nneed_cmd() {\n  command -v \"$1\" >/dev/null 2>&1 || { log \"[!] missing command: $1\"; exit 1; }\n}\n\nas_root() {\n  if [[ \"${euid:-$(id -u)}\" -ne 0 ]]; then log \"[!] please run as root\"; exit 1; fi\n}\n\nsysctlw() { sysctl -w \"$1\" >/dev/null 2>&1 || true; }\nsysctlq() { sysctl -n \"$1\" 2>/dev/null || echo \"unknown\"; }\n\ntcp_probe() {\n  local host=\"$1\" port=\"$2\"\n  timeout 2 bash -c \"cat < /dev/null > /dev/tcp/${host}/${port}\" >/dev/null 2>&1\n}\n\nping_avg_ms() {\n  local host=\"$1\"\n  local out avg\n  out=\"$(ping -c 3 -w 1 \"$host\" 2>/dev/null || true)\"\n  avg=\"$(echo \"$out\" | awk -f'/' '/rtt|round-trip/ {print $5}')\"\n  echo \"${avg:-999999}\"\n}\n\n########################################\n# server selection (fixed for the session)\n########################################\npick_and_fix_server() {\n  local best_host=\"\" best_port=\"\" best_label=\"\" best_rtt=\"999999\"\n  log \"scanning candidates to fix a server for this session...\"\n\n  for entry in \"${server_candidates[@]}\"; do\n    read -r host port label <<< \"$entry\"\n\n    if ! getent hosts \"$host\" >/dev/null 2>&1; then continue; fi\n    if ! tcp_probe \"$host\" \"$port\"; then continue; fi\n\n    local rtt\n    rtt=$(ping_avg_ms \"$host\")\n    log \"  found: $label ($host) - rtt: ${rtt}ms\"\n\n    if awk \"begin{exit !($rtt < $best_rtt)}\"; then\n      best_rtt=$rtt; best_host=$host; best_port=$port; best_label=$label\n    fi\n  done\n\n  if [[ -z \"$best_host\" ]]; then\n    log \"error: no reachable servers found.\"\n    exit 1\n  fi\n\n  fixed_host=$best_host\n  fixed_port=$best_port\n  fixed_label=$best_label\n  log \"==> server fixed: $fixed_label ($fixed_host:$fixed_port)\"\n}\n\n########################################\n# benchmark core with retry\n########################################\nrun_bench() {\n  local outdir=\"$1\"\n  local direction=\"$2\"\n  local attempt=1\n  local success=0\n\n  local json_flag=\"\"\n  iperf3 -h 2>&1 | grep -q -- '--json' && json_flag=\"--json\"\n\n  local ping_count\n  ping_count=\"$(awk \"begin{print int(($duration / $ping_interval) + 10))}\")\"\n\n  while [ $attempt -le $max_retries ]; do\n    log \"    -> [$direction] attempt $attempt/$max_retries\"\n\n    # background ping during load\n    ping -i \"$ping_interval\" -w \"$ping_timeout\" -c \"$ping_count\" \"$wan_ping_target\" \\\n      > \"${outdir}/ping_${direction}.log\" 2>&1 &\n    local ppid=$!\n\n    # run iperf3\n    local cmd=\"iperf3 -c $fixed_host -p $fixed_port -t $duration -p $parallel $json_flag\"\n    [[ \"$direction\" == \"reverse\" ]] && cmd=\"$cmd -r\"\n\n    set +e\n    $cmd > \"${outdir}/iperf3_${direction}.log\" 2> \"${outdir}/iperf3_${direction}.err\"\n    local rc=$?\n    set -e\n\n    wait \"$ppid\" >/dev/null 2>&1 || true\n\n    if [[ $rc -eq 0 ]]; then\n      log \"       success!\"\n      success=1; break\n    else\n      log \"       server busy or network error. waiting ${retry_delay}s...\"\n      sleep \"$retry_delay\"\n    fi\n    ((attempt++))\n  done\n\n  if [[ $success -eq 0 ]]; then\n    log \"    [!] failed $direction after $max_retries attempts.\"\n    return 1\n  fi\n}\n\n########################################\n# main execution\n########################################\nas_root\nneed_cmd ip; need_cmd ping; need_cmd iperf3; need_cmd awk; need_cmd bc\n\n# load modules\nmodprobe tcp_bbr >/dev/null 2>&1 || true\nmodprobe tcp_bbr3 >/dev/null 2>&1 || true\nmodprobe tcp_bbr3vanilla >/dev/null 2>&1 || true\n\n# interface optimization\niface=$(ip route get \"$wan_ping_target\" 2>/dev/null | awk '{for(i=1;i<=nf;i++)if($i==\"dev\"){print $(i+1);exit}}')\nif [[ -n \"$iface\" ]]; then\n  log \"setting fq qdisc on $iface\"\n  tc qdisc replace dev \"$iface\" root fq 2>/dev/null || true\nfi\n\n# 1. lock server for consistency\npick_and_fix_server\n\nts=\"$(date +%y%m%d-%h%m%s)\"\nrun_dir=\"${result_dir}/${ts}_$(uname -r | tr ' ' '_')\"\nmkdir -p \"$run_dir\"\n\n# 2. loop cc sequence\nfor cc in \"${cc_seq[@]}\"; do\n  # use sub-timestamp to avoid folder collision for repeated ccs\n  cc_dir=\"${run_dir}/${cc}_$(date +%h%m%s)\"\n  mkdir -p \"$cc_dir\"\n\n  log \"--------------------------------------------\"\n  log \"switching cc -> $cc\"\n  sysctlw \"net.ipv4.tcp_congestion_control=$cc\"\n\n  actual=$(sysctlq net.ipv4.tcp_congestion_control)\n  log \"current kernel cc: $actual\"\n\n  sleep \"$warmup\"\n\n  # forward test\n  log \"running forward (tx) test...\"\n  run_bench \"$cc_dir\" \"forward\"\n\n  # reverse test\n  log \"running reverse (rx) test...\"\n  run_bench \"$cc_dir\" \"reverse\"\ndone\n\n# reset to default\nsysctlw \"net.ipv4.tcp_congestion_control=bbr3\"\nlog \"all tests finished. results: $run_dir\"\n```\n\n```bash\n#!/usr/bin/env bash\nset -euo pipefail\n\n# ask whether this run is on vanilla kernel\nread -r -p \"vanilla? <y/n> \" ans\ncase \"$ans\" in\n    y|y) ktype=\"vanilla\" ;;\n    n|n) ktype=\"modified\" ;;\n    *) echo \"please answer y or n\" >&2; exit 1 ;;\nesac\n\n# configuration (override with environment variables if needed)\nlocal_target=\"${local_target:-192.168.168.102}\"\nwan_target=\"${wan_target:-1.1.1.1}\"\nping_count=\"${ping_count:-1000}\"\nping_interval=\"${ping_interval:-0.1}\"   # seconds between pings\nping_wait_time=\"${ping_wait_time:-5}\"\n\nresult_dir=\"${result_dir:-results_net_test}\"\nmkdir -p \"$result_dir\"\n\nts=\"$(date +%y%m%d-%h%m%s)\"\nkernel=\"$(uname -r | tr ' ' '_')\"\nprefix=\"${result_dir}/${ts}_${ktype}_${kernel}\"\n\necho \"========================================\"\necho \" kernel type      : $ktype\"\necho \" kernel version   : $kernel\"\necho \" local ping target: $local_target\"\necho \" wan ping target  : $wan_target\"\necho \" result prefix    : $prefix\"\necho \"========================================\"\necho\n\n########################################\n# 1. long local ping test\n########################################\necho \"[1/4] running long local ping test...\"\necho \"      ping -i ${ping_interval} -c ${ping_count} ${local_target}\" -w ${ping_wait_time}\nping -i \"$ping_interval\" -c \"$ping_count\" \"$local_target\" \\\n    > \"${prefix}_ping_local.log\"\necho \"      saved to ${prefix}_ping_local.log\"\necho\n\n########################################\n# 2. long wan ping test\n########################################\necho \"[2/4] running long wan ping test...\"\necho \"      ping -i ${ping_interval} -c ${ping_count} ${wan_target}\"\nping -i \"$ping_interval\" -c \"$ping_count\" \"$wan_target\" \\\n    > \"${prefix}_ping_wan.log\"\necho \"      saved to ${prefix}_ping_wan.log\"\necho\n\n########################################\n# 3. throughput test with iperf3 (optional)\n#    set iperf_target to enable, e.g.:\n#    export iperf_target=192.168.168.200\n########################################\nif command -v iperf3 >/dev/null 2>&1 && [ -n \"${iperf_target:-}\" ]; then\n    echo \"[3/4] running iperf3 throughput tests to ${iperf_target}...\"\n    echo \"      reverse direction (server -> client)...\"\n    iperf3 -c \"$iperf_target\" -t 60 -r \\\n        > \"${prefix}_iperf3_reverse.log\"\n    echo \"      saved to ${prefix}_iperf3_reverse.log\"\n\n    echo \"      forward direction (client -> server)...\"\n    iperf3 -c \"$iperf_target\" -t 60 \\\n        > \"${prefix}_iperf3_forward.log\"\n    echo \"      saved to ${prefix}_iperf3_forward.log\"\nelse\n    echo \"[3/4] skipping iperf3 tests.\"\n    echo \"      reason: iperf3 not installed or iperf_target not set.\"\n    echo \"iperf3 skipped: missing binary or iperf_target\" \\\n        > \"${prefix}_iperf3_skipped.txt\"\nfi\necho\n\n########################################\n# 4. combined cpu stats + ping (turbostat)\n########################################\nif command -v turbostat >/dev/null 2>&1; then\n    if [ \"${euid:-$(id -u)}\" -ne 0 ]; then\n        sudo=\"sudo\"\n        echo \"[4/4] turbostat found, will use sudo.\"\n    else\n        sudo=\"\"\n        echo \"[4/4] turbostat found, running as root.\"\n    fi\n\n    echo \"      collecting turbostat for 120 seconds...\"\n    echo \"      and running ping to ${local_target} at the same time.\"\n    echo\n\n    # start turbostat in background\n    ${sudo} turbostat --interval 1 --num_iterations 120 \\\n        > \"${prefix}_turbostat_120s.log\" 2>&1 &\n    tstat_pid=$!\n\n    # while turbostat is running, run 600 pings (120s * 0.2s interval)\n    ping -i 0.2 -c 600 \"$local_target\" \\\n        > \"${prefix}_ping_local_during_turbostat.log\"\n\n    # wait for turbostat to finish\n    wait \"$tstat_pid\" || true\n\n    echo \"      turbostat log: ${prefix}_turbostat_120s.log\"\n    echo \"      ping log     : ${prefix}_ping_local_during_turbostat.log\"\nelse\n    echo \"[4/4] turbostat not found, skipping cpu stats.\"\n    echo \"turbostat skipped: binary not found\" \\\n        > \"${prefix}_turbostat_skipped.txt\"\nfi\n\necho\necho \"all tests finished.\"\necho \"result files are under: ${result_dir}\"\necho \"you can now reboot into the other kernel and run this script again.\"\n```\n\n\n## ping test\n\nping is icmp, but queueing on the bottleneck link affects all traffic, so ping rtt/jitter is still a practical proxy for bufferbloat under load.\nthis can still be a good metric to measure bufferbloat.\n\n<table>\n    <thead>\n      <tr>\n        <th>path</th>\n        <th>metric</th>\n        <th>vanilla bbrv3</th>\n        <th>modified bbrv3</th>\n        <th>δ (mod-van)</th>\n        <th>improvement (↓ better)</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <th colspan=\"6\">\n          lan (ping 192.168.168.102, n=1000)\n        </th>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>avg rtt (ms)</td>\n        <td>0.023</td>\n        <td>0.017</td>\n        <td>-0.006</td>\n        <td>+26.8%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>mdev (ms)</td>\n        <td>0.032</td>\n        <td>0.009</td>\n        <td>-0.023</td>\n        <td>+71.9%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>p99 rtt (ms)</td>\n        <td>0.046</td>\n        <td>0.043</td>\n        <td>-0.003</td>\n        <td>+6.5%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>p99.9 rtt (ms)</td>\n        <td>0.152</td>\n        <td>0.058</td>\n        <td>-0.094</td>\n        <td>+61.8%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>max rtt (ms)</td>\n        <td>0.962</td>\n        <td>0.059</td>\n        <td>-0.903</td>\n        <td>+93.9%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>loss (%)</td>\n        <td>0.0</td>\n        <td>0.0</td>\n        <td>0.0 pp</td>\n        <td>0.0 pp</td>\n      </tr>\n\n  <tr>\n    <th colspan=\"6\">\n      wan (ping 1.1.1.1, n=1000)\n    </th>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>avg rtt (ms)</td>\n    <td>5.830</td>\n    <td>5.791</td>\n    <td>-0.039</td>\n    <td>+0.7%</td>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>mdev (ms)</td>\n    <td>0.841</td>\n    <td>0.201</td>\n    <td>-0.640</td>\n    <td>+76.1%</td>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>p99 rtt (ms)</td>\n    <td>6.310</td>\n    <td>6.220</td>\n    <td>-0.090</td>\n    <td>+1.4%</td>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>p99.9 rtt (ms)</td>\n    <td>12.818</td>\n    <td>6.341</td>\n    <td>-6.477</td>\n    <td>+50.5%</td>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>max rtt (ms)</td>\n    <td>30.600</td>\n    <td>7.220</td>\n    <td>-23.380</td>\n    <td>+76.4%</td>\n  </tr>\n  <tr>\n    <td>wan</td>\n    <td>loss (%)</td>\n    <td>0.0</td>\n    <td>0.0</td>\n    <td>0.0 pp</td>\n    <td>0.0 pp</td>\n  </tr>\n</tbody>\n\n  </table>\n\n  <p>\n    percentages are computed as (vanilla - modified) / vanilla. positive means modified is better (lower latency/jitter).\n  </p>\n\n### 1000m full duplex\n\n<table>\n    <thead>\n      <tr>\n        <th>path</th>\n        <th>metric</th>\n        <th>vanilla bbrv3</th>\n        <th>modified bbrv3</th>\n        <th>δ (mod-van)</th>\n        <th>improvement (↓ better)</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <th colspan=\"6\">\n          lan (ping 127.0.0.1, n=1000)\n        </th>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>avg rtt (ms)</td>\n        <td>0.01985</td>\n        <td>0.01770</td>\n        <td>-0.00215</td>\n        <td>+10.8%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>mdev (ms)</td>\n        <td>4.010</td>\n        <td>2.318</td>\n        <td>-1.692</td>\n        <td>+42.2%</td>\n      </tr>\n      <tr>\n        <td>lan</td>\n        <td>max rtt (ms)</td>\n        <td>4.020</td>\n        <td>2.330</td>\n        <td>-1.690</td>\n        <td>+42.0%</td>\n      </tr>\n      <tr>\n        <th colspan=\"6\">\n          wan (ping 1.1.1.1, n=1000)\n        </th>\n      </tr>\n      <tr>\n        <td>wan</td>\n        <td>avg rtt (ms)</td>\n        <td>5.784</td>\n        <td>5.764</td>\n        <td>-0.020</td>\n        <td>+0.35%</td>\n      </tr>\n      <tr>\n        <td>wan</td>\n        <td>mdev (ms)</td>\n        <td>1.640</td>\n        <td>1.440</td>\n        <td>-0.200</td>\n        <td>+12.2%</td>\n      </tr>\n      <tr>\n        <td>wan</td>\n        <td>max rtt (ms)</td>\n        <td>6.560</td>\n        <td>6.540</td>\n        <td>-0.020</td>\n        <td>+0.30%</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <p>\n    percentages are computed as (vanilla - modified) / vanilla. positive means modified is better (lower latency/jitter).\n  </p>\n\nas a result, rtt has improved significantly--something that would not happen if we only tweaked user-space applications.\nnow, let's move on to the iperf test, since bbrv3 does a lot more than bbrv1/v2, which i posted about before.\nin that previous post, i only attached a ping test, but now i am sharing an iperf3 test for you.\n\n## iperf3 test\nthe server was fixed to `ping.online.net:5200`.\n### 1000m full duplex\nthe server was fixed to `ping.online.net:5200`. the test was conducted on a 1000m full duplex router with a 500mbps wan link.\n\n### raw\n\n| case | forward<br>throughput (mbps) | reverse<br>throughput (mbps) | reverse<br>retrans | fwd latency<br>avg (ms) | rev latency<br>avg (ms) |\n|---|---|---|---|---|---|\n| bbr3_135852 | 332.85 | 401.77 | 93,315 | 23.50 | 25.62 |\n| bbr3_140147 | 334.20 | 426.41 | 152,655 | 23.50 | 26.95 |\n| bbr3vanilla (baseline) | 252.71 | 428.47 | 188,474 | 23.56 | 27.38 |\n\n### analysis\n\n| metric (forward) | vanilla (bbr3 baseline) | modified (bbr3 optimized) | improvement |\n|---|---|---|---|\n| throughput (recv) | 252.71 mbps | 334.20 mbps | +32.25% |\n| latency (avg) | 23.56 ms | 23.50 ms | +0.25% (reduced) |\n\n| metric (reverse) | vanilla (bbr3 baseline) | modified (bbr3 optimized) | improvement |\n|---|---|---|---|\n| tcp retransmissions | 188,474 | 93,315 | +50.49% (reduced) |\n\nas you can see, forward throughput increased by roughly 32% while reverse retransmissions decreased by over 50%.\nthis indicates that the tuning effectively balances the congestion window, preventing excessive packet loss without sacrificing (and even improving) forward throughput in this scenario.\nthis result suggests that the \"brake pedal\" logic works well even in higher bandwidth environments, maintaining stability and efficiency.\n\n### 100m full duplex\n### raw\nwhen running test 112620, public iperf3's response was broken for 4 attempts.\nthis shows a behavior when network quality is poor.\n\n<table>\n  <thead>\n    <tr>\n      <th>case</th>\n      <th>forward<br>recv (mbps)</th>\n      <th>reverse<br>recv (mbps)</th>\n      <th>forward<br>retrans</th>\n      <th>reverse<br>retrans</th>\n      <th>ping fwd<br>avg (ms)</th>\n      <th>ping fwd<br>max (ms)</th>\n      <th>ping rev<br>avg (ms)</th>\n      <th>ping rev<br>max (ms)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>bbr3_112401</td>\n      <td>84.99</td>\n      <td>87.31</td>\n      <td>342</td>\n      <td>35734</td>\n      <td>25.96</td>\n      <td>43.69</td>\n      <td>27.49</td>\n      <td>65.29</td>\n    </tr>\n    <tr>\n      <td>bbr3_112620<br>(worst case)</td>\n      <td>84.01</td>\n      <td>87.90</td>\n      <td>671</td>\n      <td>43481</td>\n      <td>27.69</td>\n      <td>46.41</td>\n      <td>26.82</td>\n      <td>46.99</td>\n    </tr>\n    <tr>\n      <td>bbr3vanilla_112511</td>\n      <td>81.23</td>\n      <td>87.80</td>\n      <td>580</td>\n      <td>42012</td>\n      <td>28.71</td>\n      <td>73.05</td>\n      <td>29.17</td>\n      <td>46.19</td>\n    </tr>\n  </tbody>\n</table>\n\n### analysis\n\n<table>\n  <thead>\n    <tr>\n      <th>metric (forward)</th>\n      <th>vanilla (bbr3 baseline)</th>\n      <th>modified (bbr3 optimized)</th>\n      <th>improvement</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>throughput (recv)</td>\n      <td>81.23 mbps</td>\n      <td>84.99 mbps</td>\n      <td>+4.63%</td>\n    </tr>\n    <tr>\n      <td>tcp retransmissions</td>\n      <td>580</td>\n      <td>342</td>\n      <td>+41.03% (reduced)</td>\n    </tr>\n    <tr>\n      <td>avg latency (ping)</td>\n      <td>28.71 ms</td>\n      <td>25.96 ms</td>\n      <td>+9.58% (reduced)</td>\n    </tr>\n    <tr>\n      <td>max latency (jitter)</td>\n      <td>73.05 ms</td>\n      <td>43.69 ms</td>\n      <td>+40.19% (reduced)</td>\n    </tr>\n  </tbody>\n</table>\n\nas you can see, max latency has improved by 40%, while throughput increased by 4%.\naverage latency has improved by 9% with this tweak, even though google is generally known for high-performance tuning.\nthis shows that every case has its own niche points, even though many methods are developed by renowned corporations.\nsince the cwnd management logic acted as a brake pedal, it does not affect the balanced options of bbrv3 much; if you are planning to tune your kernel, i recommend you stay within your own safe zone.\n\n## what can be the direction of my tuning?\n\nmy safe zone was *not to accept packets aggressively*.\npersonally, i concluded that preventing bufferbloat is more important than aggressively allowing packets to increase throughput (like an old korean proverb: you may burn your house down when you try to burn bedbugs).\n\nconsequently, in my case, i *reduced* the speed of certain parts that are usually considered conservative tuning.\nbut some aggressive tuning decreases pacing to obtain better responsiveness, which i wouldn't do for my server.\n\nif you are a skilled engineer, you may add those sorts of tunings to squeeze a dry towel.\n\n## risks and trade-offs\n\nthis tweak is intentionally biased toward latency stability rather than maximizing raw throughput. that implies trade-offs:\n\n* **potential throughput reduction:** reducing pacing and/or cwnd more aggressively can underutilize capacity on clean links, especially on high-bdp paths where a larger steady-state window is required.\n\n* **sensitivity to measurement noise:** bandwidth samples can fluctuate due to cross-traffic, ack compression, or transient scheduling effects. a policy that reacts to short-term drops can become overly conservative unless thresholds and smoothing are well chosen.\n\n* **workload dependence:** the benefits are most visible when queueing and tail latency matter (interactive or latency-sensitive services). for bulk transfer workloads, the same behavior may not be desirable.\n\n* **portability across kernel versions:** even if the idea is stable, field names, internal invariants, and pacing/cwnd coupling differ across kernel versions. a port must be reviewed against the target version's bbrv3 implementation details to avoid unintended behavior.\n\n* **regression risk on specific paths:** some networks (e.g., paths with unusual buffering, intermittent loss, or variable rtt) may respond poorly to conservative pacing clamps. the safe approach is to validate on representative production-like paths before relying on the tweak.\n\nif your goal is minimal bufferbloat and better tail latency under contention, these trade-offs can be acceptable. if your goal is peak throughput on clean links, the default behavior may be preferable.\n\n## source\n[mountain kernel revision](https://github.com/gg582/linux-mountain/releases/tag/mountain-v0.3)\n[test script](https://github.com/gg582/mountain_kernel_ping_test/tree/1b5950c7125b156b4adc66757487b1e807df6b79)\n"
    },
    {
      "title": "Vim은-정말-외골수들의-편집기일-뿐일까",
      "subtitle": "Vim은 어디까지 튜닝할 수 있을까",
      "description": null,
      "url": "/blog/2026/01/19/vim.html",
      "collection": "posts",
      "relative_path": "_posts/2026-01-19-Vim은-정말-외골수들의-편집기일-뿐일까.md",
      "date": "2025-12-31T22:32:00+09:00",
      "updated": null,
      "keywords": [
        "개발 환경",
        "Vim",
        "CLI"
      ],
      "categories": [
        "blog"
      ],
      "taxonomy": {
        "category": "general",
        "subcategory": "general-tools",
        "order": 1
      },
      "difficulty": "beginner",
      "excerpt": "Vim의 못난 이미지는 어디서 왔을까? 우선 짚고 넘어가야 할 것이, Vim은 현재 9.x 버전이 릴리스되고 있으며 매우 역사가 깊은 에디터이다. 많은 사람들은 복잡한 AI 확장이 달린 IDE들에 지쳐서 Vim을 사용하고 있지만, 그런 Vim에도 AI 기능을 달 수 있는 확장이 있고, 수십 년간 개선된 파싱 알고리즘, 물론 NeoVim의 트리시터에 비해서는 유연하지 못하지만 여러가지 특수 언어들을 위한 확장, 그리고 다양하게 꾸밀 수 있는 컬러스킴 등이 있다. 또한 Vim에서 가장 유명한 플러그인…",
      "search_text": "vim은-정말-외골수들의-편집기일-뿐일까 vim은 어디까지 튜닝할 수 있을까 개발 환경 vim cli blog general general-tools vim의 못난 이미지는 어디서 왔을까? 우선 짚고 넘어가야 할 것이, vim은 현재 9.x 버전이 릴리스되고 있으며 매우 역사가 깊은 에디터이다. 많은 사람들은 복잡한 ai 확장이 달린 ide들에 지쳐서 vim을 사용하고 있지만, 그런 vim에도 ai 기능을 달 수 있는 확장이 있고, 수십 년간 개선된 파싱 알고리즘, 물론 neovim의 트리시터에 비해서는 유연하지 못하지만 여러가지 특수 언어들을 위한 확장, 그리고 다양하게 꾸밀 수 있는 컬러스킴 등이 있다. 또한 vim에서 가장 유명한 플러그인… \n\n## vim의 못난 이미지는 어디서 왔을까?\n\n 우선 짚고 넘어가야 할 것이, vim은 현재 9.x 버전이 릴리스되고 있으며 매우 역사가 깊은 에디터이다.\n많은 사람들은 복잡한 ai 확장이 달린 ide들에 지쳐서 vim을 사용하고 있지만, 그런 vim에도 ai 기능을 달 수 있는 확장이 있고, 수십 년간 개선된 파싱 알고리즘, 물론 neovim의 트리시터에 비해서는 유연하지 못하지만 여러가지 특수 언어들을 위한 확장, 그리고 다양하게 꾸밀 수 있는 컬러스킴 등이 있다.\n또한 vim에서 가장 유명한 플러그인 관리자인 `vim-plug`를 개발한 전설적인 vim 확장 개발자 `junegunn`은 한국인이다.\n\n이런 평범하게 쓰기 좋은 에디터가 못난이 이미지를 가지게 된 데에는 특히 한국에서 3가지 측면이 있다고 생각한다.\n\n## 많은 팬층은 많은 안티팬들을 불러온다\n\n업계의 주류 에디터가 vscode로 흘러가든말든, vim은 한국에서 많이 사용되는 에디터 top 10을 꼽으면 당당하게 상위권 내지는 중위권에 들어갈 것이다. 서양인들이 emacs를 사랑한다면, 한국인이 사랑하는 cli 에디터는 첫째가 vim, 둘째가 gnu nano일 것이다. 아마 단순하고 효율적인 것에 열광하는 한국인의 특성인지도 모른다.\n\n그러나 이렇게 사용자가 많은 vim은 안티팬이 생기기 좋은 구조이다.\n이는 다음과 같은 까닭으로 정리된다.\n\n- cli이다.\n  - cli 매니아들은 실용과 동떨어진 너드가 많다.\n- 프로그래밍 고인물들은 꼭 옛날식으로 사용한다.\n  - 너무 많은 사람들이 사용하지만, 눈에 띄는 고인물들은 있는 기능도 쓰고 고대비 테마를 쓴다.\n- 일상적으로 사용하기에는 wsl을 접속해야 한다.\n  - vim을 메모장처럼 쓰는 사람은 macos를 쓰거나 리눅스를 쓴다.\n    - 지루하고 현학적이라고 인식된다.\n- 옆동네 neovim은 해커 문화 친화적이다.\n  - 이상한 오타쿠들이 쓸 것 같다.\n\n순화되지 못한 적나라한 표현이지만 솔직히 이런 까닭이 전혀 없다고 부정하기는 힘들 것이다.\n예를 들어서, lightline, 퍼지 파인더, 좀 복잡하지만 nerdtree 등이 적용되었고, 적당히 무난한 monokai가 적용된 vim을 보면 거부감이 적을 것이다. 그러나 텅 빈 .vimrc에 고대비 테마 설정만 딱 꽂혀 있으면 단어 추천, 코파일럿 등등이 원천 차단되어서 \"이게 뭐지?\"라는 느낌이 든다.\n\n이 vim이란 것은 사용자층에 따라 엄청나게 사용법이 갈리는 셈이다.\n\n이제 실제 사용 측면에서 얼마나 차이가 있는지 생각해 보자.\n\n\n## vscode vs zed vs vim\n\n### vscode\n\nvscode는 풍부한 ai기능을 내장하고 있으며, 마우스와 단축키 기반의 사용자 친화적인 조작법을 내세운다.\n단축키야 러닝 커브가 거의 비슷하니 제쳐 두고 보자면, 직관적인 ui, 풍부한 ai기능, ms라는 신뢰감이 가는 기업 주체가 개발하는 에디터이다.\n\n요약하자면:\n\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\">\n  <thead>\n    <tr>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">항목</th>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">점수</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">ai통합</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">5/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">인간 친화적</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">4/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">리소스 소모량</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">단순성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">2/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">설정 용이성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n  </tbody>\n</table>\n\n\n### zed\n\nzed는 논란의 신흥 언어 양대산맥인 go언어와 rust 중 rust로 작성되었다.\n빠르고 가벼운 것을 모토로 내세우지만 그렇게 가벼운지도 모르겠고, ui가 편리한지는 잘 모르겠다.\n솔직히 tui 도구의 워크플로우를 어중간하게 gui로 옮긴 것 같아서 첫인상은 좋은데 자꾸 손이 가진 않는다.\n음식으로 따지면 선물받으면 버리지 않지만 매일 먹기 애매한 초콜릿이다.\n\nai 기능을 킬 시 vscode보다 무겁다는 사례가 속출하는데, 이 경우는 사실 vscode도 충분히 무겁고, ai 통합을 안 킬 시에는 vscode랑 별 차이가 없거나 더 빠릿해서 플러스 마이너스 0으로 쳐 주겠다.\n\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\">\n  <thead>\n    <tr>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">항목</th>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">점수</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">ai통합</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">5/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">인간 친화적</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">리소스 소모량</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">단순성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">설정 용이성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n  </tbody>\n</table>\n\n### vim\n\n솔직하게 말하면 여기서 개인 의견이 강할 수 있다.\nvim의 단축키는 종류가 많지만 쓰는 것들만 추리면 생각보다 vscode나 zed에 비해 그렇게 많지도 않다.\n설정 용이성은 요즘 나오는 `vim-plug`를 쓰면 vundle보다 훨씬 낫다.\n그러나 tui라는 장벽이 잘 만들어놓은 워크플로우가 터미널에서 고립되게 하는 요소이다.\n이렇게 하여 인간 친화성에서는 공정하게 1점 감점하도록 하겠다.\n\n단순성으로 따지면 반복적인 워크플로우에 용이하다.\n작업을 선형적인 습관이 아닌 순환적인 습관으로 하는 사람이라면 vim을 선호할지도 모른다.\n어쩌면 이것이 동양권에서 우세한 vim의 인기를 더 잘 설명하는지도 모르겠다.\n\nai 통합 품질은 써드 파티 플러그인의 품질에 전적으로 의존한다.\n좋은 플러그인을 찾으면 너무 좋지만, 나쁜 플러그인을 찾으면 나쁘다.\n\n파일 등을 확인하는 것은 nerdtree가 있으나, 사용법은 그다지 간단하지 않다.\n터미널의 명령줄 등을 빌리는 것이 더 빠르다.\n\n설정 용이성은 vimscript 9도, neovim의 lua도 쉽지는 않기 때문에 json 기반보다는 감점하겠다.\n그러나 .vimrc나 init.vim만 보관하면 언제든 재현할 수 있기에 0.5점만 감점한다.\n\n<table style=\"width: 100%; border-collapse: collapse; margin: 20px 0;\">\n  <thead>\n    <tr>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">항목</th>\n      <th style=\"border: 1px solid #ddd; padding: 8px; text-align: left; background-color: #f2f2f2;\">점수</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">ai통합</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">3/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">인간 친화적</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">2/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">리소스 소모량</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">1/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">단순성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">5/5</td>\n    </tr>\n    <tr>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">설정 용이성</td>\n      <td style=\"border: 1px solid #ddd; padding: 8px; text-align: left;\">2.5/5</td>\n    </tr>\n  </tbody>\n</table>\n\n\n## 결론\n\n그렇게까지 있을 것도 없는 멍텅구리인가 하면 그런 것은 아니다.\n그렇다고 다른 것들과 별 차이없이 똑똑한 에디터느냐 하면, 방향성이 꽤 뚜렷한 에디터라고 말할 수 있다.\n\nvim에서 ide수준의 환경을 구현할 수 있느냐고 하면 분명 그러하다.\n그러나 그 단축키를 모두 암기하고 쓸 만한 사람이 vim 유저라면, 그 사람은 vim이기 때문에 사용하는 것이지 그 단축키의 직관성을 보고 쓰는 것이 아니다.\n\nvim의 방향성에 대해서는 단순하고, 핵심이 굵은 에디터 주변에 원하는 양념을 치는 것이라고 설명하고 싶다.\n다른 환경에서도 비슷하게 재현 가능하고, tui에 그렇게 어색하지 않으면서, ai가 당신의 워크플로우를 난도질하지 않게 적절하게 플러그인을 설치, 포크 및 수정해서 나만의 환경을 만들고 싶다면 충분히 추천할 만한 에디터이다.\n\n심지어는 이 블로그 포스트 역시 vim 9.1로 작성되었으며 다른 문서 편집기에 비해 크게 불편하지 않았다.\n\n앞으로는 vim을 쓰는 사람을 본다면 \"으...tui. 옛날식으로 일하네.\"라고 생각하지 말고, \"나는 vscode 쓰는데 저 사람은 저걸 쓰네. 나중에 나도 한 번 써 보고 플러그인이나 추천해 볼까?\"라고 생각해 보도록 하자.\n\n## p.s\n\n글에서 풍기는 이미지와 달리 나는 꽤 개방적인 사람이다. 블로그에 방문한다면 한 번쯤 댓글을 달아 줬으면 좋겠다.\n"
    },
    {
      "title": "호기심천국-정말 쓰레드수만큼 작업을 두고 컴파일해야 할까",
      "subtitle": "빌드 병렬화 최적 스레드 수 실험",
      "description": null,
      "url": "/blog/2025/12/31/post.html",
      "collection": "posts",
      "relative_path": "_posts/2025-12-31-호기심천국-정말로-쓰레드수만큼-작업을-두고-컴파일해야-할까.md",
      "date": "2025-12-31T22:32:00+09:00",
      "updated": null,
      "keywords": [
        "빌드 최적화",
        "병렬 컴파일",
        "make",
        "멀티스레딩",
        "성능 튜닝"
      ],
      "categories": [
        "blog"
      ],
      "taxonomy": {
        "category": "general",
        "subcategory": "general-programming",
        "order": 1
      },
      "difficulty": "beginner",
      "excerpt": "송년 기념으로 가볍게 해 보는 실험 흔히들 개발을 할 때 언급을 되는 것이 \"make같은 빌드 프로세스의 작업은 쓰레드 수만큼\"이다. 요즘 발달한 CPU성능, 그리고 정교해진 커널 동작을 보면, 어쩌면 쓰레드 초과로 잡는 게 더 자원을 긁어낼 수 있지 않을까? 같은 의문이 들기 마련이다. 현대 개발 환경에서도 유의미한지 가벼운 마음으로 알아보자. 환경 - RAM 64GB, Samsung DDR4 3200MHz - CPU AMD Ryzen 5 5600X, 4.65 GHz - B550M Pro4, A…",
      "search_text": "호기심천국-정말 쓰레드수만큼 작업을 두고 컴파일해야 할까 빌드 병렬화 최적 스레드 수 실험 빌드 최적화 병렬 컴파일 make 멀티스레딩 성능 튜닝 blog general general-programming 송년 기념으로 가볍게 해 보는 실험 흔히들 개발을 할 때 언급을 되는 것이 \"make같은 빌드 프로세스의 작업은 쓰레드 수만큼\"이다. 요즘 발달한 cpu성능, 그리고 정교해진 커널 동작을 보면, 어쩌면 쓰레드 초과로 잡는 게 더 자원을 긁어낼 수 있지 않을까? 같은 의문이 들기 마련이다. 현대 개발 환경에서도 유의미한지 가벼운 마음으로 알아보자. 환경 - ram 64gb, samsung ddr4 3200mhz - cpu amd ryzen 5 5600x, 4.65 ghz - b550m pro4, a… \n\n## 송년 기념으로 가볍게 해 보는 실험\n\n흔히들 개발을 할 때 언급을 되는 것이 \"make같은 빌드 프로세스의 작업은 쓰레드 수만큼\"이다.\n요즘 발달한 cpu성능, 그리고 정교해진 커널 동작을 보면, 어쩌면 쓰레드 초과로 잡는 게 더 자원을 긁어낼 수 있지 않을까? 같은 의문이 들기 마련이다. 현대 개발 환경에서도 유의미한지 가벼운 마음으로 알아보자.\n\n### 환경\n\n- ram 64gb, samsung ddr4 3200mhz\n- cpu amd ryzen 5 5600x, 4.65 ghz\n- b550m pro4, asrock\n- 하이퍼쓰레딩 사용 기준 논리코어로 12쓰레드 산정\n\n### 소스\n\n- ssh-chatter, commit `e2faa51` 소스(약 53000줄의 경량 게시판)\n\n### 정석적인 쓰레드 수대로 했을 때\n\n```\nreal    0m3.705s\nuser    0m18.137s\nsys     0m0.775s\n```\n\n### 쓰레드 수의 1.5배\n\n```\nreal    0m3.686s\nuser    0m18.231s\nsys     0m0.748s\n```\n\n### 쓰레드 수의 2배\n\n```\nreal    0m3.606s\nuser    0m17.806s\nsys     0m0.787s\n```\n\n### 쓰레드 수의 2.5배\n\n```\nreal    0m3.551s\nuser    0m17.483s\nsys     0m0.757s\n```\n\n### 쓰레드 수의 3배\n\n```\nreal    0m3.755s\nuser    0m17.360s\nsys     0m0.668s\n```\n\n## 결과 해석\n\n<img src=\"/assets/images/combined_metrics_05.png\" style=\"max-width:50%; height: auto;\"/>\n\n*여기서 안내하지만 시스템에 따라 다를 수 있다*\n결과는 너무나도 충격적이다.\n<u>하드웨어의 쓰레드 수의</u> **2.5배**<u>가 될 때까지 컴파일 시간은 계속 줄어들었다.</u>\n\ncs 전공자가 아닌 사람들 입장에선 당연한 상식이 머릿속에서 깨지면서 정신이 아득해질지도 모른다.\n물론 필자도 cs가 아닌 파생형 전공을 한 사람이기 때문에 말도 안 된다고 생각한 예측이 맞아 들어가는 시나리오가 존재한다는 것을 섣불리 믿기 어렵다.\n\n그렇다면 리눅스 커널 모듈 코드로도 한번 해 보자. 필자의 노트북 튜닝 역작(?) `laputil`을 한번 빌드해 보자.(커밋 `26237b0`)\n\n### 정석적인 쓰레드 수\n\n```\nreal    0m1.076s\nuser    0m1.031s\nsys     0m0.198s\n```\n\n### 쓰레드 수의 1.5배\n\n```\nreal    0m1.011s\nuser    0m1.083s\nsys     0m0.142s\n```\n\n### 쓰레드 수의 2배\n\n```\nreal    0m1.034s\nuser    0m1.065s\nsys     0m0.177s\n```\n\n## 결과 해석\n\n아니...어처구니가 없다. 이게 코미디지 다른게 코미딘가?\n솔직히 이건 당혹스러움 이상으로 수치심이 들지도 모른다.\n\n여기서도 적더도 쓰레드 수의 1.5배에서 스윗 스팟이고, 2배부터 병목이 생겼지만 **여전히 정석보다 빠르다**. windows, linux와 같은 운영체제, 그리고 현대 컴퓨터과학의 승리인가? 여러모로 마음이 복잡할 수밖에 없다.\n\n## 추론\n\n리눅스 커널 뿐만 아니라 윈도우 등의 커널도 상당한 수준의 저수준 최적화로 작업을 재배치하는 것으로 알려져 있다.\n즉 우리가 집어넣은 대로만 돌아가는 바보 기계가 아니라는 것이다...\n어찌저찌 파이프라인 사이사이에 집어넣다 보면 들어가는 구멍이 있는 듯하다. 아마 쑤셔넣었겠지.\n정석이든 아니든간에 추가적인 컴파일 시간 최적화가 가능하다. 물론 프로그램의 유형과 규모에 따라 쑤셔넣을 수 있는 정도가 다르지만.\n\n윈도우는 사용하는 기기가 없어서 테스트하지 못하였으나 아마 유사한 경향을 보일 것으로 추정된다.\n\n### 대체 왜냐?\n\n현대 cpu는 빠르다. 말도 안 되게 최적화되어있고 클럭이 4ghz는 훌쩍 넘는다. 더구나 최신 cpu는 마의 5ghz 따위는 가볍게 무시하고 말도 안 되는 고클럭을 사용한다.\n\n그런 현대 cpu는 지금 들어온 작업을 빠르게 처리하고 유휴상태로 들어간다. 그럼 그 동안은 코어는 놀고 있는 것이다.\n대학생한테 하루를 주고 피타고라스 정리를 이용한 중학교 수학 문제 모음들을 쥐어 주면, 수능 성적과 학벌 모두 무관하게 시간이 남는 경우가 많을 것이다. 그럼 대학생은 남는 시간동안 별 일이 없으면 앉아서 쉬고 있는 것이다.\n\n그런데, 피타고라스 정리를 이용한 문제 모음들을 1000개 정도 줘 보자. 전보단 시간을 빡빡하게, 한 문제를 풀고 다음 문제를 풀게 될 것이다.\n\n이것이 파이프라인을 까맣게 칠해버려서 작업으로 가득 채우는 셈인 것이다.\n\n### 컨텍스트 스위칭? 치타는 웃고 있다....\n옛날 운영체제와 달리 요즘 커널들의 컨텍스트 스위칭은 전환 속도가 최적화되어 있다.\n즉 작업 전환이 무서워서 cpu를 덜 돌릴 바에는 빠른 현대 os에게 작업을 가득 던져 주는 편이 낫다.\n그렇게 복잡한 작업이 아니면...넉넉하게 던져 보자.\n1.5배 던져도 웬만해선 괜찮을 거다.\n\n## 결론\n\n세상은 때론 여러분의 예상보다 냉혹하다. 불변하는 듯했던, 그렇지만 약간은 구시대적이고 주먹구구식인 `make -j$(nproc)`이 대체로 합리적으로 컴파일 시간을 줄여주지만, 어째선지 최선이 아닌 것이다..\n세계 최고의 석학들이 다 믿고 쓰니까 실험조차 해 보지 말자고 생각한 나를 반성한다.\n앞으로는 별로 어렵지 않은 것 같으면 직접 상황을 실험해 보고 다시 한번 고민해 봐야겠다.\n\n*p.s) 필자는 전문성이 부족하고 어딘가 맛이 간 듯한 삼류 코딩을 한다. 다시 한 번 말하지만 이 실험의 정확도는 낮다.*\n"
    },
    {
      "title": "Easy Learning Series-SOCKMAP and Splicing",
      "subtitle": "Kernel-level Network Optimization Techniques",
      "description": null,
      "url": "/network/2025-12-31-Easy-Learning-Series-SOCKMAP-and-Splicing",
      "collection": "network",
      "relative_path": "2025-12-31-Easy-Learning-Series-SOCKMAP-and-Splicing",
      "date": "2025-12-31T11:00:00+09:00",
      "updated": null,
      "keywords": [
        "SOCKMAP",
        "Splicing",
        "TCP",
        "Kernel Networking",
        "Zero-copy"
      ],
      "categories": [
        "network"
      ],
      "taxonomy": {
        "category": "network",
        "subcategory": "network-kernel",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "TCP Splicing: Gotcha, you reverse proxy! Reverse proxies like NGINX and HAProxy, which are commonly used from undergraduate labs to the field, are inherently L7 proxies. Because they involve frequent data transfer between the kernel and user space, they fundamentally cannot push…",
      "search_text": "easy learning series-sockmap and splicing kernel-level network optimization techniques sockmap splicing tcp kernel networking zero-copy network network network-kernel tcp splicing: gotcha, you reverse proxy! reverse proxies like nginx and haproxy, which are commonly used from undergraduate labs to the field, are inherently l7 proxies. because they involve frequent data transfer between the kernel and user space, they fundamentally cannot push… \n\n# tcp splicing: gotcha, you reverse proxy!\n\nreverse proxies like nginx and haproxy, which are commonly used from undergraduate labs to the field, are inherently l7 proxies. because they involve frequent data transfer between the kernel and user space, they fundamentally cannot push performance to its absolute limit from the start.\n\nin other words, among various techniques to reduce copy costs, the most powerful one is to keep as much work as possible in kernel space. cloudflare describes sockmap as a \"holy grail\" for performance in certain proxy workloads, and even calls it a \"tectonic shift\".\n\nbefore getting to sockmap, i’ll start with splice-style approaches to see how far you can push more traditional user-space designs.\n\n## what makes traditional optimization better than l7 proxies?\n\ni’d like to use a **solid metaphor** here.\nimagine you are a **woodchopper** and you need to move as many logs as required. your client wants you to move a massive amount of logs.\n\nlet's say there are two methods:\n\n1. moving each log one by one into baskets, handing them to a packaging company, which then stacks them separately in a truck to send.\n2. pre-tying the logs into **bundles**, putting them straight into a box of appropriate size, and using our own cooperative's truck.\n\nwhen there are 120 logs, in case 1, you'd have to pack 120 boxes one by one, hand them to the packager, and transport them by truck.\nin case 2, you pack 6 bundles (1 bundle = 20 logs) into the largest box and send them via our own truck.\n\neven excluding the time saved by not transferring cargo to a packager, if we assume a box only fits 1 log-bundle, one bundle is treated like one log, making it 20 times faster. if the order volume is small enough to find a box that fits all 6 bundles, the time required is 1—meaning it's 120 times faster than case 1.\n\nthis alone shows it's a change worth calling a \"seismic shift\" in high-load environments. even if we consider a median value between the worst case (all boxes fit only 1 bundle) and the best case (all bundles fit in one box), and exclude the shipping consignment, the speed is roughly `(6+1)/2 == 3.5; 120/3.5 == approx 34.28x`, which is sufficiently powerful.\n\ni can see why the cloudflare blog called it a seismic shift. now, let’s compare the functions usually used for this.\n\n## what kind of functions are available?\n\nthis is where things get interesting as we can see the comparison of `sendfile` vs `splice` vs `vmsplice`.\n\n`sendfile` reads from a disk file to a socket. it’s not zero-copy, but it avoids user space memory copying, focusing on disk -> socket transfer. to use the metaphor again, it’s like taking log bundles out of a cold storage warehouse, putting them in a box, and loading them onto the cooperative's truck.\n\n`splice` reads from a pipe to a socket and performs zero-copy for both network socket copying and its reverse. this is like taking logs from the employee at the warehouse and shoving them into the truck via a **high-speed conveyor belt with almost zero transit time** that shoves them into the truck. when returning, you take the cargo from the client and load the logs again. it’s clear why linus didn't prefer `sendfile`. (note: unless `splice_f_move` is used, copies are sometimes mixed in).\n\n`vmsplice` carries data from a memory area (especially a virtually continuous memory space) to a pipe. you can't avoid user space memory, but it is zero-copy. this is like using a consignment delivery service, but the company's truck is right next door, so you plug it in with a high-speed belt.\n\nif you need to use a virtual continuous memory area, use `vmsplice`; otherwise, `splice` should do. if memory is scarce, `vmsplice` is good, but you must accept trade-offs in performance, such as page alignment issues, so you have to handle it.\n\n## then what were nginx, haproxy doing?\n\nin fact, these two handle different parts and have different reasons for how they do things, so we can't say one is superior. however, a brief introduction will help you understand what they were thinking.\n\n**nginx** can be summarized like this: if a certain place frequently takes pine logs, remember what they take and immediately give them **\"company x's pine logs.\"** this method is fast because it doesn't need to reload information every time, but there's a risk of giving company x's logs even when they unexpectedly need oak logs. if you’ve ever experienced a caching issue, it will be easier to feel how similar this situation is.\n\n**haproxy** can be seen as using various routes. when you need large-scale transport, there are various routes between two points. since some routes might require driving on narrow roads, haproxy aims to deliver the logs on time by operating trucks through various pathways to avoid traffic jams.\n\nwhile these are excellent approaches in that they don't directly call kernel apis, it’s common sense that shortening the actual path makes the transport faster.\n\n## naive vs splice via python examples\n\n### naive (without splice)\n\n```python\nwhile data:\n    data = read(sd, 4096)\n    writeall(sd, data)\n\n```\n\n### splice\n\n```python\npipe_rd, pipe_wr = pipe()\nfcntl(pipe_rd, f_set_pipe_sz, 4096) # in our metaphor, 4096 logs make 1 bundle\nwhile n:\n    n = splice(sd, pipe_wr, 4096)\n    splice(pipe_rd, sd, n)\n\n```\n\nin this case, if a situation arises where several bundles can be sent at once, the `splice` function will bundle them together. since the api is already well-made, you can implement this easily without destructive modifications.\n\n## sockmap: ebpf rules all.\n\nnow we are focusing on the main point. from here, the approach is completely different from user-space proxying. first, let’s use a metaphor for sockmap.\n\nthis is truly an elegant method. (the metaphor is exaggerated, of course.) **sockmap can feel like a teleport fast path**: imagine building a high-speed train between the factory and the client, moving data without relying on the slow truck route.\n\nin a typical user-space proxy, data often bounces between user space and the kernel and goes through buffering paths. with ebpf + sockmap, you can build a much shorter in-kernel forwarding path.\n\nin the sockmap api, we will try using the `bpf_sk_redirect_map` part, but before that, let's look at what ebpf is.\n\n## what is ebpf?\n\nebpf (extended berkeley packet filter) lets you run verified programs inside the linux kernel at various hook points (e.g., xdp, tc, cgroup, tracing, and socket-related hooks) without rebuilding the kernel.\n\nin practice, it enables packet processing, observability, and socket i/o redirection while avoiding a lot of user↔kernel context switching and copying.\n\naccording to a netflix post, in their production use case the overhead was typically under ~1% on most instances. with that kind of cost profile, you can add functionality in the kernel without constantly shuttling data through user space.\n\n## what is sockmap?\n\nthis is a modern api designed for direct communication between sockets within the kernel space. the method of mapping each socket with this is simple, unlike conventional wisdom in kernel development, and if you narrow it down to communication for a specific purpose, the code can be finished very briefly. we will find functions here. please follow the lines and catch the structure.\n\n[ebpf documentation](https://docs.ebpf.io/linux/helper-function/)\nwe will follow the \"redirect helpers\" in \"network helpers,\" refer to the documentation, and write code to open a network socket at `127.0.0.1:8080`. what we want is to redirect messages coming from `127.0.0.1:8080` to a **socket**.\nthen the candidates we need to look at are narrowed down.\n\nwe will focus on those that look like basic forms for our purpose, those with the `sk_` tag, and especially those **without exceptions** (such as \"overriding general behavior\"). when filtered, the list looks like this:\n\n```c\nbpf_clone_redirect\nbpf_sk_redirect_map\nbpf_redirect\nbpf_redirect_map\nbpf_sk_redirect_hash\nbpf_msg_redirect_map\n...\n\n```\n\noverall, these are useful for tasks like immediately \"plugging in\" messages coming into a specific socket—for example, in a server that receives specific control packets from the outside. if you are interested in using ebpf for other purposes, you can simply check the docs.\n\nlet's cherry-pick a few and see how to read the docs.\n\n## bpf_redirect_map\n\nthere's an explanation in the definition section. the description of this function contains information that it redirects packets to an endpoint referenced by the index key of a specific map. it **specifies the purpose**, stating that this map includes network devices or cpus. it also provides **flags for specific actions** like `bpf_f_broadcast`, and informs that `bpf_redirect` is a **function that operates under fewer conditions**, needing only `ifindex` instead of a map index. this definition alone compresses everything from an overview to further links.\n\nthe returns part is clearly explained even for beginners.\n\n```c\n// xdp_redirect on success, or the value of the two lower bits of the flags argument on error.\nstatic long (* const bpf_redirect_map)(void *map, __u64 key, __u64 flags) = (void *) 51;\n\n```\n\nwhen there is no error: `xdp_redirect`. on error, you can see it gives a copy of the lower 2 bits. therefore, the code pattern becomes as follows:\n\n```c\n// bpf_printk is for debugging; replace with ring buffer for production.\nlong ret = bpf_redirect_map(&tx_port, key, 0);\nif (ret != xdp_redirect) {\n    bpf_printk(\"bpf_redirect_map failed: ret=%ld\", ret);\n    return xdp_aborted;\n}\n\n```\n\nas such, just by reading the api well, you can grasp how to write the code pattern and what role it plays.\n\n### looking at abbreviations\n\nabbreviations are common: `sk` is used for **socket**, `msg` is used for **message**, etc.\n\n### bpf_sk_redirect_map\n\nlet's translate this into plain english.\n\n* this bpf function does something.\n* this is doing something for a socket.\n* this is redirecting ___ by a map.\n\n\n\"___\" can be naturally inferred as \"the packet referenced\" if you're in a related field. combining it again: \"this bpf function redirects the socket referenced by the map.\"\n\nalso, it guides you through flags for selecting specific ingress paths like `bpf_f_ingress`, just like high-level languages. the docs list `program types` and `map types` so you won't get lost.\n\n## benchmark results\n\n```bash\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-sockmap 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[+] rx=102400001 tx=0\n^c\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-naive 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[-] edge side eof\n[+] read 97.7mib in 1075.9ms\n^c\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-splice 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[-] edge side eof\n[+] read 97.7mib in 1064.3ms\n^c\n\n```\n\nsockmap is fast enough that it’s easier to express throughput using `tx/rx` counters. in this run, `splice` improved only slightly (~11ms best-case). this matches the intuition: if you can build a true in-kernel fast path, the difference can be much larger than what you get from “better user-space piping.”\n\nthis can be attractive for high-throughput proxies and service networks.\n\nto try it yourself, check out this example which is assembly-optimized for arm64 machines and improved to specify the attach type when attaching to the kernel:\n[benchmark source](https://github.com/gg582/cloudflare-study/tree/main/ebpf-sockmap)\n\nit's a valuable resource to glimpse the code conventions and quality of a large corporation. read it thoroughly and look for further improvements; it will be a good study.\n\n## closing\n\nthe log-bundle metaphor helped me understand why splice and sockmap feel fundamentally different. i’ll keep posting notes as i explore more ebpf networking topics.\n"
    },
    {
      "title": "BBRv1을 튜닝해서 지터를 더 줄여보자",
      "subtitle": "TCP 혼잡제어 최적화를 통한 네트워크 성능 개선",
      "description": null,
      "url": "/network/2025-12-23-BBRv1을-튜닝해서-지터를-더-줄여보자",
      "collection": "network",
      "relative_path": "2025-12-23-BBRv1을-튜닝해서-지터를-더-줄여보자",
      "date": "2025-12-23T14:00:00+09:00",
      "updated": null,
      "keywords": [
        "BBR",
        "TCP 혼잡제어",
        "네트워크 튜닝",
        "지터",
        "성능 최적화"
      ],
      "categories": [
        "network"
      ],
      "taxonomy": {
        "category": "network",
        "subcategory": "network-protocol",
        "order": 1
      },
      "difficulty": "advanced",
      "excerpt": "왜 하필 혼잡제어를 건드리는 거지? TCP 혼잡제어는 아무래도 굉장히 기본적인 부분이고 건드려선 안 될 것같은 느낌이 든다. 하지만 적절한 튜닝이 동반된다면 내가 원하는 방향의 동작을 이끌어낼 수 있는 가성비가 우월한 부분이다. 최근에는 공격적인 처리량(Throughput)를 지양하고 주변와 손실을 고려하는 BBRv3가 등장했지만 현재 기기의 최고 성능보다는 전반적인 조화를 추구하는 경향이 있다. 게이머들은 조화보단 좋은 처리량을 원할 것이지만, 그러면서도 예측 가능한 동작이 필요하다. 나는 이것…",
      "search_text": "bbrv1을 튜닝해서 지터를 더 줄여보자 tcp 혼잡제어 최적화를 통한 네트워크 성능 개선 bbr tcp 혼잡제어 네트워크 튜닝 지터 성능 최적화 network network network-protocol 왜 하필 혼잡제어를 건드리는 거지? tcp 혼잡제어는 아무래도 굉장히 기본적인 부분이고 건드려선 안 될 것같은 느낌이 든다. 하지만 적절한 튜닝이 동반된다면 내가 원하는 방향의 동작을 이끌어낼 수 있는 가성비가 우월한 부분이다. 최근에는 공격적인 처리량(throughput)를 지양하고 주변와 손실을 고려하는 bbrv3가 등장했지만 현재 기기의 최고 성능보다는 전반적인 조화를 추구하는 경향이 있다. 게이머들은 조화보단 좋은 처리량을 원할 것이지만, 그러면서도 예측 가능한 동작이 필요하다. 나는 이것… \n\n\n# 왜 하필 혼잡제어를 건드리는 거지?\n\n tcp 혼잡제어는 아무래도 굉장히 기본적인 부분이고 건드려선 안 될 것같은 느낌이 든다.\n하지만 적절한 튜닝이 동반된다면 내가 원하는 방향의 동작을 이끌어낼 수 있는 가성비가 우월한 부분이다.\n최근에는 공격적인 처리량(throughput)를 지양하고 주변와 손실을 고려하는 bbrv3가 등장했지만 현재 기기의 최고 성능보다는 전반적인 조화를 추구하는 경향이 있다.\n 게이머들은 조화보단 좋은 처리량을 원할 것이지만, 그러면서도 예측 가능한 동작이 필요하다. 나는 이것을 위한 혼잡 제어 패치를 소개하고자 한다.\n\n## 기존의 bbrv1: 뭐가 문제인가?\n기존의 bbr은 대역폭의 하락에 대해 델타를 계산해서 반영하는 등의 안전 장치가 빠져 있고, 심한 경우 관성적으로 패킷을 보낼 수 있다.\n이러한 문제점을 해결하려면 델타, 즉 하락의 변화량을 계산해서 그에 비례해서 패킷 송출 간격을 늘이면 패킷이 균일하게 줄줄이 소시지처럼 착착 전송될 수 있도록 해야 한다.\n## 설계\n- 대역폭 하락 시 delta 계산\n- 대역폭의 하락에 비례해서 송출 간격을 늘린다\n  - 델타로 보아 지연이 심화되면 혼잡 윈도우를 강제로 깎음\n    -  네트워크에 머무는 패킷도 강제적으로 줄어든다\n아주 간단하지만 알기 쉬운 알고리즘이다.\nbbrv3만큼의 정교한 조화는 아니지만 낮은 throughput을 유지하면서도 적당한 버퍼 점유(bufferbloat) 제어를 할 수 있다.\n이것은 결과적으로 lan 지연 스파이크를 줄여서 밀리세컨드 단위조차 중요한 온라인 게이밍 시 긍정적인 영향을 줄 수 있다.\n\n기존 bbr이 브레이크가 부족한 f1 레이싱카, 내가 개조한 것이 성능 좋은 브레이크가 달린 시판 스포츠카라면, bbrv3는 주변 환경에 기민하게 반응하고 제어되는 고급 오프 로드 자동차라고 생각할 수 있다. 일반적인 게이머 입장에서는 적당히 안 엉키면서도 빠른 네트워크 환경을 필요로 하니 산업적인 사용이 아닌 이러한 상황에선 유효한 패치라고 볼 수 있다.\n\n## 벤치마크 결과\n\n튜토리얼에 *비전공자도 쉽게 따라 하는 리눅스 커널 해킹-지터를 잡아보자*로 되어 있는 강의에 포함된 패치를 적용한 linux 6.18, debian 13에 탑재된 제네릭 6.12, 그리고 이것까지 적용된 커널을 비교하겠다. 가능하면 6.18까지 맞추는 것이 좋으나 네트워크 스택의 변화는 적으니 편의 상 기본 커널을 사용했다. 제네릭은 vanilla, 지난 패치는 ecmp patched, 이번 패치는 mountain-v0.1로 표기한다.\n\n\n  <h2>ping comparison mountain-v0.1</h2>\n  <p>\n    positive values in “δ vs …” mean lower-is-better improvement (latency / jitter-proxy reduced).\n    “jitter” row is shown for reference only: the post reports stdev, while ping prints\n    mdev.\n  </p>\n\n  <h3>local ping: 127.0.0.1 (ms)</h3>\n  <table>\n    <thead>\n      <tr>\n        <th>metric</th>\n        <th>vanilla</th>\n        <th>ecmp patched</th>\n        <th>mountain-v0.1 (6.18.0-mountain+)</th>\n        <th>δ vs vanilla</th>\n        <th>δ vs ecmp patched</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td>min</td>\n        <td>0.011000</td>\n        <td>0.010000</td>\n        <td>0.010000</td>\n        <td>+9.09%</td>\n        <td>+0.00%</td>\n      </tr>\n      <tr>\n        <td>avg</td>\n        <td>0.029343</td>\n        <td>0.017279</td>\n        <td>0.014000</td>\n        <td>+52.29%</td>\n        <td>+18.98%</td>\n      </tr>\n      <tr>\n        <td>max</td>\n        <td>4.650</td>\n        <td>0.059000</td>\n        <td>0.067000</td>\n        <td>+98.56%</td>\n        <td>-13.56%</td>\n      </tr>\n      <tr>\n        <td>max-min (spread)</td>\n        <td>4.639</td>\n        <td>0.049000</td>\n        <td>0.057000</td>\n        <td>+98.77%</td>\n        <td>-16.33%</td>\n      </tr>\n      <tr>\n        <td>jitter (stdev in post / mdev in ping)</td>\n        <td>0.146496</td>\n        <td>0.006409</td>\n        <td>0.006000</td>\n        <td>—</td>\n        <td>—</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <p>\n    note: mountain-v0.1 values are from ping summary (min/avg/max/mdev). vanilla/ecmp patched values are from the\n    post’s computed table. wan test is excluded because i must regenerate whole test files with other kernels.\n  </p>\n\n\n## diff 첨부\n```diff\n--- a/net/core/dev.c\n+++ b/net/core/dev.c\n@@ -7682,18 +7682,8 @@ static int __napi_poll(struct napi_struct *n, bool *repoll)\n \t\tnetdev_err_once(n->dev, \"napi poll function %ps returned %d, exceeding its budget of %d.\\n\",\n \t\t\t\tn->poll, work, weight);\n +\tif (likely(work < weight)) {\n+\t\t/* traffic is low, decrease weight for next time */\n+\t\tif (work < (weight / 2) && weight > 16)\n+\t\t\tn->weight = max(weight / 2, 16);\n+\t\treturn work;\n+\t}\n+\n+\t/* if we got here, work == weight, which means high traffic.\n+\t * increase weight for next time.\n+\t */\n+\tif (n->weight < (napi_poll_weight * 4))\n+\t\tn->weight = min(n->weight * 2, napi_poll_weight * 4); \n-\tif (likely(work < weight)) \t\treturn work;\n \t/* drivers must not modify the napi state if they\n \t * consume the entire weight.  in such cases this code@@ -11432,7 +11422,6 @@ int register_netdevice(struct net_device *dev)\n \tdev_init_scheduler(dev);.io/\n \n \tnetdev_hold(dev, &dev->dev_registered_tracker, gfp_kernel);+ \tlist_netdevice(dev);\n \n \tadd_device_randomness(dev->dev_addr, dev->addr_len);diff --git a/net/ipv4/tcp_bbr.c b/net/ipv4/tcp_bbr.c\nindex cecfe6b81..760941e55 100644--- a/net/ipv4/tcp_bbr.c+++ b/net/ipv4/tcp_bbr.c@@ -77,11 +77,6 @@\n #define bbr_scale 8\t/* scaling factor for fractions in bbr (e.g. gains) */\n #define bbr_unit (1 << bbr_scale)\n +/* tweak: bandwidth delta parameters for pacing reduction */\n+#define bw_delta_alpha\t\t(bbr_unit / 2)\t/* rate of change for pacing */\n+#define bw_delta_ceiling\t(bbr_unit / 4)\t/* max reduction factor */\n+#define bw_delta_floor\t\t(bbr_unit * 3 / 4)\t/* min pacing gain */\n- /* bbr has the following modes for deciding how fast to send: */\n enum bbr_mode {\n \tbbr_startup,\t/* ramp up sending rate rapidly to fill pipe */@@ -129,8 +124,7 @@ struct bbr {\n \tu32\tack_epoch_acked:20,\t/* packets (s)acked in sampling epoch */\n \t\textra_acked_win_rtts:5,\t/* age of extra_acked, in round trips */\n \t\textra_acked_win_idx:1,\t/* current index in extra_acked array */+\t\treduce_cwnd:1,\t\t/* tweak: reduce cwnd after pacing drop */\n+\t\tunused_c:5;-\t\tunused_c:6; };\n \n #define cycle_len\t8\t/* number of phases in a pacing gain cycle */@@ -532,12 +526,6 @@ static void bbr_set_cwnd(struct sock *sk, const struct rate_sample *rs,\n \tif (!acked)\n \t\tgoto done;  /* no packet fully acked; just apply caps */\n +\t/* tweak: reduce cwnd if pacing gain dropped significantly */\n+\tif (bbr->reduce_cwnd) {\n+\t\tcwnd = max_t(s32, cwnd - acked, 1);\n+\t\tbbr->reduce_cwnd = 0; /* consume flag */\n+\t}\n- \tif (bbr_set_cwnd_to_recover_or_restore(sk, rs, acked, &cwnd))\n \t\tgoto done;\n @@ -775,7 +763,6 @@ static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)\n \tstruct tcp_sock *tp = tcp_sk(sk);\n \tstruct bbr *bbr = inet_csk_ca(sk);\n \tu64 bw;+\tu64 old_bw = bbr_bw(sk); /* tweak: scrape old bw */ \n \tbbr->round_start = 0;\n \tif (rs->delivered < 0 || rs->interval_us <= 0)@@ -791,6 +778,10 @@ static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)\n \n \tbbr_lt_bw_sampling(sk, rs);\n -\t/* divide delivered by the interval to find a (lower bound) bottleneck\n-\t * bandwidth sample. delivered is in packets and interval_us in us and\n-\t * ratio will be <<1 for most connections. so delivered is first scaled.\n-\t */ \tbw = div64_long((u64)rs->delivered * bw_unit, rs->interval_us);\n \n \t/* if this sample is application-limited, it is likely to have a very@@ -799,40 +790,15 @@ static void bbr_update_bw(struct sock *sk, const struct rate_sample *rs)\n \t * bw, causing needless slow-down. thus, to continue to send at the\n \t * last measured network rate, we filter out app-limited samples unless\n \t * they describe the path bw at least as well as our bw model.-\t *\n-\t * so the goal during app-limited phase is to proceed with the best\n-\t * network rate no matter how long. we automatically leave this\n-\t * phase when app writes faster than the network can deliver :) \t */\n \tif (!rs->is_app_limited || bw >= bbr_max_bw(sk)) {\n \t\t/* incorporate new sample into our max bw filter. */\n \t\tminmax_running_max(&bbr->bw, bbr_bw_rtts, bbr->rtt_cnt, bw);\n \t}+\n+\t/* start tweak: pacing reduction on bandwidth drop */\n+\tdo {\n+\t\tu64 max_bw = bbr_max_bw(sk);\n+\t\tu64 delta, pacing_factor;\n+\n+\t\tif (!max_bw || bw >= old_bw)\n+\t\t\tbreak;\n+\n+\t\t/* calculate reduction factor based on bandwidth drop */\n+\t\tdelta = ((old_bw - bw) * bbr_unit) / max_bw;\n+\t\tpacing_factor = (delta * bw_delta_alpha) >> bbr_scale;\n+\n+\t\tif (pacing_factor > bw_delta_ceiling)\n+\t\t\tpacing_factor = bw_delta_ceiling;\n+\n+\t\t/* apply the factor to the current pacing_gain */\n+\t\tif (pacing_factor < bbr_unit)\n+\t\t\tbbr->pacing_gain = (bbr->pacing_gain * (bbr_unit - pacing_factor)) >> bbr_scale;\n+\n+\t\tbbr->reduce_cwnd = 0;\n+\t\tif (bbr->pacing_gain < bw_delta_floor) {\n+\t\t\tbbr->reduce_cwnd = 1;\n+\t\t\t/* don't let pacing gain get too low */\n+\t\t\tif (bbr->pacing_gain < bbr_unit / 8)\n+\t\t\t\tbbr->pacing_gain = bbr_unit / 8;\n+\t\t}\n+\t} while (0);\n+\t/* end tweak */ }\n```\n\n## 소스 코드\n\n[소스 코드](https://github.com/gg582/linux-mountain/releases/tag/mountain-v0.1)\n\n이 내용은 마운틴 커널 0.1 버전으로 릴리즈되었다.\n관심이 있다면 패치된 nvidia 오픈 드라이버와 함께 다운로드해서 설치해 보도록 하자.\n\n## 마치며\n\n지금은 12월 23일이고 이틀 뒤면 12월 25일이다.\n메리 크리스마스...라지만 솔직히 냄새나는 오타쿠라서 난 별로 즐길게 없다.\n코딩하는 크리스마스로 뿌듯하게 보내보자.\n"
    },
    {
      "title": "굴비와 예제로 공부해 보는 SOCKMAP과 스플라이싱",
      "subtitle": "커널 수준 네트워크 최적화 기법",
      "description": null,
      "url": "/network/2025-12-26-굴비와-예제로-공부해보는-SOCKMAP과-스플라이싱",
      "collection": "network",
      "relative_path": "2025-12-26-굴비와-예제로-공부해보는-SOCKMAP과-스플라이싱",
      "date": "2025-12-16T16:34:00+09:00",
      "updated": null,
      "keywords": [
        "SOCKMAP",
        "스플라이싱",
        "TCP",
        "커널 네트워킹",
        "제로카피"
      ],
      "categories": [
        "network"
      ],
      "taxonomy": {
        "category": "network",
        "subcategory": "network-kernel",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "TCP 스플라이싱: 궁극의 리버스 프록시 뽑기 학부 실습부터 현업까지 흔히 사용을 하는 NGINX, HAProxy와 같은 리버스 프록시들은 태생적으로 L7 프록시이고 커널 유저랜드 간의 데이터 전달이 잦은 데서부터 일단 성능을 극한까지 끌어올릴 수는 없다. 다르게 말하면, 복사 비용을 줄이고자 하는 온갖 기법들 중 아주 강력한 것은, 애초에 커널 영역에서 가능한 많은 것을 처리하면 그만인 것인데, 그런 의미에서 SOCKMAP 인프라스트럭쳐는 클라우드플레어 블로그에서는 성배에 비유될 만큼 좋은 방법…",
      "search_text": "굴비와 예제로 공부해 보는 sockmap과 스플라이싱 커널 수준 네트워크 최적화 기법 sockmap 스플라이싱 tcp 커널 네트워킹 제로카피 network network network-kernel tcp 스플라이싱: 궁극의 리버스 프록시 뽑기 학부 실습부터 현업까지 흔히 사용을 하는 nginx, haproxy와 같은 리버스 프록시들은 태생적으로 l7 프록시이고 커널 유저랜드 간의 데이터 전달이 잦은 데서부터 일단 성능을 극한까지 끌어올릴 수는 없다. 다르게 말하면, 복사 비용을 줄이고자 하는 온갖 기법들 중 아주 강력한 것은, 애초에 커널 영역에서 가능한 많은 것을 처리하면 그만인 것인데, 그런 의미에서 sockmap 인프라스트럭쳐는 클라우드플레어 블로그에서는 성배에 비유될 만큼 좋은 방법… \n\n# tcp 스플라이싱: 궁극의 리버스 프록시 뽑기\n\n학부 실습부터 현업까지 흔히 사용을 하는 nginx, haproxy와 같은 리버스 프록시들은 태생적으로 l7 프록시이고 커널<->유저랜드 간의 데이터 전달이 잦은 데서부터 일단 성능을 극한까지 끌어올릴 수는 없다.\n다르게 말하면, 복사 비용을 줄이고자 하는 온갖 기법들 중 아주 강력한 것은, 애초에 커널 영역에서 가능한 많은 것을 처리하면 그만인 것인데, 그런 의미에서 sockmap 인프라스트럭쳐는 클라우드플레어 블로그에서는 성배에 비유될 만큼 좋은 방법이다.\n이 api는 아주 신뢰할 수 있고, 무거운 애플리케이션에 대한 프록시에서 엄청난 성능 변화를(위에서 언급한 블로그에선 지각 변동이라고까지 언급한) 가져올 수 있다.\n\n## 전통적 최적화는 l7 프록시보다 나은 점이 뭐지?\n\n여기서 난 좀 맛있는 비유를 들고자 한다.\n여러분은 어부이고 필요한 만큼 조기를 옮기고자 한다. 거래처에선 엄청나게 많은 조기를 옮겨 주기를 원한다.\n\n두 가지 방법이 있다고 해 보자:\n  1. 조기를 하나하나 바구니에 옮겨 담아서 포장업체에 주고, 업체는 그걸 따로 트럭에 쌓아서 보낸다\n  2. 미리 조기끼리 묶어서 굴비로 만들어 놨다가 바로 적당히 남는 크기의 박스에 넣고 우리 수협의 트럭을 쓴다.\n\n조기가 120마리일 때, 1번 방법에서 총 120 박스를 하나하나 포장해서 포장업체에 넘기고, 트럭에서 수송하게 된다.\n2번 방법에서는, 조기 6두릅(1두릅=20마리)를 제일 큰 박스에 포장해서 우리 트럭으로 보낸다.\n\n포장업체로의 화물 운송 시간이 빠지는 걸 제외해도, 굴비 1마리만 들어가는 박스라고 쳐도 1두릅이 1마리처럼 취급되니 20배 빠르다.\n만약 물량 발주가 적어서 6두릅이 들어가는 박스를 찾았으면 소요 시간은 1, 즉 1번보다 120배가 빠르다.\n\n확실히 이거까지만 봐도 고부하 환경에선 지각 변동이라고 할 만하다.\n만약 최악(모든 박스가 굴비 1개만함)과 최선(한 박스에 굴비가 다 들어감)의 중간값을 생각을 한다고 해도, 수하물 위탁을 빼도 `(6+1)/2 == 3.5; 120/3.5 == 약 34.28x`로 충분히 좋아진 속도가 나온다.\n\n그럼 이제 보통 이럴때 쓰는 함수들끼리 비교해 보자.\n\n## 이런데는 어떤 함수들이 있는 걸까?\n\n이게 굉장히 재밌는 부분이다. sendfile vs splice vs **vm**splice를 볼 수 있는 대목이다.\nsendfile은 디스크파일로부터 소켓으로 읽어오는 형태이고, 제로카피는 아니지만 디스크->소켓 복사가 아닌 유저 스페이스 메모리 복사는 피한다.\n\n또 비유하자면, 굴비 냉동창고에서 굴비를 꺼낸 후 박스에 담아 수협 트럭에 싣는 모습이다.\n\nsplice는 파이프로부터 소켓으로 읽어오고 네트워크 소켓으로의 복사, 그리고 그 역방향도 하는 제로카피인데, 이건 냉동창고에서 굴비를 꺼내 주는 역할을 하는 직원에게서 받아서 수협 **운송 시간이 거의 없는 고속 컨베이어 벨트로** 트럭에 쑤셔넣고, 돌아오면 거래처에서 온 해산물을 꺼내고 다시 굴비를 싣는 것이다.\n왜 리누스가 sendfile을 선호하지 않았는지 알 만하다. (단, `splice_f_move`가 아니면 가끔 copy가 섞이기도 함)\n\nvmsplice는 메모리 영역으로부터(특히 가상의 연속된 메모리 공간으로부터) 파이프로 실어 나르는 형태인데, 유저 스페이스 메모리를 피할 수 없지만 제로 카피이다. 이건 위탁 업체의 배송 서비스를 사용하지만, 위탁 업체의 트럭이 바로 옆 회사라 고속 벨트로 꽂아넣는다고 보면 된다.\n\n가상의 연속 메모리 영역을 쓸 일이 있으면 vmsplice, 아니면 splice를 쓰면 될 것 같다.\n메모리가 부족한 상황이라면 vmsplice를 활용하는 것도 좋으나 페이지 정렬 이슈 등 성능에서의 단점(trade-off)은 감안해야 한다.\n\n## 그럼 nginx, haproxy는 이것도 안 하고 뭘 한건데?\n\n사실 이 둘은 서로 건드리는 부분도 다르고, 왜 그렇게 다루는지도 달라서 뭐가 낫다고 잘라 말할 수는 없다. 그러나 짤막하게 소개해보면 이들이 무슨 생각을 한 건지 이해될 것이다.\n \nnginx는 한 마디로 말하면 이거다. 어떤 곳이 굴비를 자주 받아가는 경우 뭘 받는지 정보를 기억해 놨다가 바로 영광 x업체 굴비를 주자.\n이 방식은 그때그때 정보를 새로 불러올 필요가 없으니 성능은 빠르나, 예기치 못하게 y업체 굴비를 받아야 할 경우에 대응하지 못하고 x업체 굴비를 줄 위험이 있다. 캐싱 문제를 한 번쯤 경험해 봤다면 이것과 유사한 상황임을 체감하기 더 좋을 것이다.\n\nhaproxy는 다양한 경로를 사용한다고 보면 된다. 대규모 운송을 해야 할때, 영광<->서울로 가는 경로는 다양할 것이다.\n좁은 도로를 달려야 하는 경우도 있기 때문에 haproxy는 다양한 경로로 트럭을 운행해서 도착해야 하는 시간에 늦지 않게 굴비가 배달되는 것을 목표로 한다.\n\n직접 커널 api를 호출하지 않는다는 점에서는 아주 훌륭한 접근이지만, 애초에 중간 경로를 줄여 버리면 운송 속도가 빨라지는 것은 당연하다.\n\n## 파이썬 예제로 보는 naive와 splice의 차이\n\n### naive(splice 안씀)\n\n```python\nwhile data:\n    data = read(sd, 4096)\n    writeall(sd, data)\n```\n\n\n### splice\n\n```python\npipe_rd, pipe_wr = pipe()\nfcntl(pipe_rd, f_set_pipe_sz, 4096) #굴비로 비유하면 4096개 굴비가 1묶음이다\nwhile n\n    n = splice(sd, pipe_wr, 4096)\n    splice(pipe_rd, sd, n)\n```\n\n이 경우 만약 몇 묶음을 한 번에 보낼 수 있어지는 상황에선 splice 함수가 묶어서 보내게 된다.\n이미 api가 잘 되어 있기 때문에 생각보다 파괴적인 수정 없이도 쉽게 만들 수가 있다.\n\n## sockmap: ebpf를 여기 쓴다고? 무시무시한 성능이다!\n\n이제 드디어 본론이다. 이제부턴 유저랜드에서의 접근이랑 확 달라진다.\n우선, sockmap에 대해서 비유를 해 보자.\n이건 정말로 어마어마한 방식이다.\n(그럴 일은 없지만) 이건 영광군 모 공장에서 서울 모 거래처 사이를 지나는 고속열차를 만들어서, 트럭이라는 느린 매개체를 거치지 않고 열차에 실어 보내는 방법이라고 생각해도 좋다.\n\n커널에서는 기본 동작이 파이프를 타고 버퍼링되어 나가는 것이기 때문에 속도가 늘어질 수밖에 없는데 이것을 ebpf 프로그램이 우회해서 처리하는 것이다.\n\n일단 sockmap api에서 우리가 사용해 볼 것은 `bpf_sk_redirect_map` 부분일 텐데, 그 전에 ebpf가 무엇인지 알아보자.\n\n## ebpf가 뭐죠?\nebpf(extended berkeley packet filter)는 커널 소스 코드나 추가 모듈을 추가하지 않고 바로 패킷 필터를 시스템 콜과 소켓 사이에, 콜을 가로채서 끼워넣어 주는 기술이며, 패킷 필터가 아니어도 삽입할 수 있다.\n이것은 기본적으로 커널 영역에서 돌아가고 **cpu나 메모리 소비가 낮다**.\n넷플릭스 블로그를 참고해 보면 여기선 웬만한 인스턴스에서 1% 내의 cpu와 메모리 사용량을 보였다고 언급된다.\n추가적인 자원 소모를 최소화하면서, 유저 공간과 커널 사이에서 정보를 과하게 주고받을 필요 없이 내가 쓰고 싶은 프로그램을 간단하게 커널에 주입하는 것이다.\n그렇다면 앞서 말한 splice 등의 기법보다 가벼운 ebpf 모듈이 커널 내에서 소켓과 파이프 등이 복잡하게 오가는 과정을 **통째로 건너뛰게**하면 된다.\n직통 핫라인같은 역할이 되는 것이다.\n\n## sockmap이란?\n이건 커널에서 소켓 간에, 즉 커널 영역 사이에서 소켓끼리 이어지는 통신을 위해서 짜여진 현대적인 api이다.\n각 소켓을 이것으로 매핑을 하는 방식 역시 기존의 커널 개발에 대한 상식과 달리 간단하고, 특정 목적을 위한 통신으로 좁히면 코드도 짤막하게 끝내 버릴 수가 있다.\n함수는 여기서 찾을 것이다. 차례대로 잘 따라와 주길 바란다.\n\n[ebpf 문서](https://docs.ebpf.io/linux/helper-function/)\n우린 network helpers에서 redirect helpers로 따라 들어가서 문서를 참고한 후 127.0.0.1:8080에 하나의 네트워크 소켓을 여는 코드를 짤 것이다.\n우리가 원하는 것은 127.0.0.1:8080으로부터 들어온 메시지를 **소켓**에 리디렉션하는 것이다.\n그렇다면 우리가 봐야 하는 후보는 좁혀진다.\n\n우리 목적에서 쓰려는 기본형으로 보이는 것들과, sk_ 태그가 붙은 것들, 그 중에서도 *일반적인 동작을 오버라이드*한다고 적힌 등의 **예외사항이 없는 것**들을 주목하자.\n그렇게 추려 보면 아래 목록과 같이 추려진다.\n\n```c\nbpf_clone_redirect\nbpf_sk_redirect_map\nbpf_redirect\nbpf_redirect_map\nbpf_sk_redirect_hash\nbpf_msg_redirect_map\n...\n```\n\n전반적으로 특정 소켓으로 들어온 메시지를 곧바로 꽂아 주는 작업, 예를 들면 외부로부터 특정 제어 패킷을 받는 서버 등에서 유용하다.\n다른 용도로 ebpf를 쓸 수 있을까? 하면 그대로 docs에서 찾아보면 된다.\n\n이 중 몇 가지를 추려서 docs 읽는 법도 알아보자.\n\n## bpf\\_redirect\\_map\n\ndefinition 쪽에 설명이 있다. 이 함수의 설명에는 파킷을 특정 맵의 인덱스 키에서 참조하는 엔드포인트로 리디렉션한다는 정보가 담겨 있고,\n이 맵은 네트워크 디바이스나 cpu를 포함한다고 **용도를 특정한다.**\n`bpf_f_broadcast`처럼 **특정 동작을 위한 플래그** 역시 던져주고, 맵의 인덱스가 아닌 ifindex만 있어도 되는 **보다 적은 조건으로 동작하는 함수** 역시 `bpf_redirect`라고 알려 준다.\n이 definition 하나에 간략하게 overview~further links까지 추려둔 셈이다.\n\nreturns 부분은 초심자에게도 명확하게 설명되어 있다.\n```c\n// xdp_redirect on success, or the value of the two lower bits of the flags argument on error.\n\nstatic long (* const bpf_redirect_map)(void *map, __u64 key, __u64 flags) = (void *) 51;\n```\n\n오류가 없을 때: `xdp_redirect`, 오류 시 아래 2비트만큼 복사해서 준다는 점을 알 수 있다.\n그렇기 때문에 코드 패턴은 아래와 같아진다.\n\n```c\n// bpf_printk is for debugging; replace with ring buffer for production.\nlong ret = bpf_redirect_map(&tx_port, key, 0);\nif (ret != xdp_redirect) {\n    bpf_printk(\"bpf_redirect_map failed: ret=%ld\", ret);\n    return xdp_aborted;\n}\n```\n\n이와 같이 api만 잘 읽어도 코드 패턴을 어떻게 쓸지, 무슨 역할을 하는지도 다 파악할 수 있다.\n\n### 줄임말 보기\nsk는 socket의 줄임말로, msg는 message의 줄임말로 쓰이는 등 줄임말이 흔하다.\n### bpf\\_sk\\_redirect\\_map\n\n이걸 그럼 자연어로(영어로) 풀어보자.\n- this bpf function does something.\n  - this is doing something for a socket.\n    - this is redirecting ??? by a map\n\n???는 관련 직종이라면 자연히 the packet referenced으로 추론된다.\n다시 조합해보면, this bpf function redirects the socket referenced by the map.\n한국어로 이 bpf 함수는 맵을 참조해서 소켓을 리디렉션한다.\n\n여기도 마찬가지로 특정 인그레스 경로를 선택하기 위한 플래그인 `bpf_f_ingress` 등을 안내하니 고급 언어들에서 하듯이 마찬가지로 잘 써주면 된다.\n이쪽은 program types와 map types 등으로 어떤 플래그까지 허용되는지도 목록에 준다.\n플래그를 받는 게 중요한 함수들이라도 이걸 보면 헷갈리지 않을 수 있다.\n   \n\n## 벤치마크 결과\n\n```bash\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-sockmap 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[+] rx=102400001 tx=0\n^c\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-naive 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[-] edge side eof\n[+] read 97.7mib in 1075.9ms\n^c\nyjlee@yjlee-linuxonmac:~/cloudflare-study/ebpf-sockmap$ sudo ./echo-splice 127.0.0.1:8080\n[+] accepting on 127.0.0.1:8080 busy_poll=0\n[-] edge side eof\n[+] read 97.7mib in 1064.3ms\n^c\n```\n\nsockmap은 너무 빨라서 tx/rx로 표기해야 볼 수 있는 경지에 이르렀는데, splice는 잘 쳐줘 봐야 11ms 줄였다.\n이건 마치 아무리 뛰어난 트럭 운전사를 고용해도 ktx나 srt 고속 열차처럼 시속 300km로 운행할 수 없는 것과 마찬가지이다.\n이런 압도적인 성능은 고성능 프록시에서 매력적이고, 당연히 isp 등지에서 눈독들일 수밖에 없는 기술이다.\n\n직접 실행해보려면, arm64 머신에서도 어셈블리 최적화가 쓰이고, 커널에 부착 시 attach type을 명시하게 개선한 공부용 예제를 사용해 보자.\n\n[벤치마크 소스](https://github.com/gg582/cloudflare-study/tree/main/ebpf-sockmap)\n\n대기업의 코드 컨벤션이나 품질을 엿볼 수 있는 귀중한 자료다. 꼼꼼하게 읽어 보고 개선점을 더 찾아보면 공부가 된다.\n\n\n## 마치며\n적절하다고 생각한 비유에 생선을 사용해 보니 차이를 이해하기가 쉬웠고, 어떻게 보면 맛있는 공부가 되었다.\n네트워크에 대해 잘 모르는 나와 같은 초심자도 이러한 공부를 해보면 재미있으니, 꾸준히 네트워크 게시판에 포스팅하도록 하겠다.\n"
    },
    {
      "title": "비전공자도 쉽게 따라하는 리눅스 커널 해킹-지터를 잡아보자",
      "subtitle": "네트워크 지터 개선을 위한 리눅스 커널 튜닝",
      "description": null,
      "url": "/network/2025-12-08-비전공자도-쉽게-따라하는-리눅스-커널-해킹-지터를-잡아보자",
      "collection": "network",
      "relative_path": "2025-12-08-비전공자도-쉽게-따라하는-리눅스-커널-해킹-지터를-잡아보자",
      "date": "2025-12-08T21:00:00+09:00",
      "updated": null,
      "keywords": [
        "리눅스 커널",
        "네트워크 튜닝",
        "지터",
        "커널 해킹",
        "성능 최적화"
      ],
      "categories": [
        "network"
      ],
      "taxonomy": {
        "category": "network",
        "subcategory": "network-performance",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "--- 해킹의 종류는 여러가지 보통 해킹이라고 하면 어나니머스와 같은 사이버 범죄집단을 생각하는 경우가 많다. 그러나 화이트해킹, 블랙해킹, 정보보호, 어딘가 불쾌한 어나니머스 로고, 자신감 넘치는 체크무늬 남방의 괴짜... 실제로 리눅스의 이미지에 그러한 집단들이 많은 영향을 미쳤다. 인정하고 싶지는 않지만 그런 괴짜들이 빠지면 리눅스 데스크톱의 존립이 휘청일 지경이다. 그러한 것들만이 해킹은 아닐 뿐더러, 리눅스 해킹의 영역도 그게 다가 아니다. 실제로 용도에 맞게 범용 리눅스 커널을 특화해서…",
      "search_text": "비전공자도 쉽게 따라하는 리눅스 커널 해킹-지터를 잡아보자 네트워크 지터 개선을 위한 리눅스 커널 튜닝 리눅스 커널 네트워크 튜닝 지터 커널 해킹 성능 최적화 network network network-performance --- 해킹의 종류는 여러가지 보통 해킹이라고 하면 어나니머스와 같은 사이버 범죄집단을 생각하는 경우가 많다. 그러나 화이트해킹, 블랙해킹, 정보보호, 어딘가 불쾌한 어나니머스 로고, 자신감 넘치는 체크무늬 남방의 괴짜... 실제로 리눅스의 이미지에 그러한 집단들이 많은 영향을 미쳤다. 인정하고 싶지는 않지만 그런 괴짜들이 빠지면 리눅스 데스크톱의 존립이 휘청일 지경이다. 그러한 것들만이 해킹은 아닐 뿐더러, 리눅스 해킹의 영역도 그게 다가 아니다. 실제로 용도에 맞게 범용 리눅스 커널을 특화해서… \n\n---\n\n# 해킹의 종류는 여러가지\n보통 해킹이라고 하면 어나니머스와 같은 사이버 범죄집단을 생각하는 경우가 많다.\n그러나 화이트해킹, 블랙해킹, 정보보호, 어딘가 불쾌한 어나니머스 로고, 자신감 넘치는 체크무늬 남방의 괴짜...\n실제로 리눅스의 이미지에 그러한 집단들이 많은 영향을 미쳤다. 인정하고 싶지는 않지만 그런 괴짜들이 빠지면 리눅스 데스크톱의 존립이 휘청일 지경이다.\n\n그러한 것들만이 해킹은 아닐 뿐더러, 리눅스 해킹의 영역도 그게 다가 아니다.\n\n실제로 용도에 맞게 범용 리눅스 커널을 특화해서 뜯어고치거나, 개인적인 용도로 튜닝하는 것도 해킹이라고 부른다.\n이번에 우리가 다룰 것도 그런 보안과 별 관련도 없고, 너드, 긱 문화와도 별다른 상관이 없는 시스템 해킹의 영역이다.\n손쉬운 튜닝으로 스팀 게임에서 핑이 튀지 않게 방지해 보자. 아마 스팀 덱에서도 잘하면 이식이 될 것이다.\n\n> 여기서 \"비전공자\"라고 하는 건, c 기본 문법과 리눅스 커널 빌드/설치를 직접 해본 적은 있는 사람 정도를 상정한다. cs 전공이 아니어도 \"각오하고\" 따라갈 수 있는 수준이라고 이해하면 된다.\n\n# 리눅스 커널을 수정해 보자\n\n많은 경우, 리눅스 커널을 수정하는 것은 아주 어려운 일이라고 생각한다. 어떤 파트에 있어서는 확실히 그러하다. 그러나 어떠한 파트에선 그렇지 않다.\n이번에 다뤄볼 것은 네트워크 핑이 팍 튀어버리는 지터를 잡는 가벼운 커널 해킹이다.\n\n핑이 팍 튈 때, voip 등의 거창한 상황을 가정하지 않아도 lan에서 뚝 끊어지는 느낌이 있을 수밖에 없다. 이럴 때는 빠르다 튀었다 하는 네트워크 응답보다는 적당한 속도로 지터 없이 응답하는 것이 낫다.\n여기서는 \"완전한 최적화\"보다는 \"지터를 줄이는 방향으로 라우팅 경로 선택을 살짝 손대는 것\"을 목표로 한다.\n\n---\n\n## 문제 설정: 지터와 멀티패스 라우팅\n\n리눅스 커널은 ecmp(동일 비용 멀티패스) 라우팅이 가능하다. 즉, 동일한 비용을 가진 여러 경로가 있을 때, 해시 기반으로 적당히 분산해서 트래픽을 보낸다.\n이때 각 경로의 품질(지연, 지터, 실제 처리량)은 동일하지 않을 수 있다.\n\n* 어떤 경로는 rtt가 안정적인 대신 약간 느릴 수 있다.\n* 어떤 경로는 rtt 평균은 빠른데, 순간적으로 튀는 구간이 많을 수 있다.\n\n게이밍, 스트리밍, 실시간 상호작용에서는 평균 속도보다 **안정성(지터)** 이 더 체감된다.\n그렇다면 \"지터와 부하에 대한 지표를 경로마다 추적해서, 그걸 점수(score)로 만들어 ecmp 선택 로직에 살짝 개입\"하면 어떨까?\n\n---\n\n## 알고리즘 수립\n\n아이디어는 단순하다.\n\n* 커널이 실제로 패킷을 전송할 때마다, 사용한 `dst_entry`에 경로별 메트릭을 기록한다.\n* 이 메트릭을 지수이동평균(ema)로 누적해서 \"부드럽게\" 추적한다.\n* 멀티패스 라우팅에서 nexthop을 고를 때, 이 메트릭을 조합한 **점수(score)** 를 참고해서 기존 해시 기반 선택에 약간의 편향을 준다.\n\n### 개념 정리\n\n<img src=\"/assets/images/ktune_ping_diagram.png\" style=\"max-width:70%; height: auto;\"/>\n<img src=\"/assets/images/ktune_ping_diagram_class.png\" style=\"max-width:70%; height: auto;\"/>\n\n1. **라우팅 레벨에서 할 일**\n\n   * rtable/rt6\\_info 등 `dst_entry` 기반의 데이터 구조에 메트릭을 붙인다.\n   * 멀티패스 선택 함수(`fib_select_multipath`, ipv6의 경우 route scoring)에 메트릭에서 나온 점수를 반영한다.\n\n2. **메트릭 설계**\n\n   여기서는 \"값이 크면 무조건 나쁘다/좋다\" 같은 강한 의미를 주기보다는,  \n   **경로 상태를 대략 숫자로 표현해서, 그 숫자를 이용해 점수를 만들기 위한 재료**라는 느낌으로 보면 된다.\n\n   * `ema_load`: 단위 시간당 전송 바이트 수를 ema로 누적한 값  \n     -> \"이 경로가 어느 정도 활동을 하고 있는지\"를 대략 나타낸다.\n   * `ema_time_delta`: 현재 부하와 ema 부하의 차이를 ema로 누적한 값  \n     -> \"최근에 어느 정도 변화가 있었는지(변동성)\"를 나타낸다.\n   * `power_cost_weight`: 이 링크에 대한 비용/선호도 계수  \n     -> 위 두 값을 어떻게 반영할지 조절하는 노브 역할을 한다.  \n        (지금 글에서의 실험은 모든 경로에 같은 값을 줬고, 환경에 따라 다르게 줄 수도 있다.)\n\n   실제로는 `ema_load`, `ema_time_delta`, `power_cost_weight`를 조합해서 **\"값이 클수록 현재 환경에서 그 경로를 더 선호하도록 만드는 점수\"** 로 쓰게 된다.  \n   즉, \"부하가 많으니 무조건 덜 써야 한다\" 같은 이론적인 해석보다는, **실측 환경에서 잘 동작하는 경험적 스코어**라고 보는 쪽이 가깝다.\n\n3. **ema 업데이트**\n\n   * 기본적인 ema 공식:\n\n     ```c\n     newema = (k * new + (1 - k) * old)\n     ```\n\n   * 커널에서는 1024 스케일의 고정소수점으로 처리해서 나눗셈을 줄인다.\n\n   * 복잡하지 않으니 매크로로 치환한다.\n\n---\n\n## 유의사항\n\n먼저, 구조체를 건드릴 때 가장 주의해야 할 부분이다.\n\n```diff\n--- a/include/net/dst.h\n+++ b/include/net/dst.h\n@@ -90,12 +90,19 @@ struct dst_entry {\n \t * frequently accessed members of rtable and rt6_info out of the\n \t * __rcuref cache line.\n \t */\n-\tstruct list_head\trt_uncached;\n-\tstruct uncached_list\t*rt_uncached_list;\n-#ifdef config_64bit\n-\tstruct lwtunnel_state   *lwtstate;\n-#endif\n-};\n+\t        struct list_head        rt_uncached;\n+\t        struct uncached_list    *rt_uncached_list;\n+\t#ifdef config_64bit\n+\t        struct lwtunnel_state   *lwtstate;\n+\t#endif\n+\t        /* user added: start of power-aware routing metrics */\n+\t        u64 ema_load;\n+\t        u64 ema_time_delta;\n+\t        u64 last_update_jiffies;\n+\t        unsigned int ema_k_factor;\n+\t        unsigned int power_cost_weight;\n+\t        /* user added: end of power-aware routing metrics */\n+\t};\n````\n\n* 커널 구조체의 **패딩, 캐시라인, abi** 는 매우 중요하다.\n* `dst_entry`는 네트워킹의 핵심 구조체라 인라인/캐시 레이아웃을 망가뜨리면 성능에 큰 영향을 줄 수 있다.\n* 안전하게 가려면:\n\n  * 새 필드는 구조체 **맨 끝에** 몰아서 넣는다.\n  * 크기가 너무 커서 cacheline이나 page를 넘어가지 않도록 유의한다.\n  * 특히 모듈/외부 코드가 `sizeof(struct dst_entry)`에 의존하는 일이 없는지 확인해야 한다.\n\n잘 모르겠으면, 하나의 구조체가 적당한 수의 4kb 페이지 안에 들어가도록 설계하는 편이 낫다.\n64bit amd64/ia64 컴퓨터는 4k kernel page를 기본으로 쓰도록 설계되어 있으므로, 4096 단위로 생각하면 읽기 편하다.\n\n---\n\n## 세부사항: ema 매크로\n\n```c\n#define ema_update(k, old, new) (((k) * (new) + (1024 - (k)) * (old)) / 1024)\n```\n\n* `k`는 0~1024 사이의 값이다.\n\n  * 0에 가까우면 과거 값(old)을 더 신뢰 -> 변화에 둔감하다.\n  * 1024에 가까우면 최근 값(new)을 더 신뢰 -> 변화에 민감하다.\n* `/ 1024`로 나누는 이유는 부동소수점 대신 정수 기반 고정소수점 연산을 쓰기 위해서다.\n\nema 업데이트의 특징은 다음과 같다.\n\n* 갑작스런 튀는 값(스파이크)에 대해 완전히 따라가지 않고, 완만하게 따라간다.\n* 그래도 시간이 지나면 점점 새 값에 수렴한다.\n* 커널 안에서 부동소수점 연산은 금지되므로, 이런 형태가 거의 표준처럼 쓰인다.\n\n---\n\n## 구현: 어디를 어떻게 건드렸는가?\n\n이제 실제 패치를 보자.\n차이는 다음과 같은 요소로 나눌 수 있다.\n\n1. `dst_entry`에 ema/코스트 필드 추가\n2. 네트워크 디바이스 전송 경로에서 메트릭 업데이트\n3. ipv4/ipv6 멀티패스 라우팅에서 score 반영\n4. sysctl(튜닝 파라미터) 추가\n5. (덤) 락 처리 간단화\n\n### 1. netdevice 락 간단화\n\n```diff\ndiff --git a/include/linux/netdevice.h b/include/linux/netdevice.h\nindex 5870a9e51..cb08b9a8f 100644\n--- a/include/linux/netdevice.h\n+++ b/include/linux/netdevice.h\n@@ -4855,13 +4855,10 @@ static inline void netif_addr_lock(struct net_device *dev)\n \n static inline void netif_addr_lock_bh(struct net_device *dev)\n {\n-\tunsigned char nest_level = 0;\n-\n #ifdef config_lockdep\n \tnest_level = dev->nested_level;\n #endif\n-\tlocal_bh_disable();\n-\tspin_lock_nested(&dev->addr_list_lock, nest_level);\n+\tspin_lock_bh(&dev->addr_list_lock);\n }\n```\n\n이 부분은 지터와 직접적인 관련은 없지만, 주소 리스트 락을 잡는 부분을 간단하게 정리한 것이다.\n\n* 기존에는 `local_bh_disable()` / `spin_lock_nested()` 조합으로 구현되어 있었다.\n* `spin_lock_bh()`는 softirq bottom half 디스에이블과 스핀락 획득을 한 번에 처리해주는 헬퍼다.\n* **기존의 코드 그대로 써도 상관은 없다. 일단 넘어가도 된다.**\n* 이 글의 핵심은 아니지만, 커널 코드를 읽으면서 자주 마주치는 패턴이라 같이 적어둔다.\n\n### 2. dst_entry 확장 및 ema 필드\n\n앞서 본 것처럼 `dst_entry` 끝에 ema용 필드를 추가한다.\n여기에 ema 계수(`ema_k_factor`), power cost (`power_cost_weight`)도 함께 넣는다.\n\n### 3. 전송 시점에서 메트릭 업데이트\n\n핵심은 패킷이 실제로 전송되는 경로(`dev_hard_start_xmit`)에서 `dst_entry`를 꺼내 메트릭을 갱신하는 것이다.\n\n```diff\ndiff --git a/net/core/dev.c b/net/core/dev.c\nindex 9094c0fb8..e3f677aa9 100644\n--- a/net/core/dev.c\n+++ b/net/core/dev.c\n@@ -68,6 +68,8 @@\n  *\t\t\t\t        - netif_rx() feedback\n  */\n \n+#define ema_update(k, old, new) (((k) * (new) + (1024 - (k)) * (old)) / 1024)\n+\n@@ -172,6 +174,7 @@ static define_spinlock(ptype_lock);\n struct list_head ptype_base[ptype_hash_size] __read_mostly;\n \n static int netif_rx_internal(struct sk_buff *skb);\n+static void update_dst_ems_metrics(struct dst_entry *dst, unsigned int tx_bytes);\n@@ -3867,6 +3870,12 @@ struct sk_buff *dev_hard_start_xmit(struct sk_buff *first, struct net_device *de\n \n \t\tskb_mark_not_on_list(skb);\n \t\trc = xmit_one(skb, dev, txq, next != null);\n+\t\tif (likely(dev_xmit_complete(rc))) {\n+\t\t\tstruct dst_entry *dst = skb_dst(skb);\n+\t\t\tif (dst)\n+\t\t\t\tupdate_dst_ems_metrics(dst, skb->len);\n+\t\t}\n+\n```\n\n* 패킷 전송이 성공(`dev_xmit_complete`)했을 때만 메트릭을 업데이트한다.\n\n  * 패킷 전송 실패까지 굳이 반영하려면 별도 설계를 해야 하고, 그만큼 복잡도가 오른다.\n* `skb_dst(skb)`로 이 패킷이 사용한 `dst_entry`를 얻는다.\n* `tx_bytes`는 단순히 `skb->len`.\n\n실제 ema 갱신 로직은 아래와 같다.\n\n```diff\n+static void update_dst_ems_metrics(struct dst_entry *dst, unsigned int tx_bytes)\n+{\n+\tu64 cur_jiffies = get_jiffies_64();\n+\tu64 delta_t = cur_jiffies - read_once(dst->last_update_jiffies);\n+\tu64 cur_load_rate;\n+\n+\tif (!delta_t)\n+\t\treturn;\n+\n+\tcur_load_rate = tx_bytes / delta_t;\n+\n+\twrite_once(dst->ema_load, ema_update(read_once(dst->ema_k_factor), read_once(dst->ema_load),\n+\t\t\t\t   cur_load_rate));\n+\n+\tu64 diff;\n+\tif (cur_load_rate > read_once(dst->ema_load))\n+\t\tdiff = cur_load_rate - read_once(dst->ema_load);\n+\telse\n+\t\tdiff = read_once(dst->ema_load) - cur_load_rate;\n+\n+\twrite_once(dst->ema_time_delta, ema_update(read_once(dst->ema_k_factor),\n+\t\t\t\t\t read_once(dst->ema_time_delta),\n+\t\t\t\t\t diff));\n+\twrite_once(dst->last_update_jiffies, cur_jiffies);\n+}\n```\n\n여기서 중요한 포인트:\n\n* `jiffies`를 기반으로 단순한 \"바이트/시간\" 레이트를 계산한다.\n* `ema_load`는 이 레이트의 ema이다.\n* `ema_time_delta`는 레이트와 ema의 차이(=변동성)의 ema.\n* `read_once` / `write_once`는 경쟁 상태에서 이상한 최적화를 막기 위한 매크로로, 커널 코드에서 거의 관용적으로 사용한다.\n\n> 주의: `last_update_jiffies` 초기값이 0이기 때문에, **맨 처음 한두 번 업데이트에서는 \"부팅 이후 전체 시간\"이 분모에 들어가는 편향**이 생긴다.\n> 이 글의 측정은 부팅 후 어느 정도 시간이 지난 뒤에, 충분히 많은 패킷을 흘려보낸 상태에서 진행했기 때문에 그 초기 편향이 결과에는 크게 영향을 주지 않았다.\n\n### 4. ipv4 멀티패스에서 score 반영\n\n`fib_select_multipath`는 ipv4 ecmp에서 nexthop을 고르는 핵심 함수다.\n여기에 `calculate_lowpower_weight()`를 끼워 넣어서, 기존 해시 기반 선택에 앞서 한 번 score를 보고 개입한다.\n\n```diff\ndiff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c\n@@ -84,6 +84,24 @@\n \n #define endfor_nexthops(fi) }\n \n+static inline struct dst_entry *get_dst_entry_from_nhc(struct fib_nh_common *nhc)\n+{\n+\tif (!nhc || !nhc->nhc_pcpu_rth_output)\n+\t\treturn null;\n+\n+\tstruct rtable *rt = rcu_dereference(*this_cpu_ptr(nhc->nhc_pcpu_rth_output));\n+\treturn rt ? &rt->dst : null;\n+}\n+\n+static inline long calculate_lowpower_weight(struct dst_entry *dst)\n+{\n+\tif (!dst)\n+\t\treturn 0;\n+\n+\treturn (dst->ema_load + dst->ema_time_delta) * dst->power_cost_weight;\n+}\n```\n\n* per-cpu rtable에서 `dst_entry`를 꺼내서 score(여기서는 weight라는 이름) 를 계산한다.\n* `ema_load + ema_time_delta`에 `power_cost_weight`를 곱한 값이 이 구현에서의 스코어다.\n\n  * 수식만 보면 \"부하 + 변동성\" 느낌이지만, 실제로는 ema 계수와 트래픽 패턴에 따라 **\"적당히 안정적이고 샘플이 충분히 쌓인 경로의 점수\"** 쪽으로 작동하도록 튜닝한 경험적 값이라고 보는 게 더 가깝다.\n\n실제 선택 로직:\n\n```diff\n@@ -2161,15 +2179,19 @@ static bool fib_good_nh(const struct fib_nh *nh)\n \n \treturn !!(state & nud_valid);\n }\n+#endif\n \n+#ifdef config_ip_route_multipath\n void fib_select_multipath(struct fib_result *res, int hash,\n \t\t\t  const struct flowi4 *fl4)\n {\n \tstruct fib_info *fi = res->fi;\n \tstruct net *net = fi->fib_net;\n-\tbool found = false;\n \tbool use_neigh;\n \t__be32 saddr;\n+\tint found;\n+\tint lowpower_nh_index = -1;\n+\tlong max_ema_weight = -1;\n@@ -2178,37 +2200,54 @@ void fib_select_multipath(struct fib_result *res, int hash,\n \n \tuse_neigh = read_once(net->ipv4.sysctl_fib_multipath_use_neigh);\n \tsaddr = fl4 ? fl4->saddr : 0;\n+\tfound = 0;\n \n \tchange_nexthops(fi) {\n-\t\tint nh_upper_bound;\n+\t\tstruct dst_entry *dst;\n+\t\tlong current_weight;\n@@\n+\t\tdst = get_dst_entry_from_nhc(&nexthop_nh->nh_common);\n+\t\tcurrent_weight = calculate_lowpower_weight(dst);\n+\n+\t\tif (current_weight > max_ema_weight) {\n+\t\t\tmax_ema_weight = current_weight;\n+\t\t\tlowpower_nh_index = nhsel;\n+\t\t}\n+\t} endfor_nexthops(fi);\n+\n+\tif (lowpower_nh_index != -1) {\n+\t\tres->nh_sel = lowpower_nh_index;\n+\t\tres->nhc = fib_info_nhc(fi, lowpower_nh_index);\n+\t\treturn;\n+\t}\n+\n+\tchange_nexthops(fi) {\n@@\n \t} endfor_nexthops(fi);\n+\n+\tif (!found) {\n+\t\tres->nh_sel = 0;\n+\t\tres->nhc = &fi->fib_nh->nh_common;\n+\t}\n }\n #endif\n```\n\n전략은 다음과 같다.\n\n1. 먼저 모든 nexthop에 대해 `calculate_lowpower_weight()`를 평가한다.\n2. **여기서 weight(=score)가 가장 큰 nexthop을 우선으로 선택**한다.\n3. 모든 weight가 0이면(아직 트래픽이 거의 흐르지 않은 경우), 기존 `fib_nh_upper_bound` 기반 로직으로 그대로 fallback 한다.\n\n정리하면:\n\n* 이 구현에서의 weight는 \"작을수록 비용이 크다/작다\" 같은 전통적인 의미보다는\n  **\"현재 환경에서, 충분히 샘플이 쌓이고 비교적 안정적인 경로라고 판단되는 정도를 나타내는 스코어\"** 로 보는 쪽이 편하다.\n* 그 스코어가 커진 경로를 먼저 써보고, 그렇지 않은 경우에만 기존 해시 기반 ecmp에 맡기는 구조다.\n\n### 5. ipv4/ipv6 라우트 생성 시 초기화\n\n라우트가 만들어질 때 ema 계수와 코스트를 netns sysctl에서 가져와 초기화한다.\n\n```diff\ndiff --git a/net/ipv4/route.c b/net/ipv4/route.c\n@@ -1666,6 +1666,11 @@ struct rtable *rt_dst_alloc(struct net_device *dev,\n \t\trt->dst.output = ip_output;\n \t\tif (flags & rtcf_local)\n \t\t\trt->dst.input = ip_local_deliver;\n+\n+\t\trt->dst.ema_k_factor = dev_net(dev)->ipv4.sysctl_lowpower_ema_k_factor;\n+\t\trt->dst.power_cost_weight = dev_net(dev)->ipv4.sysctl_lowpower_power_cost_weight;\n+\t\t           write_once(rt->dst.ema_load, 0);\t\trt->dst.ema_time_delta = 0;\n+\t\trt->dst.last_update_jiffies = 0;\n \t}\n```\n\nipv6에서도 동일한 초기화를 해준다.\n\n```diff\ndiff --git a/net/ipv6/route.c b/net/ipv6/route.c\n@@ -344,6 +344,10 @@ struct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,\n \n \tif (rt) {\n \t\trt6_info_init(rt);\n+\t\t                write_once(rt->dst.ema_k_factor, read_once(net->ipv4.sysctl_lowpower_ema_k_factor));\n+\t\t                write_once(rt->dst.power_cost_weight, read_once(net->ipv4.sysctl_lowpower_power_cost_weight));\n+\t\t                write_once(rt->dst.ema_load, 0);\n+\t\t                write_once(rt->dst.ema_time_delta, 0);\t\trt->dst.last_update_jiffies = 0;\n \t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n \t}\n```\n\n여기서 눈여겨볼 부분:\n\n* ipv6에서도 ipv4 네임스페이스의 lowpower sysctl 값을 재활용한다.\n* 결국 ipv4/ipv6가 동일한 튜닝 파라미터를 공유한다.\n\n### 6. weight를 다른 프로토콜에서 활용\n\nsctp나 xfrm 정책 등에서도 동일한 메트릭을 재사용할 수 있다.\n예시로 sctp의 outqueue, xfrm bundle 생성 시점에 weight/ema를 설정하는 부분이 있다.\n\n(아래 diff는 \"이렇게도 재활용할 수 있다\"는 예시일 뿐, 이 글의 지터 측정에는 직접적인 영향을 주지 않는다.)\n\n```diff\ndiff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c\n@@ -1432,6 +1432,13 @@ int sctp_outq_is_empty(const struct sctp_outq *q)\n@@ -2702,6 +2702,12 @@ static struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,\n```\n\n---\n\n## sysctl로 튜닝하기\n\nema 계수와 power cost는 sysctl로 노출해서 런타임에 조정할 수 있게 했다.\n\n```diff\ndiff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h\n@@ -235,6 +235,11 @@ struct netns_ipv4 {\n \tu32 tcp_challenge_timestamp;\n \tu32 tcp_challenge_count;\n \tu8 sysctl_tcp_plb_enabled;\n+\n+\t/* low power settings */\n+\tint sysctl_lowpower_ema_k_factor;\n+\tint sysctl_lowpower_power_cost_weight;\n+\n```\n\n```diff\ndiff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c\n@@ -42,6 +42,9 @@ static u32 u32_max_div_hz = uint_max / hz;\n@@ -1607,6 +1610,22 @@ static struct ctl_table ipv4_net_table[] = {\n+\t{\n+\t\t.procname\t= \"lowpower_ema_k_factor\",\n+\t\t.data\t\t= &init_net.ipv4.sysctl_lowpower_ema_k_factor,\n@@\n+\t{\n+\t\t.procname\t= \"lowpower_power_cost_weight\",\n+\t\t.data\t\t= &init_net.ipv4.sysctl_lowpower_power_cost_weight,\n@@\n@@ -1682,6 +1701,9 @@ static __net_init int ipv4_sysctl_init_net(struct net *net)\n \n \tproc_fib_multipath_hash_set_seed(net, 0);\n \n+\tnet->ipv4.sysctl_lowpower_ema_k_factor = 512;\n+\tnet->ipv4.sysctl_lowpower_power_cost_weight = 100;\n+\n \treturn 0;\n```\n\n사용 예시는 다음과 같다.\n\n```bash\n# ema를 조금 더 민감하게 (최근 값 반영 비중 ↑)\nsysctl -w net.ipv4.lowpower_ema_k_factor=800\n\n# power cost에 다른 값을 주면서, ema 기반 score가 얼마나 영향력을 가지는지 조절\nsysctl -w net.ipv4.lowpower_power_cost_weight=200\n```\n\n* `lowpower_ema_k_factor`: 0~1024 범위, 기본 512\n  -> 중간 정도의 응답성을 가진 ema.\n* `lowpower_power_cost_weight`: 기본 100\n  -> 위에서 계산한 ema 기반 score에 대한 전체 스케일을 조절하는 노브.\n  (이 글에서는 모든 경로에 동일한 값을 두고, 환경에 맞는 값은 직접 실험해 선택했다.)\n\n---\n\n## 실제 패치 전체(diff)\n\n모든 변경사항을 한 번에 보고 싶은 경우를 위해 전체 diff를 붙여둔다.\n\n> 아래 diff는 **실제로 측정에 사용한 코드 그대로**이며, 본문 설명은 이 코드 기준으로 작성되었다.\n\n```diff\ndiff --git a/include/linux/netdevice.h b/include/linux/netdevice.h\nindex 5870a9e51..cb08b9a8f 100644\n--- a/include/linux/netdevice.h\n+++ b/include/linux/netdevice.h\n@@ -4855,13 +4855,10 @@ static inline void netif_addr_lock(struct net_device *dev)\n\n static inline void netif_addr_lock_bh(struct net_device *dev)\n {\n-\tunsigned char nest_level = 0;\n-\n #ifdef config_lockdep\n \tnest_level = dev->nested_level;\n #endif\n-\tlocal_bh_disable();\n-\tspin_lock_nested(&dev->addr_list_lock, nest_level);\n+\tspin_lock_bh(&dev->addr_list_lock);\n }\n\n static inline void netif_addr_unlock(struct net_device *dev)\ndiff --git a/include/net/dst.h b/include/net/dst.h\nindex f8aa1239b..64845ee1f 100644\n--- a/include/net/dst.h\n+++ b/include/net/dst.h\n@@ -90,12 +90,19 @@ struct dst_entry {\n \t * frequently accessed members of rtable and rt6_info out of the\n \t * __rcuref cache line.\n \t */\n-\tstruct list_head\trt_uncached;\n-\tstruct uncached_list\t*rt_uncached_list;\n-#ifdef config_64bit\n-\tstruct lwtunnel_state   *lwtstate;\n-#endif\n-};\n+\t        struct list_head        rt_uncached;\n+\t        struct uncached_list    *rt_uncached_list;\n+\t#ifdef config_64bit\n+\t        struct lwtunnel_state   *lwtstate;\n+\t#endif\n+\t        /* user added: start of power-aware routing metrics */\n+\t        u64 ema_load;\n+\t        u64 ema_time_delta;\n+\t        u64 last_update_jiffies;\n+\t        unsigned int ema_k_factor;\n+\t        unsigned int power_cost_weight;\n+\t        /* user added: end of power-aware routing metrics */\n+\t};\n\n struct dst_metrics {\n \tu32\t\tmetrics[rtax_max];\ndiff --git a/include/net/netns/ipv4.h b/include/net/netns/ipv4.h\nindex 2dbd46fc4..515c8f741 100644\n--- a/include/net/netns/ipv4.h\n+++ b/include/net/netns/ipv4.h\n@@ -235,6 +235,11 @@ struct netns_ipv4 {\n \tu32 tcp_challenge_timestamp;\n \tu32 tcp_challenge_count;\n \tu8 sysctl_tcp_plb_enabled;\n+\n+\t/* low power settings */\n+\tint sysctl_lowpower_ema_k_factor;\n+\tint sysctl_lowpower_power_cost_weight;\n+\n \tu8 sysctl_tcp_plb_idle_rehash_rounds;\n \tu8 sysctl_tcp_plb_rehash_rounds;\n \tu8 sysctl_tcp_plb_suspend_rto_sec;\ndiff --git a/net/core/dev.c b/net/core/dev.c\nindex 9094c0fb8..e3f677aa9 100644\n--- a/net/core/dev.c\n+++ b/net/core/dev.c\n@@ -68,6 +68,8 @@\n  *\t\t\t\t        - netif_rx() feedback\n  */\n\n+#define ema_update(k, old, new) (((k) * (new) + (1024 - (k)) * (old)) / 1024)\n+\n #include <linux/uaccess.h>\n #include <linux/bitmap.h>\n #include <linux/capability.h>\n@@ -172,6 +174,7 @@ static define_spinlock(ptype_lock);\n struct list_head ptype_base[ptype_hash_size] __read_mostly;\n\n static int netif_rx_internal(struct sk_buff *skb);\n+static void update_dst_ems_metrics(struct dst_entry *dst, unsigned int tx_bytes);\n static int call_netdevice_notifiers_extack(unsigned long val,\n \t\t\t\t\t   struct net_device *dev,\n \t\t\t\t\t   struct netlink_ext_ack *extack);\n@@ -3867,6 +3870,12 @@ struct sk_buff *dev_hard_start_xmit(struct sk_buff *first, struct net_device *de\n\n \t\tskb_mark_not_on_list(skb);\n \t\trc = xmit_one(skb, dev, txq, next != null);\n+\t\tif (likely(dev_xmit_complete(rc))) {\n+\t\t\tstruct dst_entry *dst = skb_dst(skb);\n+\t\t\tif (dst)\n+\t\t\t\tupdate_dst_ems_metrics(dst, skb->len);\n+\t\t}\n+\n \t\tif (unlikely(!dev_xmit_complete(rc))) {\n \t\t\tskb->next = next;\n \t\t\tgoto out;\n@@ -13274,4 +13283,30 @@ static int __init net_dev_init(void)\n \treturn rc;\n }\n\n+static void update_dst_ems_metrics(struct dst_entry *dst, unsigned int tx_bytes)\n+{\n+\tu64 cur_jiffies = get_jiffies_64();\n+\tu64 delta_t = cur_jiffies - read_once(dst->last_update_jiffies);\n+\tu64 cur_load_rate;\n+\n+\tif (!delta_t)\n+\t\treturn;\n+\n+\tcur_load_rate = tx_bytes / delta_t;\n+\n+\twrite_once(dst->ema_load, ema_update(read_once(dst->ema_k_factor), read_once(dst->ema_load),\n+\t\t\t\t   cur_load_rate));\n+\n+\tu64 diff;\n+\tif (cur_load_rate > read_once(dst->ema_load))\n+\t\tdiff = cur_load_rate - read_once(dst->ema_load);\n+\telse\n+\t\tdiff = read_once(dst->ema_load) - cur_load_rate;\n+\n+\twrite_once(dst->ema_time_delta, ema_update(read_once(dst->ema_k_factor),\n+\t\t\t\t\t read_once(dst->ema_time_delta),\n+\t\t\t\t\t diff));\n+\twrite_once(dst->last_update_jiffies, cur_jiffies);\n+}\n+\n subsys_initcall(net_dev_init);\ndiff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c\nindex a5f3c8459..16a894414 100644\n--- a/net/ipv4/fib_semantics.c\n+++ b/net/ipv4/fib_semantics.c\n@@ -84,6 +84,24 @@\n\n #define endfor_nexthops(fi) }\n\n+static inline struct dst_entry *get_dst_entry_from_nhc(struct fib_nh_common *nhc)\n+{\n+\tif (!nhc || !nhc->nhc_pcpu_rth_output)\n+\t\treturn null;\n+\n+\tstruct rtable *rt = rcu_dereference(*this_cpu_ptr(nhc->nhc_pcpu_rth_output));\n+\treturn rt ? &rt->dst : null;\n+}\n+\n+static inline long calculate_lowpower_weight(struct dst_entry *dst)\n+{\n+\tif (!dst)\n+\t\treturn 0;\n+\n+\treturn (dst->ema_load + dst->ema_time_delta) * dst->power_cost_weight;\n+}\n+\n+\n\n const struct fib_prop fib_props[rtn_max + 1] = {\n \t[rtn_unspec] = {\n@@ -2161,15 +2179,19 @@ static bool fib_good_nh(const struct fib_nh *nh)\n\n \treturn !!(state & nud_valid);\n }\n+#endif\n\n+#ifdef config_ip_route_multipath\n void fib_select_multipath(struct fib_result *res, int hash,\n \t\t\t  const struct flowi4 *fl4)\n {\n \tstruct fib_info *fi = res->fi;\n \tstruct net *net = fi->fib_net;\n-\tbool found = false;\n \tbool use_neigh;\n \t__be32 saddr;\n+\tint found;\n+\tint lowpower_nh_index = -1;\n+\tlong max_ema_weight = -1;\n\n \tif (unlikely(res->fi->nh)) {\n \t\tnexthop_path_fib_result(res, hash);\n@@ -2178,37 +2200,54 @@ void fib_select_multipath(struct fib_result *res, int hash,\n\n \tuse_neigh = read_once(net->ipv4.sysctl_fib_multipath_use_neigh);\n \tsaddr = fl4 ? fl4->saddr : 0;\n+\tfound = 0;\n\n \tchange_nexthops(fi) {\n-\t\tint nh_upper_bound;\n+\t\tstruct dst_entry *dst;\n+\t\tlong current_weight;\n\n-\t\t/* nexthops without a carrier are assigned an upper bound of\n-\t\t * minus one when \"ignore_routes_with_linkdown\" is set.\n-\t\t */\n-\t\tnh_upper_bound = atomic_read(&nexthop_nh->fib_nh_upper_bound);\n-\t\tif (nh_upper_bound == -1 ||\n+\t\tif ((nexthop_nh->fib_nh_flags & rtnh_f_dead) ||\n+\t\t    (ip_ignore_linkdown(nexthop_nh->fib_nh_dev) &&\n+\t\t     (nexthop_nh->fib_nh_flags & rtnh_f_linkdown)) ||\n \t\t    (use_neigh && !fib_good_nh(nexthop_nh)))\n \t\t\tcontinue;\n\n-\t\tif (!found) {\n-\t\t\tres->nh_sel = nhsel;\n-\t\t\tres->nhc = &nexthop_nh->nh_common;\n-\t\t\tfound = !saddr || nexthop_nh->nh_saddr == saddr;\n+\t\tdst = get_dst_entry_from_nhc(&nexthop_nh->nh_common);\n+\t\tcurrent_weight = calculate_lowpower_weight(dst);\n+\n+\t\tif (current_weight > max_ema_weight) {\n+\t\t\tmax_ema_weight = current_weight;\n+\t\t\tlowpower_nh_index = nhsel;\n \t\t}\n+\t} endfor_nexthops(fi);\n\n-\t\tif (hash > nh_upper_bound)\n-\t\t\tcontinue;\n+\tif (lowpower_nh_index != -1) {\n+\t\tres->nh_sel = lowpower_nh_index;\n+\t\tres->nhc = fib_info_nhc(fi, lowpower_nh_index);\n+\t\treturn;\n+\t}\n+\n+\tchange_nexthops(fi) {\n+\t\tint nh_upper_bound;\n+\n+\t\tnh_upper_bound = atomic_read(&nexthop_nh->fib_nh_upper_bound);\n\n-\t\tif (!saddr || nexthop_nh->nh_saddr == saddr) {\n+\t\tif ((nh_upper_bound != -1) && (hash <= nh_upper_bound) &&\n+\t\t    !((nexthop_nh->fib_nh_flags & rtnh_f_dead)) &&\n+\t\t    !(ip_ignore_linkdown(nexthop_nh->fib_nh_dev) &&\n+\t\t      (nexthop_nh->fib_nh_flags & rtnh_f_linkdown)) &&\n+\t\t    !(use_neigh && !fib_good_nh(nexthop_nh))) {\n \t\t\tres->nh_sel = nhsel;\n \t\t\tres->nhc = &nexthop_nh->nh_common;\n-\t\t\treturn;\n+\t\t\tfound = 1;\n+\t\t\tbreak;\n \t\t}\n-\n-\t\tif (found)\n-\t\t\treturn;\n-\n \t} endfor_nexthops(fi);\n+\n+\tif (!found) {\n+\t\tres->nh_sel = 0;\n+\t\tres->nhc = &fi->fib_nh->nh_common;\n+\t}\n }\n #endif\n\ndiff --git a/net/ipv4/route.c b/net/ipv4/route.c\nindex b549d6a57..30cb75f0b 100644\n--- a/net/ipv4/route.c\n+++ b/net/ipv4/route.c\n@@ -1666,6 +1666,11 @@ struct rtable *rt_dst_alloc(struct net_device *dev,\n \t\trt->dst.output = ip_output;\n \t\tif (flags & rtcf_local)\n \t\t\trt->dst.input = ip_local_deliver;\n+\n+\t\trt->dst.ema_k_factor = dev_net(dev)->ipv4.sysctl_lowpower_ema_k_factor;\n+\t\trt->dst.power_cost_weight = dev_net(dev)->ipv4.sysctl_lowpower_power_cost_weight;\n+\t\t           write_once(rt->dst.ema_load, 0);\t\trt->dst.ema_time_delta = 0;\n+\t\trt->dst.last_update_jiffies = 0;\n \t}\n\n \treturn rt;\ndiff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c\nindex a1a50a5c8..a962843bc 100644\n--- a/net/ipv4/sysctl_net_ipv4.c\n+++ b/net/ipv4/sysctl_net_ipv4.c\n@@ -42,6 +42,9 @@ static u32 u32_max_div_hz = uint_max / hz;\n static int one_day_secs = 24 * 3600;\n static u32 fib_multipath_hash_fields_all_mask __maybe_unused =\n \tfib_multipath_hash_field_all_mask;\n+\n+static unsigned int zero = 0;\n+static unsigned int one_zero_two_four = 1024;\n static unsigned int tcp_child_ehash_entries_max = 16 * 1024 * 1024;\n static unsigned int udp_child_hash_entries_max = udp_htable_size_max;\n static int tcp_plb_max_rounds = 31;\n@@ -1607,6 +1610,22 @@ static struct ctl_table ipv4_net_table[] = {\n \t\t.extra1\t\t= sysctl_zero,\n \t\t.extra2\t\t= &tcp_syn_linear_timeouts_max,\n \t},\n+\t{\n+\t\t.procname\t= \"lowpower_ema_k_factor\",\n+\t\t.data\t\t= &init_net.ipv4.sysctl_lowpower_ema_k_factor,\n+\t\t.maxlen\t\t= sizeof(int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.extra1\t\t= &zero,\n+\t\t.extra2\t\t= &one_zero_two_four\n+\t},\n+\t{\n+\t\t.procname\t= \"lowpower_power_cost_weight\",\n+\t\t.data\t\t= &init_net.ipv4.sysctl_lowpower_power_cost_weight,\n+\t\t.maxlen\t\t= sizeof(int),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_dointvec\n+\t},\n \t{\n \t\t.procname\t= \"tcp_shrink_window\",\n \t\t.data\t\t= &init_net.ipv4.sysctl_tcp_shrink_window,\n@@ -1682,6 +1701,9 @@ static __net_init int ipv4_sysctl_init_net(struct net *net)\n\n \tproc_fib_multipath_hash_set_seed(net, 0);\n\n+\tnet->ipv4.sysctl_lowpower_ema_k_factor = 512;\n+\tnet->ipv4.sysctl_lowpower_power_cost_weight = 100;\n+\n \treturn 0;\n\n err_ports:\ndiff --git a/net/ipv6/route.c b/net/ipv6/route.c\nindex aee6a10b1..241443902 100644\n--- a/net/ipv6/route.c\n+++ b/net/ipv6/route.c\n@@ -344,6 +344,10 @@ struct rt6_info *ip6_dst_alloc(struct net *net, struct net_device *dev,\n\n \tif (rt) {\n \t\trt6_info_init(rt);\n+\t\t                write_once(rt->dst.ema_k_factor, read_once(net->ipv4.sysctl_lowpower_ema_k_factor));\n+\t\t                write_once(rt->dst.power_cost_weight, read_once(net->ipv4.sysctl_lowpower_power_cost_weight));\n+\t\t                write_once(rt->dst.ema_load, 0);\n+\t\t                write_once(rt->dst.ema_time_delta, 0);\t\trt->dst.last_update_jiffies = 0;\n \t\tatomic_inc(&net->ipv6.rt6_stats->fib_rt_alloc);\n \t}\n\n@@ -411,6 +415,22 @@ static bool rt6_check_expired(const struct rt6_info *rt)\n \treturn false;\n }\n\n+static inline struct dst_entry *get_dst_entry_from_fib6_nh(const struct fib6_nh *nh)\n+{\n+\tif (!nh || !nh->rt6i_pcpu)\n+\t\treturn null;\n+\n+\tstruct rt6_info *rt = rcu_dereference(*this_cpu_ptr(nh->rt6i_pcpu));\n+\treturn rt ? &rt->dst : null;\n+}\n+\n+static inline long calculate_lowpower_weight(struct dst_entry *dst)\n+{\n+\tif (!dst)\n+\t\treturn 0;\n+\n+\t    return (read_once(dst->ema_load) + read_once(dst->ema_time_delta)) * read_once(dst->power_cost_weight);}\n+\n static struct fib6_info *\n rt6_multipath_first_sibling_rcu(const struct fib6_info *rt)\n {\n@@ -749,6 +769,7 @@ static int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n \t\t\t   int strict)\n {\n \tint m = 0;\n+\tlong weight;\n\n \tif (!oif || nh->fib_nh_dev->ifindex == oif)\n \t\tm = 2;\n@@ -764,6 +785,10 @@ static int rt6_score_route(const struct fib6_nh *nh, u32 fib6_flags, int oif,\n \t\tif (n < 0)\n \t\t\treturn n;\n \t}\n+\n+\tweight = calculate_lowpower_weight(get_dst_entry_from_fib6_nh(nh));\n+\tif (weight > 0)\n+\t\t\t\t\tm += weight;\n \treturn m;\n }\n\ndiff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c\nindex f6b8c13da..cfcc7807f 100644\n--- a/net/sctp/outqueue.c\n+++ b/net/sctp/outqueue.c\n@@ -1432,6 +1432,13 @@ int sctp_outq_is_empty(const struct sctp_outq *q)\n  * transmitted_queue, we print a range: sacked: tsn1-tsn2, tsn3, tsn4-tsn5.\n  * kept tsn6-tsn7, etc.\n  */\n+static inline long calculate_lowpower_weight(struct dst_entry *dst)\n+{\n+\tif (!dst)\n+\t\treturn 0;\n+\n+\t   return (read_once(dst->ema_load) + read_once(dst->ema_time_delta)) * read_once(dst->power_cost_weight);}\n+\n static void sctp_check_transmitted(struct sctp_outq *q,\n \t\t\t\t   struct list_head *transmitted_queue,\n \t\t\t\t   struct sctp_transport *transport,\n@@ -1499,6 +1506,7 @@ static void sctp_check_transmitted(struct sctp_outq *q,\n \t\t\t\t    tchunk->rtt_in_progress) {\n \t\t\t\t\ttchunk->rtt_in_progress = 0;\n \t\t\t\t\trtt = jiffies - tchunk->sent_at;\n+\n \t\t\t\t\tsctp_transport_update_rto(transport,\n \t\t\t\t\t\t\t\t  rtt);\n \t\t\t\t}\ndiff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c\nindex 62486f866..13aeab10a 100644\n--- a/net/xfrm/xfrm_policy.c\n+++ b/net/xfrm/xfrm_policy.c\n@@ -2702,6 +2702,12 @@ static struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,\n \t\t\tgoto put_states;\n \t\t}\n\n+                write_once(dst1->ema_k_factor, read_once(dev_net(dst_dev(dst1))->ipv4.sysctl_lowpower_ema_k_factor));\n+                write_once(dst1->power_cost_weight, read_once(dev_net(dst_dev(dst1))->ipv4.sysctl_lowpower_power_cost_weight));\n+                write_once(dst1->ema_load, 0);\n+                write_once(dst1->ema_time_delta, 0);\n+\t\tdst1->last_update_jiffies = 0;\n+\n \t\tbundle[i] = xdst;\n \t\tif (!xdst_prev)\n \t\t\txdst0 = xdst;\n```\n\n\n---\n\n## 빌드와 테스트: 실제로 적용해 보기\n\n실제로 커널을 빌드해서 적용하려면 대략 다음 순서로 진행하면 된다.\n\n1. 커널 소스 준비\n\n   * 배포판에서 제공하는 커널 소스를 쓰거나, vanilla 커널을 다운로드한다.\n\n2. 위 diff를 `lowpower_jitter.patch` 같은 이름으로 저장한다.\n\n3. 커널 소스 루트에서 패치 적용:\n\n   ```bash\n   patch -p1 < ../lowpower_jitter.patch\n   ```\n\n4. 설정/빌드:\n\n   ```bash\n   make olddefconfig\n   make -j\"$(nproc)\"\n   ```\n\n5. 설치 및 부팅\n\n   * 일반적인 리눅스 커널의 빌드 방법을 따른다.\n   * 새 커널로 부팅.\n\n6. sysctl 튜닝 및 측정\n\n   * 앞서 소개한 sysctl로 ema/코스트를 조정한다.\n   * `ping`, `mtr`, `iperf` 등을 활용해 멀티패스 환경에서 rtt/지터를 비교 측정해본다.\n\n---\n\n## 테스트 환경 / 토폴로지\n\n이 글에서 사용한 측정 환경은 아주 단순한 가정용 네트워크 토폴로지다.\n\n```text\n가정용 모뎀 ------ 라우터 --- pc\n```\n\n* **모뎀**: 통신사(isp)에서 제공하는 가정용 광/케이블 모뎀\n* **라우터**: 모뎀 뒤에서 **공인 ip를 직접 받는** 공유기\n* **pc**: 라우터 뒤에 유선으로 연결된 리눅스 머신\n  (글에서 `localhost(192.168.168.102)` 라고 적힌 부분은 이 pc를 가리킨다.)\n\n측정 시나리오는 다음과 같이 나뉜다.\n\n* **local ping localhost**:\n  이 pc에서 자기 자신(192.168.168.102)을 대상으로 ping 을 1000회 보낸 결과.\n* **wan ping 1.1.1.1**:\n  같은 토폴로지에서, 공인 ip를 가지고 있는 라우터를 통해 인터넷으로 나가 1.1.1.1을 1000회 ping 한 결과.\n\n즉, **lan/localhost 레벨에서의 지터 개선이 눈에 더 잘 나타나는 환경**이고, wan 측정치는 \"이 가정용 망에서 테스트했더니 이 정도였다\" 정도로만 보는 것이 맞다.\n다른 네트워크/isp 환경에서는 수치가 전혀 다를 수 있다.\n\nvanilla: *linux-kbuild-6.12.57+deb13 generic* \nmodified: patch over commit *559e608*\n\n---\n\n## 메트릭 비교\n\n\n\n<h3>local ping localhost (ms)</h3>\n<table>\n  <thead>\n    <tr><th>metric</th><th>vanilla</th><th>modified</th></tr>\n  </thead>\n  <tbody>\n    <tr><td>count</td><td>1000</td><td>1000</td></tr>\n    <tr><td>min</td><td>0.011</td><td>0.010</td></tr>\n    <tr><td>avg</td><td>0.029343</td><td>0.017279</td></tr>\n    <tr><td>median</td><td>0.022</td><td>0.015</td></tr>\n    <tr><td>p95</td><td>0.042</td><td>0.03405</td></tr>\n    <tr><td>p99</td><td>0.04501</td><td>0.041</td></tr>\n    <tr><td>max</td><td>4.65</td><td>0.059</td></tr>\n    <tr><td>stdev</td><td>0.146496</td><td>0.006409</td></tr>\n    <tr><td colspan=\"3\">outliers</td></tr>\n    <tr><td>count ≥ 0.5 ms</td><td>1</td><td>0</td></tr>\n  </tbody>\n</table>\n\n<h3>wan ping 1.1.1.1 (ms)</h3>\n<table>\n  <thead>\n    <tr><th>metric</th><th>vanilla</th><th>modified</th></tr>\n  </thead>\n  <tbody>\n    <tr><td>count</td><td>1000</td><td>1000</td></tr>\n    <tr><td>min</td><td>5.07</td><td>5.05</td></tr>\n    <tr><td>avg</td><td>5.79535</td><td>5.77376</td></tr>\n    <tr><td>median</td><td>5.81</td><td>5.79</td></tr>\n    <tr><td>p95</td><td>6.05</td><td>6.06</td></tr>\n    <tr><td>p99</td><td>6.1301</td><td>6.1702</td></tr>\n    <tr><td>max</td><td>6.94</td><td>6.93</td></tr>\n    <tr><td>stdev</td><td>0.179675</td><td>0.214948</td></tr>\n    <tr><td colspan=\"3\">outliers</td></tr>\n    <tr><td>count ≥ 6.0 ms</td><td>110</td><td>137</td></tr>\n    <tr><td>count ≥ 6.2 ms</td><td>4</td><td>8</td></tr>\n    <tr><td>count ≥ 6.5 ms</td><td>1</td><td>3</td></tr>\n  </tbody>\n</table>\n\nlocalhost(192.168.168.102)로의 연결은 확실히 핑이 덜 튀고, wan에서도 크게 성능 차이가 없다.\n적어도 이 가정용 네트워크에서, lan 레벨의 최악의 경우를 방어하는 데에는 성공했다.\n\n---\n\n## 시각화 그래프\n\n<img src=\"/assets/images/local_ping_cdf.png\" alt=\"localpingcdf\" style=\"max-width:70%; height:auto;\" />\n<img src=\"/assets/images/local_ping_hist_zoom.png\" alt=\"localpinghistzoom\" style=\"max-width:70%; height:auto;\" />\n<img src=\"/assets/images/wan_ping_cdf.png\" alt=\"wanpingcdf\" style=\"max-width:70%; height:auto;\" />\n<img src=\"/assets/images/wan_ping_hist.png\" alt=\"wanpinghist\" style=\"max-width:70%; height:auto;\" />\n\n## 전체 로그 첨부\n\n<a href=\"/assets/files/vanilla.zip\">vanilla</a><br> <a href=\"/assets/files/modified.zip\">modified</a>\n\n---\n\n## 마무리\n\n이 예시는 \"비전공자도 따라 할 수 있는\" 수준으로, 리눅스 커널 네트워크 스택에 ema 기반 메트릭을 살짝 얹어서 라우팅 결정을 조정해보는 예시였다.\n(다시 한 번 말하지만, 여기서의 비전공자는 cs 학위가 없더라도 리눅스 빌드/설치 경험은 있는 사람 정도를 뜻한다.)\n\n* 커널 해킹이라고 해서 거대한 서브시스템 전체를 이해해야만 할 필요는 없다.\n* 실제로는\n\n  * 경로를 표현하는 구조체(`dst_entry`)에 필드 몇 개 추가하고,\n  * 패킷 전송 경로에서 값 업데이트,\n  * 멀티패스 선택 함수에서 그 값을 참고하도록 한 정도다.\n\n이 정도만으로도, 특정 상황에서는 \"핑이 팍 튀어버리는\" 문제를 체감상 꽤 줄일 수 있다.\n필요하다면, 여기서 더 나아가 rtt 샘플을 직접 기록하거나, 에너지 소비 모델까지 붙여서 진짜 의미의 \"power-aware, jitter-aware\" 라우팅으로 확장해 보는 것도 가능하다.\n"
    },
    {
      "title": "[재귀]하노이의 탑-프로그래머스-레벨 2",
      "subtitle": "재귀 알고리즘을 활용한 하노이의 탑 문제 풀이",
      "description": null,
      "url": "/codingtest/2025-08-08-[재귀]하노이의탑-프로그래머스-레벨2/",
      "collection": "codingtest",
      "relative_path": "2025-08-08-[재귀]하노이의탑-프로그래머스-레벨2",
      "date": "2025-08-08T21:52:00+09:00",
      "updated": null,
      "keywords": [
        "재귀",
        "하노이의 탑",
        "프로그래머스",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-recursion",
        "order": 2
      },
      "difficulty": "beginner",
      "excerpt": "--- 하노이의 탑 - Lv.2 문제 하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. - 한 번에 하나의 원판만 옮길 수 있습니다. - 큰 원판이 작은 원판 위에 있어서는 안됩니다. 하노이 탑…",
      "search_text": "[재귀]하노이의 탑-프로그래머스-레벨 2 재귀 알고리즘을 활용한 하노이의 탑 문제 풀이 재귀 하노이의 탑 프로그래머스 알고리즘 codingtest codingtest algorithm-recursion --- 하노이의 탑 - lv.2 문제 하노이 탑(tower of hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다. - 한 번에 하나의 원판만 옮길 수 있습니다. - 큰 원판이 작은 원판 위에 있어서는 안됩니다. 하노이 탑… \n\n---\n\n# 하노이의 탑 - lv.2\n\n### 문제\n하노이 탑(tower of hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다.\n\n- 한 번에 하나의 원판만 옮길 수 있습니다.\n- 큰 원판이 작은 원판 위에 있어서는 안됩니다.\n\n하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다. 1번에는 n개의 원판이 있고 이 n개의 원판을 3번 원판으로 최소 횟수로 옮기려고 합니다.\n\n1번 기둥에 있는 원판의 개수 n이 매개변수로 주어질 때, n개의 원판을 3번 원판으로 최소로 옮기는 방법을 return하는 solution를 완성해주세요.\n\n---\n\n### 제한사항\n`n은 15이하의 자연수` 입니다.\n\n### 입출력 예\n`n \tresult`\n`2 \t[ [1,2], [1,3], [2,3] ]`\n\n### 구조\n이것은 단계적이고 체계적인 분류와 분기 조건 확인이 필요한 문제는 아니다.\n대신 **주어진 조건대로** 재귀를 구현하는 것이 문제이다.\n하지만 이 조건만으로 구조를 파악하기 쉽지가 않다.\n\n단계적으로 풀어가 보자.\n- n개의 크기 차이가 있는 큰 것부터 바닥에 쌓은 원판들을 옮긴다.\n- 기둥은 3개가 있다.\n- `1->3`일 시 보조기둥이 필요하다.\n- 원판은 자신보다 큰 원판 위에 올라가지 않는다\n  - **모든 원판은 시작 시 가장 왼쪽의 기둥에 모여 있다.**\n\n이는 단순히 어떤 보조 기둥을 거쳐 원판을 어떤 목적지로 옮기느냐의 문제로 귀결된다.\n\n그렇다면 문제의 케이스는 둘로 좁힐 수 있다.\n- 보조 기둥이 없을 시 `(보조 기둥 == 목적지)`\n- 보조 기둥이 있을 시 `(보조 기둥 != 목적지)`\n그러나 보조 기능을 사용하는 케이스와 사용하지 않는 케이스는 이 문제에서 요구하는, 출발지점-목적지 구조에서\n보조 기둥을 사용한 것과 완벽히 동일하게 간주된다.\n\n그렇다면 보조 기둥을 강제하면 된다.\n\n그러나 이것의 케이스를 둘로 나누어야 한다.\n\n- 출발지 - 보조 기둥 (최종 목적지를 보조 기둥처럼 사용)\n- 보조 기둥 - 목적지 (출발지를 보조 기둥처럼 사용\n\n\n이것은 `출발지 - 목적지`만 담는 출제 의도에선 사소한 사항인 것이다.\n\n이렇게 구현 방법을 단순화하였으니. 이 부분이 pt1, pt2로 표기된 것을 유심히 보며 코드를 보도록 하자.\n\n### 풀이\n\n```cpp\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid hanoi(vector<vector<int>> &answer, int n, int from, int to, int via) {\n    if(n==1) {\n        answer.push_back({from, to});\n        return;\n    }\n    hanoi(answer, n-1/*smaller recursion*/, from, via, to); // pt1. from -> via using to\n    answer.push_back({from, to});\n    hanoi(answer, n-1 /*smaller recursion*/, via, to, from); // pt2. via -> to using from\n}\n\nvector<vector<int>> solution(int n) {\n    vector<vector<int>> answer;\n    hanoi(answer, n, 1, 3, 2);\n    return answer;\n}\n```\n\n재귀적 사고를 요구하는 문제이다. 아마도 중견기업, 대기업, 기술 위주 스타트업 문제에 중급 문제로 출제될 수 있는 유형같다.\n\n"
    },
    {
      "title": "Incuspeed-Init레벨 가상화 컨테이너를 손쉽게",
      "subtitle": null,
      "description": null,
      "url": "/cloud/2025/07/13/incuspeed-init.html",
      "collection": "posts",
      "relative_path": "_posts/2025-07-13-Incuspeed-Init레벨-가상화-컨테이너를-손쉽게.md",
      "date": "2025-07-13T23:33:00+09:00",
      "updated": null,
      "keywords": [
        "Virtualization",
        "LXC",
        "Incus",
        "Python",
        "Go"
      ],
      "categories": [
        "cloud"
      ],
      "taxonomy": {
        "category": "cloud",
        "subcategory": "virtualization",
        "order": 1
      },
      "difficulty": "advanced",
      "excerpt": "--- IncuSpeed: Incus Remote Container Manager 프로젝트 개요 IncuSpeed는 init 단계까지 포함한 시스템 컨테이너를 원격에서 쉽고 안전하게 생성, 관리할 수 있도록 설계된 클라이언트-서버 구조의 애플리케이션입니다. 파이썬 Kivy 기반 GUI 클라이언트를 통해 멀티유저 환경에서 컨테이너의 생성, 삭제, 상태 변경(freeze/unfreeze 등), 파일 전송을 직관적으로 수행할 수 있으며, Go 언어로 구현된 서버는 Incus 컨테이너를 직접 제어합니다.…",
      "search_text": "incuspeed-init레벨 가상화 컨테이너를 손쉽게 virtualization lxc incus python go cloud cloud virtualization --- incuspeed: incus remote container manager 프로젝트 개요 incuspeed는 init 단계까지 포함한 시스템 컨테이너를 원격에서 쉽고 안전하게 생성, 관리할 수 있도록 설계된 클라이언트-서버 구조의 애플리케이션입니다. 파이썬 kivy 기반 gui 클라이언트를 통해 멀티유저 환경에서 컨테이너의 생성, 삭제, 상태 변경(freeze/unfreeze 등), 파일 전송을 직관적으로 수행할 수 있으며, go 언어로 구현된 서버는 incus 컨테이너를 직접 제어합니다.… \n\n---\n\n# incuspeed: incus remote container manager\n\n## 프로젝트 개요\n\nincuspeed는 init 단계까지 포함한 시스템 컨테이너를 원격에서 쉽고 안전하게 \n생성, 관리할 수 있도록 설계된 클라이언트-서버 구조의 애플리케이션입니다.\n파이썬 kivy 기반 gui 클라이언트를 통해 멀티유저 환경에서 컨테이너의 생성, 삭제, 상태 변경(freeze/unfreeze 등), \n파일 전송을 직관적으로 수행할 수 있으며, go 언어로 구현된 서버는 incus 컨테이너를 직접 제어합니다.\n\n---\n\n## 주요 기능\n\n- **컨테이너 라이프사이클 관리**: `start`, `stop`, `freeze`, `unfreeze`, `restart`, `delete`, `create`\n- **원격 상태 조회 및 갱신**: gui에서 실시간 컨테이너 목록 갱신 및 상태 확인\n- **파일 푸시 기능**: gui로 편리하게 컨테이너 내부에 파일을 전송 가능\n- **ssh 포트 매핑**: 각 컨테이너에 3개의 포트를 할당, 30001, 30002는 테스트용 스페어 포트로 외부에 매핑\n- **유저별 네임스페이스 분리**: 유저 가입/탈퇴 기능 구현, 유저 단위 컨테이너 관리 및 권한 분리\n- **중복 태그 허용**: 동일 태그명으로 여러 컨테이너 식별 가능하나 내부적으로는 고유 식별자 부여\n- **mongodb 연동**: 컨테이너 및 유저 정보를 mongodb에 저장 및 관리\n\n---\n\n## 기술적 구현 상세\n\n### 클라이언트-서버 구조 및 통신\n\n- https 프로토콜 기반으로 지정된 인증서 사용하여 안전한 원격 명령 전송\n- json 포맷의 요청/응답 프로토콜 직접 설계 및 구현\n- python kivy gui 앱에서 쓰레딩으로 비동기 처리 구현, ui 프리징 방지 및 원활한 사용자 경험 제공\n- go 서버에서는 goroutine과 waitgroup을 이용해 비동기 작업과 동기화를 안정적으로 수행\n- 애플리케이션의 핵심 코드를 모듈로 분리: main 간결화\n- swagger를 통한 직관적 문서화\n\n### 보안 및 인증\n\n- aes 암호화와 bcrypt 해싱을 통해 민감 데이터 보호\n- 유저별 자원 분리로 개별성 강화\n- 등록되지 않은 유저의 임의 접근 차단\n- ssh 터널링과 nginx 리버스 프록시 설정으로 포트 포워딩 및 접근 제어를 체계적으로 구현\n\n### 시스템 및 네트워크 설계\n\n- 각 컨테이너에 독립된 ssh 포트 배정 및 서비스 분리\n- 테스트용 스페어 포트를 외부 포트에 매핑하여 유연한 네트워크 관리 지원\n- 컨테이너 상태 및 유저 관리 데이터 mongodb에 저장하여 신뢰성 있는 상태 관리\n\n---\n\n## 프로젝트 의의 및 평가\n\n이 프로젝트는 단순 토이 프로젝트를 넘어, 다음과 같은 수준을 보여줍니다:\n\n- **멀티유저 분산 시스템 설계 및 구현** 경험\n- **네트워크, 보안, 비동기 처리** 등 다층 기술 스택 통합\n- **실제 서비스 환경을 고려한 보안 및 인증 체계** 적용\n- **크로스 플랫폼 gui 구현 및 ux 고려**\n\n이는 일반적인 대학생 수준으로 달성하기 힘들며, 현업 기준으로  **1-2년차 엔트리 개발자 수준**의 기술적 성취입니다.\n특히 클라이언트-서버 아키텍처, 직접 설계한 json api, 멀티프로세싱/고루틴 활용 등은 \n엔트리 레벨 개발자가 쉽게 경험하기 어려운 분야입니다.\n\n---\n\n## 확장 가능성\n\n- 컨테이너 스냅샷 원격 생성 및 관리 기능 추가\n- 컨테이너 상태를 이미지로 저장하는 기능 개발\n\n---\n\n## 결론\n\nincus remote container manager 프로젝트는 단순 gui 툴이 아닌,\n시스템 수준의 컨테이너 관리, 보안, 네트워크, 멀티유저 운영 체계를 통합한 완성도 높은 소프트웨어 솔루션입니다.\n\n## 링크\n[저장소 링크](https://github.com/gg582/incuspeed)\n[모듈 부분](https://github.com/gg582/linux_virt_unit)\n\n---\n"
    },
    {
      "title": "[재귀][백트래킹] 좋은수열-백준 2661번",
      "subtitle": "재귀와 백트래킹을 활용한 수열 생성 문제",
      "description": null,
      "url": "/codingtest/2025-07-01-[재귀][백트래킹]-좋은수열-백준-2661번/",
      "collection": "codingtest",
      "relative_path": "2025-07-01-[재귀][백트래킹]-좋은수열-백준-2661번",
      "date": "2025-07-01T19:55:00+09:00",
      "updated": null,
      "keywords": [
        "재귀",
        "백트래킹",
        "백준",
        "알고리즘"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-recursion",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "--- 백준 2661번: 좋은 수열 성능 제약 - 메모리 제한: 128MB - 시간 제한: 1초 문제 숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 다음은 나쁜 수열의 예이다. - 33 - 3 2121 323 - 123123 213 다음은 좋은 수열의 예이다. - 2 - 32 - 32123 - 1232123 길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구…",
      "search_text": "[재귀][백트래킹] 좋은수열-백준 2661번 재귀와 백트래킹을 활용한 수열 생성 문제 재귀 백트래킹 백준 알고리즘 codingtest codingtest algorithm-recursion --- 백준 2661번: 좋은 수열 성능 제약 - 메모리 제한: 128mb - 시간 제한: 1초 문제 숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 다음은 나쁜 수열의 예이다. - 33 - 3 2121 323 - 123123 213 다음은 좋은 수열의 예이다. - 2 - 32 - 32123 - 1232123 길이가 n인 좋은 수열들을 n자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구… \n\n---\n# 백준 2661번: 좋은 수열\n\n### 성능 제약\n- 메모리 제한: 128mb\n- 시간 제한: 1초\n### 문제\n숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다.\n\n다음은 나쁜 수열의 예이다.\n- 33\n- 3<ins>2121</ins>323\n- <ins>123123</ins>213\n\n다음은 좋은 수열의 예이다.\n- 2\n- 32\n- 32123\n- 1232123\n\n길이가 n인 좋은 수열들을 n자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.\n## 입력\n입력은 숫자 n하나로 이루어진다. n은 1 이상 80 이하이다.\n\n### 출력\n첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 n인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.\n#### 예제 입력 1\n`7`\n\n#### 예제 출력 1\n`1213121`\n\n## 발단\n일단 조건은, 반복적 규칙이 연속적으로 나와서는 안 된다.\n12312323을 군집화하면, (123)(123)23, 1231(23)(23)이라는 2가지 경우의 수가 있다.\n부분을 보자. `123123`\n### 구조(12312323의 나쁜 수열 substring, 123123)\n123 / 123\n\n`left: 123, right: 123`\n```cpp\n(\"123\" == \"123\") == true\n```\n### 구조(121312313의 좋은 수열 substring, 2313)\n\n23 / 13\n`left: 23, right: 13`\n```cpp\n(\"23\" == \"13\") == false\n```\n\n좋은 수열은 substring에서 중간을 기준으로 **서로 가장 같은 길이의 서브스트링을 추출해** 좌측과 우측이 동일한 `l == r`인 것이 존재하지 않아야 한다는 것이다.\n그리고 이러한 비교는 재귀적으로 돌아갈 것이다.\n`123 -> 12, 23 -> (1,2), (2,3)`과 같은 형태이다.\n\n조금 더 비유적으로 설명해보자. 좋은 막대, 나쁜 막대라고 해 보자.\n\n- 균질한 재질로 좌우 대칭으로 주조한 쇠 막대는 좋은 막대가 아니다.\n- 숲에서 잘라온 울퉁불퉁한 나뭇가지는 좋은 막대이다.\n\n## 전개\n좋은 수열의 검증 방법을 생각해 보자.\n문자열의 끝부터 최소 길이부터 비교해 보도록 하자.\n### 나쁜 수열(12312323)\n\n#### 비교 길이: 1, 비교 인덱스: 6, 7\n-> idx[6] == 2, idx[7] == 3\n`left: 2, right: 3`\n```cpp\n( \"2\" == \"2\" ) == false\n```\n#### 비교 길이: 2, 비교 인덱스: idx[4] to idx[5], idx[6] to idx[7]\n\n\n<table>\n  <thead>\n    <tr>\n      <th>index</th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>'4'</th>\n      <th>'5'</th>\n      <th>\"6\"</th>\n      <th>\"7\"</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>value</td>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n      <td>1</td>\n      <td>2</td>\n      <td>3</td>\n      <td>2</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n\n`'left': 23, \"right\" : 23`\n( \"23\" == \"23\" ) == true\n### 좋은 수열 (121312313)\n\n#### 길이 1, 추가 재귀 x\nleft: 1 right: 2\nleft: 2 right: 1\nleft: 1 right: 2\nleft: 1 right: 3\n어떤 것도 좌우가 일치하지 않는다.\n#### 길이 2, 추가 재귀 1회\n##### 길이 2\nleft: 12 right: 13\n##### 재귀 1회차, 길이 1\nleft: 3 right: 1\n##### length 2\nleft: 21 right: 31\n##### 재귀 1회차, 길이 1\nleft: 1 right: 2\n##### 재귀 1회차, 길이 1\nleft: 21 right: 31\n\n그리고 유의할 점은, 재귀 호출은 순차적으로 출력되지 않으므로 로깅으로 흐름을 따라가는 것이 제한적이다.\n```\n9\nleft: 1 right: 2\nleft: 2 right: 1\nleft: 1 right: 2\nleft: 1 right: 3\nleft: 12 right: 13\nleft: 3 right: 1\nleft: 21 right: 31\nleft: 1 right: 2\nleft: 13 right: 12\nleft: 121 right: 312\nleft: 2 right: 1\nleft: 31 right: 21\nleft: 213 right: 121\nleft: 1 right: 2\nleft: 1 right: 3\nleft: 12 right: 13\nleft: 131 right: 213\nleft: 2 right: 3\nleft: 31 right: 23\nleft: 213 right: 123\nleft: 3 right: 1\nleft: 12 right: 31\nleft: 131 right: 231\nleft: 1213 right: 1231\nleft: 1 right: 2\nleft: 23 right: 12\nleft: 1 right: 3\nleft: 23 right: 13\nleft: 312 right: 313\nleft: 2131 right: 2313\nleft: 3 right: 2\nleft: 12 right: 32\nleft: 131 right: 232\nleft: 1213 right: 1232\nleft: 1 right: 3\nleft: 3 right: 2\nleft: 21 right: 32\nleft: 2 right: 3\nleft: 1 right: 3\n121312313\n```\n이와 같이 로그를 갖는다. 일부 순서가 뒤바뀌곤 한다.\n\n## 발단\n\n### 유의사항\nfor(int i = 1; i <= len / 2; i++) 지점에서 등호를 써야 적확\nanswer != \"\" (혹은!answer.equals(\"\")) 에서 논리 부정을 누락하면 안 된다. 오탈자나 나기 좋은데, \n만약 부등호가 아니라면 알고리즘 수행이 되기도 전의 첫번째 호출에서 **아무 동작도 하지 않고** 함수가 끝난다.\n\n### java 풀이\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class main {\n    static string answer = \"\";\n    static int maxchecknumber = 3;\n    public static void main(string[] args) throws exception {\n        bufferedreader br = new bufferedreader(new inputstreamreader(system.in));\n        bufferedwriter bw = new bufferedwriter(new outputstreamwriter(system.out));\n        int len = integer.parseint(br.readline());\n        string s = \"\";\n        createstring(s, len);\n        bw.write(answer);\n        bw.flush();\n    }\n    static boolean checkvalidstring(string s) {\n        int len = s.length();\n        for(int i = 1; i <= len / 2; i++) {\n            int size = len - i * 2;\n            string suffix1 = s.substring(len - i, len);\n            string suffix2 = s.substring(len - 2 * i, len - i);\n\n            if (suffix1.equals(suffix2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static void createstring(string s, int len) {\n        if(!checkvalidstring(s)) return;\n        if(!answer.equals(\"\")) return;\n        if(s.length() >= len) {\n            answer = s;\n        }\n        for(int i = 1; i <= maxchecknumber; i++) {\n            createstring(s+integer.tostring(i), len);\n        }\n    }\n}\n```\n\njava에서 등호를 이용한 스트링 비교는 권장되지 않는다. equals 등을 이용하여 비교하는 것이 보편적이다.\n\n### javascript 풀이\n\n```javascript\nfunction inputlength() {\n    let fs = require('fs')\n    let input = fs.readfilesync('/dev/stdin').tostring().trim();\n    return number(input);\n}\n\nlet answer      = \"\";\nlet n           = 0;\nlet maxchecknum = 3;\n\nfunction verify(s) {\n    for(let i = 1; i <= s.length / 2; i++) {\n        let size = s.length - i * 2;\n        if(s.slice(size, size+i) === s.slice(size+i, size+i*2)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction goodstring(s) {\n    if(!verify(s) ||  answer !== \"\") {\n        return\n    }\n    if(s.length === n) {\n        answer = s\n        return\n    }\n    for(let i = 1; i <= maxchecknum; i++) {\n        goodstring(s+i)\n    }\n}\n\nfunction main() {\n    n = inputlength()\n    goodstring(\"\")\n    console.log(answer)\n}\n\nmain()\n```\n`===` 비교를 통해 type coersion을 방지한다. 또한, slice 지점을 지정하는 것은 go같으나 그 호출방식은 전통적인 java, c++에 가깝다.\n\n### python3 풀이\n```python\nclass problem2661:\n    def __init__(self):\n        self.answer = false\n        self.l      = 0\n    def inputlength(self):\n        self.l = int(input())\n\n    def verify(self, s):\n        for i in range(1, int(len(s) / 2) + 1):\n            size = len(s) - i *2\n            if s[size: size+i] == s[size+i: size+i*2]:\n                return false\n        return true\n\n    def goodstring(self, s):\n        if not self.verify(s) or self.answer:\n            return\n        if len(s) >= self.l:\n            self.answer = true\n            print(s)\n            return\n        for i in range(1,4):\n            self.goodstring(s+str(i))\n            if self.answer:\n                return\n    def main(self):\n        self.inputlength()\n        self.goodstring(\"\")\nif __name__ == \"__main__\":\n    p = problem2661()\n    p.main()\n```\n파이썬 풀이는 현대적이고 자연어에 가까운 언어라는 특성이 잘 반영된다.\n파이썬은 초기 학습 곡선이 좋으나 후반부 학습 곡선이 대체로 확 가팔라진다.\nself를 이용한 클래스 구현은 직관적이고 이해하기 편하다.\nor, not, in-range 등의 자연어에 가까운 언어 특성은 파이썬이 이토록 빠르게 확산되는 원동력이었다.\ngo가 만약 이러한 키워드들을 지원했다면 파이썬의 아성을 넘볼 수 있었을까 상상해 본다.\n\n### go 풀이\n\n```go\npackage main\nimport \"bufio\"\nimport \"os\"\nimport \"strconv\"\nimport \"strings\"\n\ntype creategoodstring interface {\n\tinput()\n\tgoodstring(string)\n\tverify(string) bool\n}\n\nconst max_check_num = 3\n\ntype solve2661  struct {\n\tl int //length\n\tanswer bool\n\tiostr *bufio.readwriter\n}\n\nfunc (prob *solve2661) input() {\n\tprob.iostr = bufio.newreadwriter(bufio.newreader(os.stdin), bufio.newwriter(os.stdout))\n\tvar buf []byte  = make([]byte, 2)\n\t_, err := prob.iostr.read(buf)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprob.l, err = strconv.atoi(strings.trimright(string(buf), \"\\n\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (prob *solve2661) verify(s string) bool {\n\tfor i := 1; i <= len(s) / 2; i++ {\n\t\tsize := len(s) - i * 2;\n\t\tif s[size: size+i] == s[size+i: size+i*2] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (prob *solve2661) goodstring(s string) {\n\tif !prob.verify(s) || prob.answer {\n\t\treturn\n\t}\n\n\tif len(s) >= prob.l {\n\t\tprob.answer = true\n\t\tprob.iostr.writestring(s)\n        prob.iostr.flush()\n\t\treturn\n\t}\n\tfor i := 1; i <= max_check_num; i++ {\n\t\tprob.goodstring(s+strconv.itoa(i))\n        if prob.answer {\n            return\n        }\n\t}\n}\n\nfunc main() {\n\tp := new(solve2661)\n\tp.input()\n\tp.goodstring(\"\")\n}\n```\n여기서는 final recursion을 bool type으로 관리했고, 인터페이스를 활용해 코드를 정리했다.\nc++보다도 메모리 절약적이며 성능 역시 근소한 차이인 868-872kb, 4ms의 성능을 보였다.\ngc가 있는 매니지드 언어에서 이 정도의 성능을 낼 수 있다는 점이 주목할 점이다.\n생산성 중심의 현대 언어다운 빠르고 쉬운 슬라이싱과 단순한 문법으로 스크립트 짜듯 작성 가능하다.\n\n### cpp 풀이\n\n```cpp\n#include<iostream>\n#include<string>\n\nusing namespace std;\n#define max_check_num 3\n\nbool check_valid(string s) {\n    int len = s.length();\n    for(int i = 1; i <= len /2 ; i++) {\n        int size = len - i * 2;\n        if(s.substr(size,i) == s.substr(size+i,i)) return false;\n        //len = 7\n        //if i == 1: len - 2 == 5 , len - 2 + 1 == 6. compare idx5 and idx6\n        // if i == 2: len - 4 == 3 as len 2, len - 4 + 2 == 4 as len 2. comparing idx[3-4], idx[5,6]\n        // .. continues\n    }\n    return true;\n}\n\nvoid createstring(string s, string &answer, int len) {\n    if(!check_valid(s)) return;\n    if(answer.length()) return;\n    if(s.length() >= len) {\n        answer = s;\n        return;\n    }\n    for(int i = 1; i <= max_check_num; i++) {\n        createstring(s+to_string(i), answer, len);\n        if(answer.length()) return;\n    }\n}\n\nint main() {\n    string s = \"\", answer = \"\";\n    int len = 0;\n    cin >> len;\n    createstring(s, answer, len);\n    cout << answer;\n    return 0;\n}\n```\n\n단순하고 고전적인 풀이다. 고전 c++의 틀을 벗어나지 않았다(또한 그것이 의도이다).\n\n"
    },
    {
      "title": "리눅스 캐릭터 디바이스 작성 및 인터럽트",
      "subtitle": "캐릭터 디바이스 드라이버 개발과 인터럽트 처리",
      "description": null,
      "url": "/embedded/2025-06-05-리눅스-캐릭터-디바이스-작성-및-인터럽트/",
      "collection": "embedded",
      "relative_path": "2025-06-05-리눅스-캐릭터-디바이스-작성-및-인터럽트",
      "date": "2025-06-06T14:45:00+09:00",
      "updated": null,
      "keywords": [
        "캐릭터 디바이스",
        "디바이스 드라이버",
        "인터럽트",
        "리눅스 커널"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-linux",
        "order": 3
      },
      "difficulty": "intermediate",
      "excerpt": "--- 리눅스 캐릭터 디바이스란? 캐릭터 디바이스는, 말 그대로 문자 기반 으로 시스템과 상호작용한다는 뜻이다. 동일한 디바이스 드라이버가 관리하는 디바이스들은 같은 메이저 번호를 지니고, 각각의 디바이스들은 서로 다른 마이너 번호를 가진다. 주요 특성 - 스트림 기반 순차 I/O - 유저-디바이스 간 버퍼링 없는 직접 상호작용 할당 순서 - 메이저, 마이너 번호 할당 - 캐릭터 디바이스 리전 할당 - 캐릭터 디바이스 구조체 초기화 - 캐릭터 디바이스 클래스 생성 - 캐릭터 디바이스 생성 주요 사…",
      "search_text": "리눅스 캐릭터 디바이스 작성 및 인터럽트 캐릭터 디바이스 드라이버 개발과 인터럽트 처리 캐릭터 디바이스 디바이스 드라이버 인터럽트 리눅스 커널 embedded embedded embedded-linux --- 리눅스 캐릭터 디바이스란? 캐릭터 디바이스는, 말 그대로 문자 기반 으로 시스템과 상호작용한다는 뜻이다. 동일한 디바이스 드라이버가 관리하는 디바이스들은 같은 메이저 번호를 지니고, 각각의 디바이스들은 서로 다른 마이너 번호를 가진다. 주요 특성 - 스트림 기반 순차 i/o - 유저-디바이스 간 버퍼링 없는 직접 상호작용 할당 순서 - 메이저, 마이너 번호 할당 - 캐릭터 디바이스 리전 할당 - 캐릭터 디바이스 구조체 초기화 - 캐릭터 디바이스 클래스 생성 - 캐릭터 디바이스 생성 주요 사… \n\n---\n\n# 리눅스 캐릭터 디바이스란?\n\n캐릭터 디바이스는, 말 그대로 **문자 기반**으로 시스템과 상호작용한다는 뜻이다.\n동일한 디바이스 드라이버가 관리하는 디바이스들은 같은 메이저 번호를 지니고, 각각의 디바이스들은 서로 다른 마이너 번호를 가진다.\n\n## 주요 특성\n\n- 스트림 기반 순차 i/o\n- 유저-디바이스 간 버퍼링 없는 직접 상호작용\n\n## 할당 순서\n\n- 메이저, 마이너 번호 할당\n- 캐릭터 디바이스 리전 할당\n- 캐릭터 디바이스 구조체 초기화\n- 캐릭터 디바이스 클래스 생성\n- 캐릭터 디바이스 생성\n\n\n## 주요 사용처\n\n사용자와 버퍼링 없이 순차적으로 소통한다는 특성은 시리얼 포트 등에 적합하다.\n이러한 시리얼 포트를 통해 터미널, 키보드/마우스, 라인 프린터 등의 상호작용을 할 수가 있다.\n\n간단한 인터럽트가 포함된 캐릭터 디바이스를 실제로 구현하며 알아보도톡 하자.\n\n\n## 기본 구조\n\n캐릭터 디바이스는 init, exit, 그리고 사용자 공간-> 커널 메모리, 디바이스 드라이버 open, close, 커널 메모리->사용자 공간이라는 두 개의 메모리 io 흐름으로 대표된다.\n필요한 경우 io 명령을 지정하는 ioctl(**i/o c**on**t**ro**l**)을 지정 가능하며, 이것은 꽤 자주 사용된다. 이것과 관련해서도 추후 안내할 것이다.\n\n----\n\n## 기본 헤더/하드웨어 연결\n\n### 코드\n```c\n#include<linux/init.h>\n#include<linux/delay.h>\n#include<linux/workqueue.h>\n#include<linux/module.h>\n#include<linux/wait.h>\n#include<linux/cdev.h>\n#include<linux/device.h>\n#include<linux/err.h>\n#include<linux/interrupt.h>\n#include<linux/time.h>\n#include<linux/gpio.h>\n#define echo 536 // gpio-536 (gpio-24) in /sys/kernel/debug/info\n#define echo_label \"gpio_24\"\n#define trig 535 // gpio 23 // gpio-535 (gpio-23) in /sys/kernel/debug/info\n#define trig_label \"gpio_23\"\nstatic wait_queue_head_t waitqueue; //waitqueue for wait and wakeup\n\ndev_t dev = 0; // device driver's major/minor number\n\nint irq_no; //variabe for storing echo pin irq\n_bool echo_status; //for checking echo pin status, needed for identifying rising/falling\nuint64_t sr04_send_ts, sr04_recv_ts, duration;\n```\n\n### 헤더 선언\n\n```c\n#include<linux/init.h>\n```\n모듈의 init과 exit을 위해 필요하다.\n```c\n#include<linux/workqueue.h>\n#include<linux/wait.h>\n```\n작업 큐를 위해 필수적이다.\n```c\n#include<linux/module.h>\n```\n커널 모듈의 필수 기능들이 포함되어있다.\n```c\n#include<linux/cdev.h>\n#include<linux/device.h>\n```\n캐릭터 디바이스의 구조체와 클래스를 사용하기 위해 필수적이다.\n```c\n#include<linux/err.h>\n```\n오류 처리를 위한 정의들이다. `is_err`와 같은 것들이 있다.\n```c\n#include<linux/interrupt.h>\n```\n```c\n#include<linux/time.h>\n```\n타임스탬프를 가져오기 위한 정의들을 포함한다.\n```c\n#include<linux/gpio.h>\n```\ngpio를 사용하기 위한 헤더이다.\n```c\n#define echo 536 // gpio-536 (gpio-24) in /sys/kernel/debug/info\n#define echo_label \"gpio_24\"\n#define trig 535 // gpio 23 // gpio-535 (gpio-23) in /sys/kernel/debug/info\n#define trig_label \"gpio_23\"\n```\n아래에서 설명하도록 하겠다.\n```c\nstatic wait_queue_head_t waitqueue; //waitqueue for wait and wakeup\n```\n작업 큐이다. init에서 초기화할 것이다.\n\n```c\ndev_t dev = 0; // device driver's major/minor number\n```\n디바이스 드라이버의 메이저, 마이너 넘버를 정수로 저장한다.\n**단일 정수로 저장하며 구조체가 아니다.**\n\n```c\nint irq_no; //variabe for storing echo pin irq\n```\n정수로 echo 핀의 인터럽트 요청 번호를 저장한다.\n```c\n_bool echo_status; //for checking echo pin status, needed for identifying rising/falling\nuint64_t sr04_send_ts, sr04_recv_ts, duration;\n```\n에코 핀의 상태, 핀 인터럽트 시작/종료 시 타임스탬프, 그리고 그 차를 저장할 변수를 선언한다.\n\n\n----\n\n### 하드웨어 연결\n\n\n<img src=\"/assets/images/rpi_sr04.png\" style=\"max-width:50%; height: auto;\"/>\n\n우선 라즈베리 파이를 준비하고, 다음과 같이 연결한다.\ntrig 핀은 23번, echo 핀은 24번이다.\n\n이러한 gpio 핀 번호를 그대로 쓰는 것은, 아쉽게도 6.x 커널에서 지원하지 않는다.\n```bash\ncat /sys/kernel/debug/info\n```\n를 통해 핀 테이블을 확인한다.\n내가 사용하는 rpi 4b 기종의 경우 echo 핀이 gpio-536, trig 핀이 gpio-535이다.\n\n또한, 나중에 언급하겠지만, gpio 핀을 시스템에 요청할 때는 레이블이 필요하다. 이 경우 간단하고 알아보기 쉽게 gpio 핀 번호를 쓰도록 하겠다.\n\n```c\n#define echo 536 // gpio-536 (gpio-25) in /sys/kernel/debug/info\n#define echo_label \"gpio_24\"\n\n#define trig 535 // gpio 23 // gpio-535 (gpio-23) in /sys/kernel/debug/info \n#define trig_label \"gpio_23\"\n```\n\n\n이제 핀 할당을 위한 매크로가 선언되었다.\n\n## 인터럽트 설정\n<img src=\"https://img1.daumcdn.net/thumb/r1280x0/?scode=mtistory2&fname=https%3a%2f%2ft1.daumcdn.net%2fcfile%2ftistory%2f9978c64b5f64d18135\" style=\"max-width:50%; height: auto;\"/>\n\n핀을 인터럽트 wake-up 신호로 쓰려면 rising인지, falling인지 등을 정교하게 설정해야 한다.\n전압이 올라가는 순간과 떨어지는 순간 모두가 트리거로 사용될 수 있으나, 하드웨어가 이를 감지할 수 없을 가능성이 있다. 둘 모두를 커널에 말해주는 편이 좋다.\n\n```c\n\tirq_no = gpio_to_irq(echo); // gpio pin as interrupt pin\n\tif(request_irq(irq_no, echo_irq_triggered, irqf_trigger_rising | irqf_trigger_falling, \"hc-sr04\", (void *) echo_irq_triggered)) { //request irq function is for measurement... see the top of the code.\n\t\t_printk(\"cannot register irq...\");\n\t\tfree_irq(irq_no, (void *) echo_irq_triggered);\n\t}\n```\n\n## 거리 공식\n\n이제, 거리 공식을 되새겨 보자. 보통은 이것을 중학교 시간에 배웠다.\n\n`거리 = 속력 * 시간`\n\n커널 타이머가 나노초임을 안다면 쉽게 할 수 있지만, 센티미터 단위여서 100을 곱해야 한다는 것 외에도 핵심이 있다. 초음파가 발사된 후 돌아오기까지의 시간은 거리를 2배로 측정하며, 소리의 속도는 343m/s이다. (그러나 소리의 속도는 기온에 따라 편차도 있으니 대략 340m/s로 사용할 수 있다.)\n\n그렇다면 초음파의 속도만큼 나누면서도, 미터가 아닌 센티미터 단위로 측정할 것이라면 계산 공식은 `duration*(340/2)/(1000000000/100)`이 될 것인데, 이것을 간추리면 `duration*170/10000000`이다.\n\n그렇다면 duration은 언제 산출해야 하는가?\n\n앞에 설정한 인터럽트의 시점은 echo핀에 초음파가 돌아와서 전압으로 출력되는(혹은 출력이 다시 그라운드로 떨어지는) 시점이다.\n이 인터럽트 함수를 초음파의 왕복 시간을 구하는 시간으로 정의하고 `duration`이라는 변수에 저장하면 된다.\n\n\n----\n\n## 핀 설정\n\necho는 항상 인터럽트의 트리거로만 사용된다. 그 말은, 이것은 항상 **입력**용 핀이라는 뜻이다.\n그렇다면 이 echo가 연결된 gpio는 입력 전용, 항상 측정을 시작할 때 전압을 **출력**하기만 한다. 그렇다면 출력 전용 핀으로 설정해야 한다.\n\n이것은 코드로 다음과 같이 나타내진다.\n\n```c\ngpio_direction_output(trig,0);\ngpio_direction_input(echo);\n```\n\n\n\n## 메모리 할당과 해제\n\n할당 해제는 할당의 역순이다. 하지만 특정 단계에서 실패 시 상위 단계들로 차근차근 할당 해제하는 것을 깔끔하게 하기 쉽지 않다.\n\n이 때 다익스트라가 쓰지 말라고 엄포한 `goto`를 쓰게 될 것이다.\n물론 권위자의 판단이니만큼 개별 케이스에 대해 일일이 함수를 선언하거나, 분기문을 달 것이라면 그것도 괜찮다고 생각한다.\n\n하지만 이 경우는 goto의 가능한 활용법을 보이는 것도 나쁘지 않다고 판단했다.\ncdev(character device), class, major/minor 등의 할당을 유심히 보며 따라와 주길 바란다.\n\n```c\nstatic int __init sr04_driver_init(void) {\n    int major = major(dev);\n    int minor = minor(dev);\n\tif(alloc_chrdev_region(&dev, minor, 1, \"sr04\")<0) { /* note: dev_t alloc */\n\t\t_printk(\"cannot allocate chrdev region, \\n find comment \\\"note: dev_t alloc \\\"\\n, \\\n\t\t\tquitting without driver ins...\\n\");\n\t\tgoto chrdev_error;\n\t}\n\t_printk(\"major = %d, minor = %d\", major(dev),minor(dev));\n\tcdev_init(&sr04_cdev,&fops);\n\tif((cdev_add(&sr04_cdev,dev,1)) < 0) { /* note: adding cdev */\n\t\t_printk(\"cannot add cdev: find comment \\\"note: adding cdev\\\"\\n,\\\n\t\t\t quitting without driver ins...\\n\");\\\n\t\tgoto cdev_error;\n\t}\n\tif(is_err(sr04_class = class_create(\"sr04_class\"))) { /*note: creating dev class */\n\t\t_printk(\"cannot create class structure,\\n \\\n\t\t\t  find comment \\\"note: creating dev class\\\",\\\n\t\t\t  quitting without driver ins..\\n\");\n\t\tgoto class_error;\n\t}\n\n\tif(is_err(device_create(sr04_class, null, dev, null, \"sr04\"))) {\n\t\t_printk(\"cannot create the device,\\n find comment \\\"note: dev creation\\\", \\nquitting without driver ins...\\n\");\n\t\tgoto device_creation_error;\n\t}\n\n\n\t//gpio availability check\n\tif(!gpio_is_valid(echo)) {\n\t\t_printk(\"sr04 echo pin is not working\\n\");\n\t}\n\tif(!gpio_is_valid(trig)) {\n\t\t_printk(\"sr04 trig pin is not working\\n\");\n\t}\n\n\tif(gpio_request(trig,trig_label)<0) {\n\t\t_printk(\"error on trig request\");\n\t\tgpio_free(trig);\n\t\treturn -1;\n\t}\n\tif(gpio_request(echo,echo_label)<0) {\n\t\t_printk(\"error on echo request\");\n\t\tgpio_free(trig); //if the program has executed until now, trig is available, and requested succesfully\n\t\tgpio_free(echo);\n\t\treturn -1;\n\t}\n\n\tirq_no = gpio_to_irq(echo); // gpio pin as interrupt pin\n\tif(request_irq(irq_no, echo_irq_triggered, irqf_trigger_rising | irqf_trigger_falling, \"hc-sr04\", (void *) echo_irq_triggered)) { //request irq function is for measurement... see the top of the code.\n\t\t_printk(\"cannot register irq...\");\n\t\tfree_irq(irq_no, (void *) echo_irq_triggered);\n\t}\n\n\tgpio_direction_output(trig,0);\n\tgpio_direction_input(echo);\n\tinit_waitqueue_head(&waitqueue); // waitqueue init\n\t_printk(\"sr04 dev. driver inserted.\");\n\treturn 0;\n\n\nchrdev_error:\n\tunregister_chrdev_region(dev,1);\n\t_printk(\"sr04 dev. driver failed\");\n\treturn -1;\ncdev_error:\n\tcdev_del(&sr04_cdev);\n\tgoto chrdev_error;\nclass_error:\n\tclass_destroy(sr04_class);\n\tgoto cdev_error;\n\ndevice_creation_error:\n\tdevice_destroy(sr04_class,dev);\n\tgoto class_error;\n}\n```\n- `device_creation_error`는 동작 후 `class_error`를 호출\n- `class_error`는 동작 후 `cdev_error`를 호출\n- `cdev_error`는 동작 후 `chrdev_error`를 호출\n- `chrdev_error`는 goto 없이 종료\n\n이러한 흐름으로 불필요한 코드 중복을 막을 수 있다.\n\n그리고 정상적으로 모듈의 적재를 해제할 시의 메모리 할당 해제 코드는 역순으로 단순하게 진행하면 된다.\n\n```c\nstatic void __exit sr04_driver_exit(void) {\n\tfree_irq(irq_no, (void *) echo_irq_triggered);\n\tgpio_free(echo);\n\tgpio_free(trig);\n\tdevice_destroy(sr04_class,dev);\n\tclass_destroy(sr04_class);\n\tcdev_del(&sr04_cdev);\n\tunregister_chrdev_region(dev,1);\n\t_printk( \"sr04 dev. driver removed.\\n\" );\n}\n```\n\n----\n\n## 인터럽트 후 읽기\n\n\n거리는 인터럽트가 트리거된 후, echo 핀이 **꺼진 후** 왕복 시간을 읽어서 계산해야 오차가 없다. 즉, 읽기 작업은 항상 **인터럽트가 끝난 후**에 동작해야 한다는 절차를 따른다.\n여기서 c의 절차 지향적 철학이 빛을 발한다.\n\n### 인터럽트 코드\n```c\n/* start of irq handler */\nstatic irqreturn_t echo_irq_triggered(int irq, void *dev_id) {\n\techo_status = (_bool)gpio_get_value(echo);\n\tif(echo_status == 1) {\n\t\tsr04_send_ts = ktime_get_ns();\n\t\t_printk(\"echo interrupt\\n\");\n\t} else {\n\t\t_printk(\"succeed to get sr04_recv_ts%llu\\n\", sr04_recv_ts);\n\t\tsr04_recv_ts = ktime_get_ns();\n\t\tduration = sr04_recv_ts-sr04_send_ts;\n\t\twake_up_interruptible(&waitqueue);\n\t}\n\n\treturn irq_handled;\n}\n```\n\n인터럽트는 echo핀의 현재 값을 `echo_status`라는 불리언으로, 또한 나노초 단위의 타임스탬프 차를 구해서 `duration`에 저장한다.\n또한, wake up 시점 역시 echo핀이 1일 때로 직관적이다.\n\n이제 이것을 아래에서 어떻게 읽는지를 살펴보자.\n\n```c\nssize_t sr04_read(struct file *file, char __user *buf, size_t len, loff_t * off) {\n\tgpio_set_value(trig,1);\n\twait_event_interruptible(waitqueue,echo_status == 0); //wait for interrupt pin\n\tgpio_set_value(trig,0);\n\tif(duration<=0) { //if duration is invalid\n\t\t_printk(\"sr04 distance measurement: failed to get echo.. : duration is %llu\\n\", duration);\n\t\treturn 0;\n\t} else {\n\t\tchar dist[16];\n\t\tmemset(dist,0,sizeof(dist));\n\t\tsprintf(dist, \"%llu\", duration*170/10000000);\n\t\t_printk(\"duration : %llu\\n\", duration);\n\t\tint copied_bytes=copy_to_user(buf,dist,16);  //returning value as character\n\t\tif(copied_bytes>0) {\n\t\t\t_printk(\"distance hasn't copied to user...remained bytes: %d\", copied_bytes);\n\t\t}\n\t\treturn sizeof(dist);\n\t}\n\treturn 0;\n}\n```\n\n`wait_event_interruptible`에 echo핀의 상태가 0(그라운드 값)일때까지 작업큐로부터 인터럽트 종료를 기다린다.\n\n\n----\n\n## 전체 코드\n\n이제 이러한 흐름을 이해했다면 전체 코드를 통해 어떻게 조합되는지 알아 봐도 좋을 것이다.\n아래 코드를 참고 바란다.\n\n\n```c\n#include<linux/init.h>\n#include<linux/workqueue.h>\n#include<linux/module.h>\n#include<linux/wait.h>\n#include<linux/cdev.h>\n#include<linux/device.h>\n#include<linux/err.h>\n#include<linux/interrupt.h>\n#include<linux/time.h>\n#include<linux/gpio.h>\n#define echo 536 // gpio-536 (gpio-24) in /sys/kernel/debug/info\n#define echo_label \"gpio_24\"\n#define trig 535 // gpio 23 // gpio-535 (gpio-23) in /sys/kernel/debug/info\n#define trig_label \"gpio_23\"\nstatic wait_queue_head_t waitqueue; //waitqueue for wait and wakeup\n\ndev_t dev = 0; // device driver's major/minor number\n\nint irq_no; //variabe for storing echo pin irq\n_bool echo_status; //for checking echo pin status, needed for identifying rising/falling\nuint64_t sr04_send_ts, sr04_recv_ts, duration;\n/* start of irq handler */\n\nstatic irqreturn_t echo_irq_triggered(int irq, void *dev_id) {\n\techo_status = (_bool)gpio_get_value(echo);\n\tif(echo_status == 1) {\n\t\tsr04_send_ts = ktime_get_ns();\n\t\t_printk(\"echo interrupt\\n\");\n\t} else {\n\t\t_printk(\"succeed to get sr04_recv_ts%llu\\n\", sr04_recv_ts);\n\t\tsr04_recv_ts = ktime_get_ns();\n\t\tduration = sr04_recv_ts-sr04_send_ts;\n\t\twake_up_interruptible(&waitqueue); // interrupt wake up\n\t}\n\n\treturn irq_handled;\n}\n\n\n/* -- start of function prototype */\nstruct class *sr04_class;\nstruct cdev sr04_cdev;\n\nstatic int __init sr04_driver_init(void);\nint sr04_driver_open(struct inode *inode, struct file *file) ;\nint sr04_driver_release(struct inode *inode, struct file *file) ;\nstatic void __exit sr04_driver_exit(void);\n\nssize_t sr04_read(struct file *file, char __user *buf, size_t len, loff_t * off);\n\n/* -- end of function prototype -- */\n\nstruct file_operations fops = {\n\t.owner\t= this_module,\n\t.read\t= sr04_read,\n\t.open\t= sr04_driver_open,\n\t.release = sr04_driver_release,\n};\n\nint sr04_driver_open(struct inode *inode, struct file *file) {\n\treturn 0;\n}\nint sr04_driver_release(struct inode *inode, struct file *file) {\n\treturn 0;\n}\n\nstatic int __init sr04_driver_init(void) {\n    int major = major(dev);\n    int minor = minor(dev);\n\tif(alloc_chrdev_region(&dev, minor, 1, \"sr04\")<0) { /* note: dev_t alloc */\n\t\t_printk(\"cannot allocate chrdev region, \\n find comment \\\"note: dev_t alloc \\\"\\n, \\\n\t\t\tquitting without driver ins...\\n\");\n\t\tgoto chrdev_error;\n\t}\n\t_printk(\"major = %d, minor = %d\", major(dev),minor(dev));\n\tcdev_init(&sr04_cdev,&fops);\n\tif((cdev_add(&sr04_cdev,dev,1)) < 0) { /* note: adding cdev */\n\t\t_printk(\"cannot add cdev: find comment \\\"note: adding cdev\\\"\\n,\\\n\t\t\t quitting without driver ins...\\n\");\\\n\t\tgoto cdev_error;\n\t}\n\tif(is_err(sr04_class = class_create(\"sr04_class\"))) { /*note: creating dev class */\n\t\t_printk(\"cannot create class structure,\\n \\\n\t\t\t  find comment \\\"note: creating dev class\\\",\\\n\t\t\t  quitting without driver ins..\\n\");\n\t\tgoto class_error;\n\t}\n\n\tif(is_err(device_create(sr04_class, null, dev, null, \"sr04\"))) {\n\t\t_printk(\"cannot create the device,\\n find comment \\\"note: dev creation\\\", \\nquitting without driver ins...\\n\");\n\t\tgoto device_creation_error;\n\t}\n\n\n\t//gpio availability check\n\tif(!gpio_is_valid(echo)) {\n\t\t_printk(\"sr04 echo pin is not working\\n\");\n\t}\n\tif(!gpio_is_valid(trig)) {\n\t\t_printk(\"sr04 trig pin is not working\\n\");\n\t}\n\n\tif(gpio_request(trig,trig_label)<0) {\n\t\t_printk(\"error on trig request\");\n\t\tgpio_free(trig);\n\t\treturn -1;\n\t}\n\tif(gpio_request(echo,echo_label)<0) {\n\t\t_printk(\"error on echo request\");\n\t\tgpio_free(trig); //if the program has executed until now, trig is available, and requested succesfully\n\t\tgpio_free(echo);\n\t\treturn -1;\n\t}\n\n\tirq_no = gpio_to_irq(echo); // gpio pin as interrupt pin\n\tif(request_irq(irq_no, echo_irq_triggered, irqf_trigger_rising | irqf_trigger_falling, \"hc-sr04\", (void *) echo_irq_triggered)) { //request irq function is for measurement... see the top of the code.\n\t\t_printk(\"cannot register irq...\");\n\t\tfree_irq(irq_no, (void *) echo_irq_triggered);\n\t}\n\n\tgpio_direction_output(trig,0);\n\tgpio_direction_input(echo);\n\tinit_waitqueue_head(&waitqueue); // waitqueue init\n\t_printk(\"sr04 dev. driver inserted.\");\n\treturn 0;\n\n\nchrdev_error:\n\tunregister_chrdev_region(dev,1);\n\t_printk(\"sr04 dev. driver failed\");\n\treturn -1;\ncdev_error:\n\tcdev_del(&sr04_cdev);\n\tgoto chrdev_error;\nclass_error:\n\tclass_destroy(sr04_class);\n\tgoto cdev_error;\n\ndevice_creation_error:\n\tdevice_destroy(sr04_class,dev);\n\tgoto class_error;\n}\n\nstatic void __exit sr04_driver_exit(void) {\n\tfree_irq(irq_no, (void *) echo_irq_triggered);\n\tgpio_free(echo);\n\tgpio_free(trig);\n\tdevice_destroy(sr04_class,dev);\n\tclass_destroy(sr04_class);\n\tcdev_del(&sr04_cdev);\n\tunregister_chrdev_region(dev,1);\n\t_printk( \"sr04 dev. driver removed.\\n\" );\n}\n\n\nssize_t sr04_read(struct file *file, char __user *buf, size_t len, loff_t * off) {\n\tgpio_set_value(trig,1);\n\twait_event_interruptible(waitqueue,echo_status == 0); //wait for interrupt pin\n\tgpio_set_value(trig,0);\n\tif(duration<=0) { //if duration is invalid\n\t\t_printk(\"sr04 distance measurement: failed to get echo.. : duration is %llu\\n\", duration);\n\t\treturn 0;\n\t} else {\n\t\tchar dist[16];\n\t\tmemset(dist,0,sizeof(dist));\n\t\tsprintf(dist, \"%llu\", duration*170/10000000);\n\t\t_printk(\"duration : %llu\\n\", duration);\n\t\tint copied_bytes=copy_to_user(buf,dist,16);  //returning value as character\n\t\tif(copied_bytes>0) {\n\t\t\t_printk(\"distance hasn't copied to user...remained bytes: %d\", copied_bytes);\n\t\t}\n\t\treturn sizeof(dist);\n\t}\n\treturn 0;\n}\n\n\nmodule_init(sr04_driver_init);\nmodule_exit(sr04_driver_exit);\nmodule_license(\"gpl\");\nmodule_author(\"yunjin lee <gzblues61@gmail.com>\");\nmodule_description(\"hc-sr04\");\nmodule_version(\"0.01\");\n```\n\n\n## 마무리하며\n\n이번 시간에는 캐릭터 디바이스와 인터럽트 기초까지 속성으로 나갈 수 있었다. 다음 시간에는 i2c에 대한 추가 강의로 다시 이어서 진도를 나가도록 하겠다.\n"
    },
    {
      "title": "StatefulSet과 Deployment의 차이",
      "subtitle": null,
      "description": null,
      "url": "/cloud/2025-06-05-StatefulSet과-Deployment의-차이/",
      "collection": "cloud",
      "relative_path": "2025-06-05-StatefulSet과-Deployment의-차이",
      "date": "2025-06-05T14:39:20+09:00",
      "updated": null,
      "keywords": [
        "Kubernetes",
        "StatefulSet",
        "Deployment",
        "K8s Concepts"
      ],
      "categories": [
        "cloud"
      ],
      "taxonomy": {
        "category": "cloud",
        "subcategory": "kubernetes",
        "order": 2
      },
      "difficulty": "beginner",
      "excerpt": "StatefulSet이란? 먼저, k8s 한국어 문서의 설명을 보도록 하자. 여기서 읽어낼 수 있는 사실은 아래와 같다. - 파드들의 순서 및 고유성 보장 - 파드들은 동일한 스펙으로 생성되나 스케줄링 시 개별 식별자로 관리 - PV(Persistent Volume)을 통해 지속성 제공이 가능(Persistent Pod 식별자) 구글에서는 spec을 스'팩'으로 한글화하는 것 같다. 파드들은 개별적인 식별자로 관리되며, 역시 PV를 이용한 지속성 제공을 지원한다. 스테이트풀셋은 파드를 생성하기 위…",
      "search_text": "statefulset과 deployment의 차이 kubernetes statefulset deployment k8s concepts cloud cloud kubernetes statefulset이란? 먼저, k8s 한국어 문서의 설명을 보도록 하자. 여기서 읽어낼 수 있는 사실은 아래와 같다. - 파드들의 순서 및 고유성 보장 - 파드들은 동일한 스펙으로 생성되나 스케줄링 시 개별 식별자로 관리 - pv(persistent volume)을 통해 지속성 제공이 가능(persistent pod 식별자) 구글에서는 spec을 스'팩'으로 한글화하는 것 같다. 파드들은 개별적인 식별자로 관리되며, 역시 pv를 이용한 지속성 제공을 지원한다. 스테이트풀셋은 파드를 생성하기 위… \n# statefulset이란?\n\n먼저, k8s 한국어 문서의 설명을 보도록 하자.\n\n```text\n스테이트풀셋은 애플리케이션의 스테이트풀을\n관리하는데 사용하는 워크로드 api 오브젝트이다.\n\n파드 집합의 디플로이먼트와 스케일링을 관리하며,\n 파드들의 순서 및 고유성을 보장한다 .\n\n디플로이먼트와 유사하게, \n스테이트풀셋은 동일한 컨테이너 스펙을 기반으로 둔 파드들을 관리한다.\n디플로이먼트와는 다르게, \n스테이트풀셋은 각 파드의 독자성을 유지한다. \n이 파드들은 동일한 스팩으로 생성되었지만, \n서로 교체는 불가능하다. \n다시 말해, 각각은 재스케줄링 간에도 지속적으로 유지되는 식별자를 가진다.\n\n스토리지 볼륨을 사용해서 워크로드에 지속성을 제공하려는 경우, \n솔루션의 일부로 스테이트풀셋을 사용할 수 있다. \n스테이트풀셋의 개별 파드는 장애에 취약하지만,\n퍼시스턴트 파드 식별자는 기존 볼륨을 실패한 볼륨을 \n대체하는 새 파드에 더 쉽게 일치시킬 수 있다.\n```\n여기서 읽어낼 수 있는 사실은 아래와 같다.\n\n- 파드들의 순서 및 고유성 보장\n- 파드들은 동일한 스펙으로 생성되나 스케줄링 시 개별 식별자로 관리\n- pv(persistent volume)을 통해 지속성 제공이 가능(persistent pod 식별자)\n\n*구글에서는 spec을 스'팩'으로 한글화하는 것 같다.*\n\n파드들은 개별적인 식별자로 관리되며, 역시 pv를 이용한 지속성 제공을 지원한다.\n스테이트풀셋은 파드를 생성하기 위한 명세의 일종이며 **개별 파드의 독립성을 강조한다**, 가 적절한 요약일 것 같다.\n\n# deployment란?\n다시 k8s 한국어 문서를 보도록 하자.\n\n```text\n디플로이먼트(deployment) 는 파드와 레플리카셋(replicaset)에 대한 선언적 업데이트를 제공한다.\n\n디플로이먼트에서 의도하는 상태 를 설명하고, 디플로이먼트 컨트롤러(controller)는 현재 상태에서 의도하는 상태로 비율을 조정하며 변경한다. 새 레플리카셋을 생성하는 디플로이먼트를 정의하거나 기존 디플로이먼트를 제거하고, 모든 리소스를 새 디플로이먼트에 적용할 수 있다. \n```\n\n여기까지만 봐선 파드와 레플리카셋을 업데이트하고, 의도된 상태에 맞게 관리한다고 하면 스테이트풀셋과의 차이를 알기 힘들다.\n따라서 문서의 유스케이스 항목을 살펴봐야 한다.\n\n## 유스케이스\n\n다음은 디플로이먼트의 일반적인 유스케이스이다.\n\n- 레플리카셋을 롤아웃 할 디플로이먼트 생성. 레플리카셋은 백그라운드에서 파드를 생성한다. 롤아웃 상태를 체크해서 성공 여부를 확인한다.\n- 디플로이먼트의 podtemplatespec을 업데이트해서 파드의 새로운 상태를 선언한다. 새 레플리카셋이 생성되면, 디플로이먼트는 파드를 기존 레플리카셋에서 새로운 레플리카셋으로 속도를 제어하며 이동하는 것을 관리한다. 각각의 새로운 레플리카셋은 디플로이먼트의 수정 버전에 따라 업데이트한다.\n- 만약 디플로이먼트의 현재 상태가 안정적이지 않은 경우 디플로이먼트의 이전 버전으로 롤백한다. 각 롤백은 디플로이먼트의 수정 버전에 따라 업데이트한다.\n- 더 많은 로드를 위해 디플로이먼트의 스케일 업.\n- 디플로이먼트 롤아웃 일시 중지로 podtemplatespec에 여러 수정 사항을 적용하고, 재개하여 새로운 롤아웃을 시작한다.\n- 롤아웃이 막혀있는지를 나타내는 디플로이먼트 상태를 이용.\n- 더 이상 필요 없는 이전 레플리카셋 정리.\n*레플리카셋은 파드의 스케줄링 개수 등을 설정하여 파드의 갑작스런 중단이나 상태 변경에 유연하게 대응하기 위한 오브젝트이다.*\n\n## 차이점\n\n유스케이스 비교를 하면 비로소 두 스케줄링 방식의 결정적인 차이를 알 수 있다.\n디플로이먼트는 상태 일시 중지, 수정 후 재개 등 유연한 상태 관리가 가능하며, **파드는 하나의 묶음처럼 관리되어** 서비스 노출 시 무엇을 노출해도 상관이 없기에 **랜덤 선택**되어 포워딩하게 된다.\n\n**보다 통합적인 파드 묶음 관리**로의 특성을 보이는 것이다.\n\n# 둘의 yaml 코드 비교\n\n## deployment\n이것 역시 한국어 문서에서 가져온 예시 코드이다.\n```yaml\napiversion: apps/v1\nkind: deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchlabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerport: 80\n```\n\n3개의 파드를 스케줄링하는 레플리카셋을 디플로이먼트로 묶어 관리하는 형태이다.\n이 때, 각각의 레플리카셋 내의 컨테이너에서 80번의 포트를 열어 nginx가 컨테이너 외부로 나갈 수 있게 허가한다. *(이것은 nginx 프록시 설정에 따라 바뀐다.)*\n\n## statefulset (persistent)\n\n```yaml\napiversion: v1\nkind: service\nmetadata:\n  name: nginx\n  labels:\n    app: nginx\nspec:\n  ports:\n  - port: 80\n    name: web\n  clusterip: none\n  selector:\n    app: nginx\n---\napiversion: apps/v1\nkind: statefulset\nmetadata:\n  name: web\nspec:\n  selector:\n    matchlabels:\n      app: nginx # .spec.template.metadata.labels 와 일치해야 한다\n  servicename: \"nginx\"\n  replicas: 3 # 기본값은 1\n  minreadyseconds: 10 # 기본값은 0\n  template:\n    metadata:\n      labels:\n        app: nginx # .spec.selector.matchlabels 와 일치해야 한다\n    spec:\n      terminationgraceperiodseconds: 10\n      containers:\n      - name: nginx\n        image: registry.k8s.io/nginx-slim:0.8\n        ports:\n        - containerport: 80\n          name: web\n        volumemounts:\n        - name: www\n          mountpath: /usr/share/nginx/html\n  volumeclaimtemplates:\n  - metadata:\n      name: www\n    spec:\n      accessmodes: [ \"readwriteonce\" ]\n      storageclassname: \"my-storage-class\"\n      resources:\n        requests:\n          storage: 1gi\n```\n\n이것 역시 nginx의 80 포트를 서비스한다. 이 statefulset은 pvc(persistent volume claim) 템플릿을 가진 **퍼시스턴트 스테이트풀셋이다.**\n\n# 결론\n\nstatefulset은 파드를 생성 후 개별 파드가 서로 다른 형태로 변경되고 분화되어야 하는 경우에 적용 가능할 것이다. 초기 3개의 파드를 만들고 개별로 관리하고 변경하려면 묶음 관리하는 deployment의 방식은 좋지 않다.\n\ndeployment는 여러 파드들을 통일감있게, 여분의 레플리카 리소스 등을 균일하게 관리해야 할 때 적합하다. 무중단, 고가용성 서비스를 위해 프록시 설정을 하고, 동일한 프록시가 레플리카로 구비되어있어야 한다면 이것이 적합할 것이다.\n\n# 참조\n\n[deployment](https://kubernetes.io/ko/docs/concepts/workloads/controllers/deployment/)\n[replicaset](https://kubernetes.io/ko/docs/concepts/workloads/controllers/replicaset/)\n[statefulset](https://kubernetes.io/ko/docs/concepts/workloads/controllers/statefulset/)\n"
    },
    {
      "title": "동적 프로비저닝을 구성해 보자-쿠버네티스(kubeADM)",
      "subtitle": null,
      "description": null,
      "url": "/cloud/2025-05-28-동적-프로비저닝을-구성해-보자-쿠버네티스(kubeADM)/",
      "collection": "cloud",
      "relative_path": "2025-05-28-동적-프로비저닝을-구성해-보자-쿠버네티스(kubeADM)",
      "date": "2025-05-28T12:39:20+09:00",
      "updated": null,
      "keywords": [
        "Kubernetes",
        "Dynamic Provisioning",
        "NFS",
        "Storage Class"
      ],
      "categories": [
        "cloud"
      ],
      "taxonomy": {
        "category": "cloud",
        "subcategory": "kubernetes",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "동적 프로비저닝이란? 동적 프로비저닝은 쿠버네티스에서 퍼시스턴트 볼륨 요청(PVC)을 했을 때 동적으로 퍼시스턴트 볼륨(PV)를 생성하고 해당 스토리지를 요청한 프로세스에 연결해 주는 방식이다. 이러한 방식은 높은 유연성 과 자동화된 할당 정책, 배포 편리성 등의 까닭으로 클라우드 관리 시 자주 사용된다. 동적 프로비저닝 시 퍼시스턴트 볼륨은 기본으로 지정된 스토리지 클래스 범위에서 자동으로 할당된다. 이러한 까닭에, 스토리지 클래스가 이미 충분한 저장 공간을 가지고 있지 않고, 자동으로 설정된…",
      "search_text": "동적 프로비저닝을 구성해 보자-쿠버네티스(kubeadm) kubernetes dynamic provisioning nfs storage class cloud cloud kubernetes 동적 프로비저닝이란? 동적 프로비저닝은 쿠버네티스에서 퍼시스턴트 볼륨 요청(pvc)을 했을 때 동적으로 퍼시스턴트 볼륨(pv)를 생성하고 해당 스토리지를 요청한 프로세스에 연결해 주는 방식이다. 이러한 방식은 높은 유연성 과 자동화된 할당 정책, 배포 편리성 등의 까닭으로 클라우드 관리 시 자주 사용된다. 동적 프로비저닝 시 퍼시스턴트 볼륨은 기본으로 지정된 스토리지 클래스 범위에서 자동으로 할당된다. 이러한 까닭에, 스토리지 클래스가 이미 충분한 저장 공간을 가지고 있지 않고, 자동으로 설정된… \n\n# 동적 프로비저닝이란?\n\n동적 프로비저닝은 쿠버네티스에서 퍼시스턴트 볼륨 요청(pvc)을 했을 때 동적으로 퍼시스턴트 볼륨(pv)를 생성하고 해당 스토리지를 요청한 프로세스에 연결해 주는 방식이다.\n이러한 방식은 **높은 유연성**과 자동화된 할당 정책, 배포 편리성 등의 까닭으로 클라우드 관리 시 자주 사용된다.\n동적 프로비저닝 시 퍼시스턴트 볼륨은 기본으로 지정된 스토리지 클래스 범위에서 자동으로 할당된다.\n이러한 까닭에, 스토리지 클래스가 이미 충분한 저장 공간을 가지고 있지 않고, 자동으로 설정된 경우, 많은 서비스가 해당 스토리지 클래스에 몰리게 된다.\n\n정적 프로비저닝은 **세밀하고 직접적인 정책 관리**와 **배포 흐름에 대한 선후관계가 엄격**하기 때문에 명확한 워크플로우를 추구하거나 엄격한 보안 규칙이 적용되는 경우 사용된다.\n\n하지만 일반적인 클라우드 실습의 경우에는 일일이 pv, pvc를 생성하는 것을 가정하지 않고, 동적 프로비저닝이 활성화되어 있다는 가정 하에 진행된다.\n그리고, 깃랩과 같은 소규모 배포를 벗어난 서비스를 사용할 경우 퍼시스턴스가 복잡하게 설정되어 있으므로 이러한 기능이 있다면 유용하다.\n\n그러나 클라우드 컴퓨팅의 장점 중 하나는 리소스의 유연한 공유이다.\n따라서 많은 경우 스토리지 볼륨을 제공하는 노드와 컴퓨팅 노드를 분리하고, 개인 실습용 로컬 클러스터 구축 시에도 보통은 이러한 전략을 사용할 것이다.\n그럼, 노드 1개에 nfs를 설정하고, 설정된 파일시스템을 마운트하여 스토리지 클래스로 설정하는 과정을 알아보자.\n\n## 워커 노드 nfs 설정\n\n간단하게 모든 사용자가 모든 작업을 할 수 있는 파일시스템을 만들어 보자.\n노드가 외부로 노출되어서 서비스되는 등 보안이 취약해질 수 있는 경우 접근 권한 등은 알아서 수정하도록 하자.\n\nnfs를 설정할 노드에 접속하여 아래와 같은 파일을 만든다.\n\n```bash\n#!/bin/bash\necho \"setting up nfs storage...\"\napt install -y nfs-kernel-server ## 이 부분은 배포판에 따라 수정해야 함\nmkdir -p /mnt/k8s-storage-class\nchown nobody:nogroup /mnt/k8s-storage-class #폴더 소유자 부재 상태로 전환\nchmod 777 /mnt/k8s-storage-class #모든 사용자가 파일시스템 접근 권한이 있음.\necho \"/mnt/k8s-storage-class 192.168.0.*/24(rw,sync,no_subtree_check,no_root_squash)\" >> /etc/exports #클라이언트에서 서브디렉토리, 루트 권한 취득 허가\nsystemctl restart nfs-server\nexportfs -arv #export fs\necho \"\"\"\n#################################################\n## if you are using firewalld:                  #\n## firewall-cmd --permanent --add-service=nfs   #\n## firewall-cmd --reload                        #\n#################################################\n## if you are using ufw:                       ##\n## ufw allow nfs                               ##\n#################################################\n\"\"\"\n```\n\n이렇게 되면 폴더는 자연스레 사용자의 소유권에 따라 맞춰질 것이다.\n\n하지만, 이대로는 nfs가 설정되었을 뿐이지 쿠버네티스 스토리지 클래스에서 nfs를 저장공간으로 쓰지도 않고, 여전히 pvc는 대기 상태에서 걸려 있을 수밖에 없다.\n바로 노드의 ip를 기억 후에 아래로 내려가자. kubectl로 확인해도 좋고, `ip addr`로 확인해도 좋다.\n\n## 스토리지 클래스 생성 \n그렇다면, 다음으로 storageclass를 생성해 보자.\n다행인 것은, nfs 스토리지를 저장공간으로 쓰는 스토리지 클래스는 헬름 차트로 손쉽게 생성 가능하다.\n역시 빠르게 스크립트부터 보자.\n\n```bash\nhelm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner\nhelm update\nhelm install nfs-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \\\n    --set nfs.server=$your_nfs_server_ip \\\n    --set nfs.path=/mnt/k8s-storage-class \\\n    --set storageclass.defaultclass=true \\\n    --set storageclass.reclaimpolicy=delete\nsudo apt install -y nfs-common\n```\nexport 등으로 your_nfs_ip를 정의해야 하고, 이것은 노드 주소로 설정해야 한다.\n그 후 생성한 스크립트를 실행하면 배포가 완료되고 `kubectl get storageclass`를 하면 (default) 태그로 스토리지클래스가 설정이 되어 있을 것이다.\n\n## gitlab 배포\n이제, 테스트 삼아 gitlab을 배포해 보자.\n\n```bash\n#!/bin/bash\nexport your_domain=example.com\nexport your_email=me@example.com\nexport your_public_ip=10.10.10.10\n```\n이것과 같이 자신의 정보에 맞게 스크립트를 만들어 주자.\n그러나, public ip로 바로 체결되지 않은 경우 그냥 \"\"로 비워두자.\n\n이제 `export` 명령을 실행해 보면 메일 등의 주소가 환경 변수로 설정된 것을 볼 수 있다.\n\n그럼, 깃랩 설치를 위한 스크립트도 짜 보자. 아주 간단하다.\n명령어에서 요구하는 것 역시 모두 환경변수에 있다.\n\n```bash\n#!/bin/bash\nhelm repo add gitlab https://charts.gitlab.io/\nhelm repo update\nkubectl create ns gitlab\nhelm upgrade --install gitlab gitlab/gitlab \\\n  --timeout 600s \\\n  --set global.hosts.domain=$your_domain \\\n  --set global.hosts.externalip=$your_public_ip \\\n  --set certmanager-issuer.email=$your_email \\\n  --set gitlab.gitlab-rails.initialrootemail=$your_email \\\n  --namespace gitlab\n```\n이 때, 공인 ip를 쓰지 않고 비워둔 경우 `kubectl get svc -n gitlab`를 해 보자.\ngitlab-nginx-ingress-controller은 `loadbalancer` 타입으로 생성되어 있고, ip는 할당되지 않고 대기 상태일 것이다.\n이렇다면, metallb를 설정 후, 서비스를 수정해야 한다. \n\n```bash\nkubectl edit configmap -n kube-system kube-proxy\nkubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.9/config/manifests/metallb-native.yaml\n```\nmetallb가 설정되었다. 하지만 할당하기 위한 ip 범위를 설정하지 않았다. 이를 설정하도록 하자.\n\n```yaml\napiversion: metallb.io/v1beta1\nkind: ipaddresspool\nmetadata:\n  name: gitlab-metallb-pool\n  namespace: metallb-system\nspec:\n  addresses:\n    - 192.168.1.200-192.168.1.250\n  autoassign: true\n```\n\n편하게 192.168.1.200 - 192.168.1.250으로 하고, yaml을 `kubectl apply`로 적용하자.\n이제 ip 대역이 설정되었다. 실제로 같은 네트워크 레벨에서 ip를 할당하기 위해 l2 advertiser를 설정하자.\n\n```yaml\napiversion: metallb.io/v1beta1\nkind: l2advertisement\nmetadata:\n  name: gitlab-l2-advertisement\n  namespace: metallb-system\nspec:\n  ipaddresspools:\n    - gitlab-metallb-pool\n```\n마찬가지로 적용해 준다.\n\n`kubectl edit svc gitlab-nginx-ingress-controller -n gitlab`을 해 보자.\n만약 실수로 공인 ip를 기입했다면 열린 서비스 yaml에서 공인 ip를 삭제하자.\n\n이후 조금 기다리면 192.168.1.200으로 첫 ip가 metallb를 통해 할당된다.\n다시 `kubectl get svc -n gitlab`하고 노출 포트에 따라 적절히 포워딩한 후 웹 ui로 접속하자.\nroot의 비밀번호를 몰라서 로그인이 안 될 것이다.\n이것은 gitlab의 base64 인코딩된 시크릿을 읽어서 확인하면 된다. \n```bash\nkubectl get secret gitlab-gitlab-initial-root-password -ojsonpath='{.data.password}' -n gitlab | base64 --decode; echo\n```\n\n다음으로 확인한 비밀번호로 접속하면 관리자로 로그인된다.\n"
    },
    {
      "title": "리눅스 I2C 슬레이브 디바이스",
      "subtitle": "리눅스 커널에서 I2C 슬레이브 디바이스 이해하기",
      "description": null,
      "url": "/embedded/2025-05-10-리눅스-I2C-슬레이브-디바이스/",
      "collection": "embedded",
      "relative_path": "2025-05-10-리눅스-I2C-슬레이브-디바이스",
      "date": "2025-05-19T13:00:00+09:00",
      "updated": null,
      "keywords": [
        "I2C",
        "슬레이브 디바이스",
        "리눅스 커널",
        "임베디드 시스템"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-linux",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "I2C란? I2C는 Inter-Integrated Circuit의 약자로, 8bit 패킷을 주고받으며 간단한 입출력을 지원하는 2-Wire 인터페이스를 뜻합니다. I2C 버스 I2C 버스는 각각의 I2C 디바이스들이 연결된 마스터-슬레이브 구조를 의미합니다. 마스터는 슬레이브에 데이터 전송을 요청하고 슬레이브는 마스터에 데이터로 응답합니다. 이러한 구조에서는 하드웨어 장치는 절대적으로 슬레이브에 있다는 것을 알 수 있습니다. 하나의 마스터에 연결 가능한 최대 슬레이브 디바이스의 개수는 이론상 27…",
      "search_text": "리눅스 i2c 슬레이브 디바이스 리눅스 커널에서 i2c 슬레이브 디바이스 이해하기 i2c 슬레이브 디바이스 리눅스 커널 임베디드 시스템 embedded embedded embedded-linux i2c란? i2c는 inter-integrated circuit의 약자로, 8bit 패킷을 주고받으며 간단한 입출력을 지원하는 2-wire 인터페이스를 뜻합니다. i2c 버스 i2c 버스는 각각의 i2c 디바이스들이 연결된 마스터-슬레이브 구조를 의미합니다. 마스터는 슬레이브에 데이터 전송을 요청하고 슬레이브는 마스터에 데이터로 응답합니다. 이러한 구조에서는 하드웨어 장치는 절대적으로 슬레이브에 있다는 것을 알 수 있습니다. 하나의 마스터에 연결 가능한 최대 슬레이브 디바이스의 개수는 이론상 27… \n\n## i2c란?\n\ni2c는 inter-integrated circuit의 약자로, 8bit 패킷을 주고받으며 간단한 입출력을 지원하는 2-wire 인터페이스를 뜻합니다.\n\n## i2c 버스\n\ni2c 버스는 각각의 i2c 디바이스들이 연결된 마스터-슬레이브 구조를 의미합니다.\n\n마스터는 슬레이브에 **데이터 전송을 요청하고**\n슬레이브는 마스터에 **데이터로 응답합니다.**\n\n이러한 구조에서는 하드웨어 장치는 절대적으로 슬레이브에 있다는 것을 알 수 있습니다.\n\n하나의 마스터에 연결 가능한 최대 슬레이브 디바이스의 개수는 이론상 27(128)개입니다.\n그러나 실제로는 24(16)개 만큼이 예약되어 있어 27-264(112)개의 최대 장치 수를 가집니다.\n\n그런데, i2c 버스에 대해 조금 검색해 보신 분들은 i2c smbus라는 걸 많이 들어 봤을 것입니다. smbus가 대체 무엇의 약자인지 생각해 보지 않은 사람들도 많을 것입니다.\n이것은 **standard-mode bus** 라는 뜻이고, 다른 모드도 존재합니다.\n\n이제 버스의 종류를 알아 보도록 하겠습니다.\n\n<div style=\"text-align: center;\">\n  <table style=\"border-collapse: collapse; width: 100%; borderl 1px solid black;\">\n    <thead style=\"background color: #f2f2f2;\">\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">mode</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">speed</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">standard mode(sm)</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">100 kbit/s</th>\n      </tr>\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">fast mode(fm)</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">400 kbit/s</th>\n      </tr>\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">fast mode plus(fm+)</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">1 mbit/s</th>\n      </tr>\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">high-speed mode(hs-mode)</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">3.4 mbit/s</th>\n      </tr>\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">ultra-fast speed mode(ufm)</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">5 mbit/s</th>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\nfast-mode 등의 속도가 안정성보다 우선시되는 작업을 위한 고속 버스도 눈에 띕니다.\n대부분의 i2c bus는 standard bus인 경우가 많으나 특수한 경우를 위해 기억해 둡시다.\n\n## i2c 인터페이스\n\ni2c 인터페이스는 sda(**s**erial **da**ta), scl(**s**erial **cl**ock) 두 개의 핀을 통해 구성됩니다.\n패킷 1개의 길이는 8bit입니다.\n\n패킷 송/수신이 완료된 후에만 stop 시그널을 보냅니다.\n송/수신에 실패하는 등의 상황이 생기면 stop 시그널이 생성되지 않았으므로 동일 패킷에 대한 start 시그널이 다시 들어오거나 나갈 수 있습니다.\n\n패킷은 읽기, 쓰기 값을 의미하는 초기 1비트와 7bit의 페이로드로 구성됩니다.\n\n--------------------------\n\n<table>\n  <tr>\n    <td style=\"border: 1px solid red; padding: 8px; text-align: center;>0x00</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x01</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x02</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x03</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x04</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x05</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x06</td>\n    <td style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x07</td>\n  </tr>\n</table>\n0x00 주소의 값이 **0인 경우** i2c 동작은 쓰기 동작입니다.\n0x00 주소의 값이 **1인 경우** i2c 동작은 읽기 동작입니다.\n\n**i2c는 편리한 입출력 작업을 위한 2-wire 인터패이스**라고 이해하시면 편하고, 낮은 비용으로 반이중 제어가 필요한 디바이스들을 다수 관리할 수 있습니다.\n\n## i2c 디바이스 드라이버 작성\n\n### i2c 어댑터 정의\n\ni2c 어댑터를 가져오기 위한 c 함수 원형은 다음과 같습니다.\n```c\nstruct i2c_adapter *i2c_get_adapter(int nr);\n```\n만약 1번 버스를 가져오고 싶다면, 다음과 같이 하면 됩니다.\n\n```c\nstruct i2c_adapter *adapter = null;\nadapter = i2c_get_adapter(1);\nif(adapter == null) {\n    fprintf(stderr, \"i2c bus 1 is unavailable\");\n    //null check하기\n}\n```\n### 보드 정보 작성\n\n보드 정보에 대한 구조체 원형은 필드가 아주 단순하지만은 않습니다.\n\n```c\nstruct i2c_board_info {\n    char type[i2c_name_size];\n    unsigned short flags;\n    unsigned short addr;\n    void *platform_data;\n    struct dev arch_data *archdata;\n    struct device_node *of_node;\n    int irq;\n};\n```\n\n당연히 이 필드를 직접 채워넣는 것은 수고롭습니다.\n이런 수고를 덜어주기 위한 매크로 함수를 사용하도록 합시다.\n```c\ni2c_board_info(dev_type, dev_addr);\n```\n같은 식으로 넣어 줍니다.\n\n여기서는 led 제어 장치가 0x20 슬레이브 주소에 인식되었다고 가정해 봅시다.\n\n```c\nstruct i2c_board_info led_controller = {\n    i2c_board_info(\"led_ctrl\", 0x20);\n}\n```\n\n### 새 디바이스 클라이언트 생성\n\n```c\nstruct i2c_client *i2c_new_device(i2c_adapter *adapter, i2c_board_info *boardinfo);\n```\n앞의 내용들을 어댑터 가져오기-> 디바이스 클라이언트 생성 순으로 적용해 봅시다.\n\n```c\n#define slave_device_name led_ctrl\n#define slave_addr 0x20\n#define i2c_available_bus 1\nstatic struct i2c_adapter *adapter = null;\nstatic struct i2c_client  *client  = null;\nstatic struct i2c_board_info info = {\n    i2c_board_info\n    (\n        slave_device_name,\n        slave_addr\n    )\n};\n\nstatic int __init driver_init(void) {\n    adapter = i2c_get_adapter(i2c_available_bus);\n    client  = i2c__new_device(adapter, \n    return 0;\n};\n```\n### next\n이번 튜토리얼에선 i2c를 이해하고 디바이스 클라이언트를 생성하는 것까지 완료하였습니다.\n다음 시간에는 본격적인 제어 함수들을 다뤄 보도록 합시다.\n"
    },
    {
      "title": "라즈봇 디바이스 드라이버 작성-모터편 1",
      "subtitle": "IOCTL 기반 I2C 슬레이브 제어 드라이버 구현",
      "description": null,
      "url": "/embedded/2025-05-10-라즈봇-디바이스-드라이버-작성-모터편-1/",
      "collection": "embedded",
      "relative_path": "2025-05-10-라즈봇-디바이스-드라이버-작성-모터편-1",
      "date": "2025-05-10T12:00:00+09:00",
      "updated": null,
      "keywords": [
        "디바이스 드라이버",
        "I2C",
        "IOCTL",
        "라즈베리파이",
        "모터 제어"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-linux",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "라즈봇 디바이스 드라이버 작성(모터 편) - 1 개요 IOCTL로 I2C 슬레이브를 제어하는 디바이스 드라이버를 작성해 봅시다. 작성 계획 쉬운 모터 제어 : 먼저, 전진, 후진, 좌회전, 우회전을 고정 속도로 만들어 봅시다. 정밀한 제어 : 바퀴의 속도와 회전 방향을 I2C 쓰기 동작 버퍼를 직접 지정하여 제어해 봅시다. 우선, IOCTL 캐릭터 디바이스 형태로 일종의 더미 디바이스를 만들어 주는 구조가 관리하기 편합니다. 이 더미 디바이스는 적절한 I/O 요청을 받아, I2C 슬레이브가 이해…",
      "search_text": "라즈봇 디바이스 드라이버 작성-모터편 1 ioctl 기반 i2c 슬레이브 제어 드라이버 구현 디바이스 드라이버 i2c ioctl 라즈베리파이 모터 제어 embedded embedded embedded-linux 라즈봇 디바이스 드라이버 작성(모터 편) - 1 개요 ioctl로 i2c 슬레이브를 제어하는 디바이스 드라이버를 작성해 봅시다. 작성 계획 쉬운 모터 제어 : 먼저, 전진, 후진, 좌회전, 우회전을 고정 속도로 만들어 봅시다. 정밀한 제어 : 바퀴의 속도와 회전 방향을 i2c 쓰기 동작 버퍼를 직접 지정하여 제어해 봅시다. 우선, ioctl 캐릭터 디바이스 형태로 일종의 더미 디바이스를 만들어 주는 구조가 관리하기 편합니다. 이 더미 디바이스는 적절한 i/o 요청을 받아, i2c 슬레이브가 이해… \n\n# 라즈봇 디바이스 드라이버 작성(모터 편) - 1\n\n### 개요\nioctl로 i2c 슬레이브를 제어하는 디바이스 드라이버를 작성해 봅시다.\n\n### 작성 계획\n* **쉬운 모터 제어**: 먼저, 전진, 후진, 좌회전, 우회전을 고정 속도로 만들어 봅시다.\n* **정밀한 제어**: 바퀴의 속도와 회전 방향을 i2c 쓰기 동작 버퍼를 직접 지정하여 제어해 봅시다.\n\n우선, ioctl 캐릭터 디바이스 형태로 일종의 더미 디바이스를 만들어 주는 구조가 관리하기 편합니다.\n이 더미 디바이스는 적절한 i/o 요청을 받아, i2c 슬레이브가 이해 가능한 형태로 번역해 줘야 합니다.\n가장 먼저, 간단한 알고리즘 구현 혹은 테스트를 위해 기본적인 4가지 동작을 정의해 봅시다.\n\n```bash\neditor ioctl_motor_cmd.h # 기본 에디터로 작성할 헤더 파일 생성\n```\n\n먼저, 헤더의 중복 포함을 검사하기 위한 매크로를 다음과 같이 2줄 작성합니다.\n\n```c\n#ifndef ioctl_motor_cmd_h\n#define ioctl_motor_cmd_h\n```\n\n구문을 하나하나 우리말로 풀어 봅시다.\n```text\n만약 io 제어 모터 명령어 헤더가 미리 정의되지 않았다면,\n    io 제어 명령어 헤더를 정의합니다.\n```\n\n그렇다면, 헤더를 두 번 포함시키려 해도 이 매크로에서 방지해 주게 됩니다.\n\n그 말은,\n\n---\n\n1. 최초로 헤더 포함 시도\n - 만약 헤더가 포함되어 있었는지 확인\n - 미포함\n - 승인\n\n2. 두 번째로 헤더 포함 시도\n - 만약 헤더가 포함되어 있었는지 확인\n - 포함\n - 미승인\n\n---\n\n과 같은 식으로 동작하게 된다는 것을 의미합니다.\n\n이제 본격적으로 ioctl에 대한 매크로와 자료형을 정의해 봅시다.\n\n```c\n#include<linux/ioctl.h>\n```\n\n이 헤더를 포함시켜 주어 요구 사항을 충족시켜 주도록 합시다.\n\n이제 정보를 보내기 위한 구조체를 보내 보도록 하겠습니다.\nyahboom 라즈봇의 i2c 칩은 다음과 같은 명령어 양식을 받습니다.\n\n<div style=\"text-align: center;\">\n  <table style=\"border-collapse: collapse; width: 100%; border: 1px solid black;\">\n    <thead style=\"background-color: #f2f2f2;\">\n    <tr>\n      <th style=\"border: 2px solid orange; padding: 8px; text-align: center;\">시작 비트</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">왼쪽 바퀴 방향</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">왼쪽 바퀴 속도</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">오른쪽 바퀴 방향</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">오른쪽 바퀴 속도</th>\n    </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <th style=\"border: 2px solid orange; padding: 8px; text-align: center;\"> 0x01 </th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\"> 0 혹은 1 </th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\"> 0 - 100 </th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\"> 0 혹은 1 </th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\"> 0 - 100 </th>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n--------\n\n<div style=\"text-align: center;\">\n  <table style=\"border-collapse: collapse; width: 100%; border: 1px solid black;\">\n    <thead style=\"background-color: #f2f2f2;\">\n    <tr>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">전진</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">후진</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x01</th>\n      <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">0x00</th>\n    </tr>\n    </tbody>\n  </table>\n</div>\n\n속도는 100단계로 다소 단계 수가 적습니다.\n0일 시 바퀴가 멈추고, 100일 시 전속력으로 회전합니다.\n\n\n이에 맞는 io 정보 구조체를 작성해 봅시다.\n\n```c\nstruct ioctl_info {\n    unsigned long size;\n    char buf[5];\n}\n```\nioctl 형식의 io 제어 구조체에서 보낼 정보에 대한 크기는 관습적으로 long입니다.\n우리가 보내야 할 정보는 위에서 언급한 양식을 따르는 5 바이트 크기의 버퍼입니다.\n\n따라서 이렇게 정의한 후 실제 사용할 때는 size는 늘 5가 될 것이고, size != 5일 시 오염된 요청으로 간주하고 해당 제어 요청을 거부하게 될 것입니다.\n\n그리고, 앞서 언급했듯 사용자의 편의를 위해 기초 동작들을 고정 속도로 정의하기로 했습니다.\n즉, 한 종류의 ioctl 명령어만을 사용하지 않게 된 것입니다.\n다양한 요청들에 대한 식별 번호를 열거형으로 쉽게 구현해 봅시다.\n예약어들을 피하기 위해 3부터 열거합니다.\n```c\nenum {\n    cmd_left = 3,\n    cmd_right,\n    cmd_forward,\n    cmd_forward_slow,\n    cmd_backward,\n    cmd_stop,\n    cmd_io,\n}\n```\n\n이렇게 선언하면 3, 4, 5 ... 순으로 자연히 동작 별로 번호가 부여됩니다.\n\n자, 그럼 이 ioctl 디바이스의 호출을 검증하기 위한 매직 넘버를 지정하겠습니다.\n이 매직이 일치하는지 검사하여 바른 요청인지를 알 수 있습니다.\n이번에는 무난하게 문자형 'g'를 사용하도록 하겠습니다.\n\n```c\n#define ioctl_magic 'g'\n```\n\n그럼 이제 실제 ioctl 커맨드 양식으로, 호출을 정의하도록 하겠습니다.\n\n정의하는 형식은,\n\n`_지정동작(매직넘버, 요청 번호, 전달할 자료형)`\n\n지정 동작에는 여러 종류가 있지만 대표적인 r/w에 대해 소개하겠습니다.\n\ni2c 칩으로부터 동작을 읽어와야 할 경우, \n```c\n_ior(magic, cmd_num, datatype)\n```\n으로 요청하게 됩니다.\n\n그렇다면, 동작을 써야 하는 경우는 어떠할까요?\n이 부분은 이번에 저와 함꼐 구현하게 되실 부분입니다.\n```c\n_iow(magic, cmd_num, datatype)\n```\n앞서 말한 구조체 등을 활용하면,\n```c\n#define pi_cmd_left _iow(ioctl_magic, cmd_left, struct ioctl_info)\n```\n와 같이 동작을 정의할 수 있겠습니다.\n나머지 동작들도 이와 같이 작성하면 어렵지 않습니다.\n또한, 이번에는 r/w가 모두 필요한 경우를 가정해 봅시다,\n이 때를 위한 동작은,\n```c\n_iowr(magic, cmd_num, datatype)\n```\n과 같습니다.\n이러한 동작이 필요한 동작을 가정해 봅시다.\ni2c 칩은 적외선 led에 대한 쓰기 권한과 스캔 위치의 표면 온도를 감지 가능한 열감지 센서에 대한 읽기 권한이 있다고 합시다.\n호출은 적외선을 발산하는 동시에 표면 온도를 읽어 개발자에게 전달해야 합니다.\n이러한 동작을 처리하기 위한 호출로는 `_iowr`은 아주 적합한 선택이 될 것입니다. \n\n필요하다고 생각하는 동작들을 적당히 정의해 주신 후 다음 단계로 넘어가겠습니다.\n\n### 디바이스 드라이버 작성 - part 1\n\n이제, 앞서 말한 정보를 토대로 디바이스 드라이버의 초반부를 작성해 봅시다.\n\n```c\n#include \"ioctl_modor_cmd.h\" //앞서 작성한 헤더 포함\n#define max_speed 0x63 //십진수로 100\n#define mid_speed  0x4f //십진수로 79\n#define min_speed 0x00\n\n#define i2c_bus_available 1 //모터 제어 칩은 1번 버스에 연결되어 있음.\n//주로 0번은 보드 내에 통합된 버스인 경우가 많으며, 확장 기기 등의 버스는 1번 이상임.\n#define slave_dev_name \"motordev\" //적절하게 슬레이브에 대한 이름을 지어 주어야 함.\n#define motor_slave_addr 0x16 //모터는 1번 버스, 0x16번 주소에 인식됨.\n\nstatic struct i2c_adapter *motori2cadapter = null;\nstatic i2c_client *motori2cclient = null;\n\nchar left[5] =       { 0x01, 0x00, mid_speed, 0x01, mid_speed };\nchar right[5] =      { 0x01, 0x01, mid_speed, 0x00, mid_speed }; \n/*\n   회전은 너무 빠른 속도로 진행될 시에 섬세한 제어가 힘이 듭니다.\n   아무리 간단한 예약어라고 하더라도 느리게 회전하는 편이 낫습니다.\n*/\n\n\nchar forward[5] = { 0x01, 0x01, max_speed, 0x01, max_speed };\nchar forward_slow[5] = { 0x01, 0x01, mid_speed, 0x01, mid_speed };\n//이 경우도 빠른 전진과 느린 전진으로 두 가지 경우를 선언하는 것이 좋아 보입니다.\n\nchar backward[5] = { 0x01, 0x00, max_speed, 0x00, max_speed };\n\n/* 후진에 대한 정의입니다. 지나치게 속도가 빠른 감이 있으나, \n   이 기기에 후진을 위한 센서가 없으므로 실제로 사용될 경우는 적을 것입니다.\n   만약 앞선 정의에서 느린 후진 등을 정의하셨다면 그에 맞게 정의해 주세요.\n예: char backward_slow[5] = { 0x01, 0x00, mid_speed, 0x00, mid_sped };\n*/\n\nchar stop[5] =      { 0x01, 0x00,    0x00, 0x00,    0x00   };\n\n```\n\n이제 하드웨어를 제어하기 위한 기본적인 초반 정의는 끝났습니다.\n다음 시간에는, i2c 슬레이브 디바이스에 대해 알아보겠습니다.\n"
    },
    {
      "title": "DFS와 BFS의 시각적 차이",
      "subtitle": null,
      "description": null,
      "url": "/codingtest/2025/05/09/dfs-bfs.html",
      "collection": "posts",
      "relative_path": "_posts/2025-05-09-BFS와-DFS-시각화.md",
      "date": "2025-05-09T22:47:00+09:00",
      "updated": null,
      "keywords": [
        "DFS",
        "BFS",
        "Visualization",
        "Algorithm"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-graph",
        "order": 1
      },
      "difficulty": "beginner",
      "excerpt": "DFS와 BFS의 시각화 비교 연습 문제를 풀다 보면 DFS(깊이 우선 탐색)를 쓸지, BFS(너비 우선 탐색)를 쓸지 결정하는 것이 항상 간단한 일은 아닙니다. 알고리즘의 기본 원리를 이해했다고 하더라도, 실제 상황에서는 그 선택이 문제의 본질과 직접적으로 연결되기 때문입니다. 이런 고민 끝에, DFS와 BFS를 직접 시각화해서 그 차이를 직관적으로 비교해보기로 했습니다. 해당 시각화는 120x120 크기의 장애물 없는 격자에서 DFS와 BFS를 시작 지점 으로부터 실행하고, 그 탐색 경과를 이…",
      "search_text": "dfs와 bfs의 시각적 차이 dfs bfs visualization algorithm codingtest codingtest algorithm-graph dfs와 bfs의 시각화 비교 연습 문제를 풀다 보면 dfs(깊이 우선 탐색)를 쓸지, bfs(너비 우선 탐색)를 쓸지 결정하는 것이 항상 간단한 일은 아닙니다. 알고리즘의 기본 원리를 이해했다고 하더라도, 실제 상황에서는 그 선택이 문제의 본질과 직접적으로 연결되기 때문입니다. 이런 고민 끝에, dfs와 bfs를 직접 시각화해서 그 차이를 직관적으로 비교해보기로 했습니다. 해당 시각화는 120x120 크기의 장애물 없는 격자에서 dfs와 bfs를 시작 지점 으로부터 실행하고, 그 탐색 경과를 이… \n\n# dfs와 bfs의 시각화 비교\n\n연습 문제를 풀다 보면 dfs(깊이 우선 탐색)를 쓸지, bfs(너비 우선 탐색)를 쓸지 결정하는 것이 항상 간단한 일은 아닙니다. 알고리즘의 기본 원리를 이해했다고 하더라도, 실제 상황에서는 그 선택이 문제의 본질과 직접적으로 연결되기 때문입니다.\n\n이런 고민 끝에, dfs와 bfs를 직접 시각화해서 그 차이를 직관적으로 비교해보기로 했습니다.\n\n해당 시각화는 120x120 크기의 장애물 없는 격자에서 dfs와 bfs를 시작 지점 `(0, 0)`으로부터 실행하고, 그 탐색 경과를 `.bmp` 이미지로 저장한 것입니다. 시각화 소스 코드는 맨 아래에 첨부한 github 저장소에서 확인할 수 있습니다.\n\n\n## dfs (depth-first search)\n\ndfs는 말 그대로 \"깊이 우선\" 탐색입니다. 가능한 한 깊게 탐색한 뒤, 더 이상 탐색할 노드가 없을 경우에야 되돌아옵니다. 이는 일종의 백트래킹 구조를 띠며, 재귀적으로 다음 노드를 따라 내려가는 방식입니다.\n\n예제 레포지토리 내의 dfs 코드는 다음과 같습니다. dfs/bfs 모두 bmp_class.cpp에 정의되어 있고 bitmap 클래스 안의 메서드입니다.\n\n```cpp\n    void dfs(int row, int col, int depth) {\n        if(!is_avail(row,col)) return;\n        visited[row][col] = true;\n        image_data[row][col].color(depth);\n        int drow[] = {-1,1,0,0};\n        int dcol[] = {0,0,-1,1};\n        for(int i = 0; i < 4; i++) {\n            int nrow = row+drow[i], ncol = col+dcol[i];\n            if(is_avail(nrow,ncol)) {\n                dfs(nrow,ncol,depth+cnt);\n            }\n        }\n    }\n ```\n\n이와 같이 재귀 깊이와 다음 순회 위치를 주면서 코드가 진행됩니다.\n\n`image_data[row][col].color(depth);` 구문이 실행될 때 이미지 상에서 색상이 깊이에 따라 변화하며, 실제로 깊은 영역일수록 색이 변화된 것을 볼 수 있습니다. 탐색이 한 방향으로 깊게 진행되다 보니, 일부 영역이 빠르게 깊은 색상(청록 등)으로 채색됩니다.\n이는 탐색 깊이에 따라 색상이 다음과 같이 표현되었기 때문입니다:\n\n- 검정 → 파랑 → 청록\n\n이는 `.bmp`의 픽셀 단위가 rgb 순서(blue → green → red)로 저장되기 때문이며, dfs의 재귀 깊이를 시각화하기 적절한 방법입니다.\n\n![dfs]({{\"/assets/images/dfs.bmp\" | relative_url}})\n\n> 위 이미지: dfs의 탐색 결과. 깊게 찌르듯 한쪽으로 파고드는 경향이 보인다.\n\n이러한 방식은 특정 노드까지의 **최단 거리**를 구하는 데에는 적합하지 않습니다. dfs는 경로의 깊이만을 추적하며, 경로의 효율성이나 최소성에는 관여하지 않기 때문입니다.\n\n## bfs (breadth-first search)\n\nbfs는 **시작 지점으로부터 일정 거리**를 두고 넓게 퍼져나가는 방식으로 탐색합니다. 가장 가까운 노드부터 순차적으로 처리하기 때문에, 특정 노드까지의 최소 이동 횟수를 계산하는 데 매우 유리합니다.\n\n```cpp\n   void bfs(int row, int col) {\n        std::queue<pair<int,int>> q;\n        q.push(make_pair(row,col));\n        image_data[row][col].color(0);\n        while(q.size()) {\n            pair<int,int> point = q.front();\n            int cur_row = point.first, cur_col = point.second;\n            visited[cur_row][cur_col] = true;\n            int cur_color = image_data[cur_row][cur_col].get_color();\n            q.pop();\n            int drow[] = {-1,1,0,0};\n            int dcol[] = {0,0,-1,1};\n            for(int i = 0; i < 4; i++) {\n                int nrow = drow[i]+cur_row, ncol = dcol[i]+cur_col;\n                if(is_avail(nrow,ncol)) {\n                    visited[nrow][ncol] = true;\n                    q.push(make_pair(nrow,ncol));\n                    image_data[nrow][ncol].color(cur_color+cnt);\n                }\n            }\n        }\n    }\n```\n\n이 bfs 구현에서는 큐와 적절한 방문처리를 통해 격자를 순회하고, cnt만큼 증감하며 픽셀 색상의 변화를 유도하였습니다.\n\n달리 말해 `(0,0)`에서부터의 거리 값에 따라 픽셀 색상을 채우도록 시각화한 것입니다. 결과적으로, 중심부에서 시작해 바깥쪽으로 부드럽게 색이 짙어지는 그래프가 생성됩니다.\n\n![bfs]({{\"/assets/images/bfs.bmp\" | relative_url}})\n\n> 위 이미지: bfs의 탐색 결과. 거리 기반 채색 덕분에 부드럽게 번지는 패턴을 보인다.\n\nbfs는 명확하게 거리 기반 탐색이 필요한 상황(최단 경로 탐색, 거리 측정 등)에 매우 적합하며, dfs와는 상반된 특성을 가집니다.\n완전탐색을 위한 백트래킹 기법 등은 재귀 깊이가 깊지 않다면 보다 간소한 dfs를 사용하는 것도 좋은 방법입니다.\n\n---\n\n## 결론\n\ndfs와 bfs는 각각 장단점이 뚜렷하며, 쓰임새도 명확히 구분됩니다.\n\n<div style=\"text-align: center;\">\n  <table style=\"border-collapse: collapse; width: 100%; border: 1px solid black;\">\n    <thead style=\"background-color: #f2f2f2;\">\n      <tr>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">알고리즘</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">특징</th>\n        <th style=\"border: 1px solid black; padding: 8px; text-align: center;\">적합한 상황</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td style=\"border: 1px solid black; padding: 8px;\">dfs</td>\n        <td style=\"border: 1px solid black; padding: 8px;\">깊게 파고듦. 스택/재귀 구조</td>\n        <td style=\"border: 1px solid black; padding: 8px;\">전체 경로 탐색, 백트래킹 문제</td>\n      </tr>\n      <tr>\n        <td style=\"border: 1px solid black; padding: 8px;\">bfs</td>\n        <td style=\"border: 1px solid black; padding: 8px;\">넓게 퍼짐. 큐 구조</td>\n        <td style=\"border: 1px solid black; padding: 8px;\">최단 거리 탐색, 레벨 기반 문제</td>\n      </tr>\n    </tbody>\n  </table>\n</div>\n\n텍스트만으로 이해하기 어려운 dfs와 bfs의 차이를 이미지로 시각화하면, 두 탐색 알고리즘의 특성과 용도를 보다 명확히 구분할 수 있습니다.\n\n---\n\n**참고 저장소**\ngithub: [traverse\\_visualization\\_bmp](https://github.com/gg582/traverse_visualization_bmp)\n\n"
    },
    {
      "title": "원격 자동차 제어 시스템",
      "subtitle": null,
      "description": null,
      "url": "/cloud/2025-05-09-원격-자동차-제어-시스템/",
      "collection": "cloud",
      "relative_path": "2025-05-09-원격-자동차-제어-시스템",
      "date": "2025-05-09T21:57:00+09:00",
      "updated": null,
      "keywords": [
        "Kubernetes",
        "Device Driver",
        "TCP",
        "Remote Control"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-projects",
        "order": 1
      },
      "difficulty": "intermediate",
      "excerpt": "Kubernetes와 TCP를 이용한 저지연 실시간 자동차 제어 1. 소개 소스 이 시스템은 원격에서 자동차를 제어할 수 있는 환경을 제공합니다. 이 프로젝트는 진성근 교수님의 실험실에서 나온 발췌입니다. 이 저장소에는 reader.sh를 비롯한 쉘로만 동작하는 초기 프로토타입 스크립트 몇 개를 제외하면 (reader.sh, car\\ controllser.sh, writer.sh, pod\\ car\\ run.sh와 같은 것) 쉘 스크립트, yaml, Go, C 모두 본인이 작성한 코드만 있으며, 타…",
      "search_text": "원격 자동차 제어 시스템 kubernetes device driver tcp remote control embedded embedded embedded-projects kubernetes와 tcp를 이용한 저지연 실시간 자동차 제어 1. 소개 소스 이 시스템은 원격에서 자동차를 제어할 수 있는 환경을 제공합니다. 이 프로젝트는 진성근 교수님의 실험실에서 나온 발췌입니다. 이 저장소에는 reader.sh를 비롯한 쉘로만 동작하는 초기 프로토타입 스크립트 몇 개를 제외하면 (reader.sh, car\\ controllser.sh, writer.sh, pod\\ car\\ run.sh와 같은 것) 쉘 스크립트, yaml, go, c 모두 본인이 작성한 코드만 있으며, 타… \n# kubernetes와 tcp를 이용한 저지연 실시간 자동차 제어\n\n# 1. 소개\n\n[소스](https://github.com/gg582/remotecarfrommonet)\n\n이 시스템은 원격에서 자동차를 제어할 수 있는 환경을 제공합니다.\n이 프로젝트는 진성근 교수님의 실험실에서 나온 발췌입니다.\n\n이 저장소에는 reader.sh를 비롯한 쉘로만 동작하는 초기 프로토타입 스크립트 몇 개를 제외하면 (reader.sh, car\\_controllser.sh, writer.sh, pod\\_car\\_run.sh와 같은 것) 쉘 스크립트, yaml, go, c 모두 본인이 작성한 코드만 있으며, 타인의 코드는 포함되어 있지 않습니다.\n전체 초기 파일은 깃허브에서 직접 작성자를 확인해야 하나 일부를 정리하자면\n- reader.sh\n- car\\_controller.sh\n- pod\\_mk\\_tun.sh\n- pod\\_car\\_run.sh\n- writer.sh\n\n프로젝트의 다른 일부에서 기여했던 구성원들이 있으나, 대부분의 자료는 유실된 상태입니다.\n\n프론트엔드 및 상위 관리 구조는 김경빈, abduolimov alisherbek(@alisherfw) 가 맡았습니다.\n\n구조 설계는 주로 김경빈이 담당했으며, 세부 아이디어는 저를 비롯하여, abduolimov alisherbek, akhmad kholmurodov가 기여했습니다.\n(예: 디바이스 드라이버 구조, tcp 흐름도, 통합 관리 아이디어 등)\n\n**기본적으로 모든 소스는 본인이 직접 구현했으며, 아이디어는 실험실 구성원 전체의 것입니다.**\n\n---\n\n### 역할 정리:\n\n- **메인 구조**: 김경빈, 진성근\n- **tcp 흐름도**: 이윤진, 김경빈, 진성근\n- **kubernetes 배포 구조**: 진성근\n- **세부 k8s 구조**: 이윤진\n- **디바이스 드라이버 구조 세부 구현**: 이윤진\n- **내부 소프트웨어 구현**: 이윤진, 진성근, 김경빈\n- **프론트엔드 구현**: 김경빈, abduolimov alisherbek, akhmad kholmurodov\n- **소프트웨어 통합**: 이윤진, akhmad kholmurodov, abduolimov alisherbek\n\n---\n\n## 기본 네트워크 구조\n\n- 물리 자동차가 장치 상태를 송신\n- 가상 자동차가 해당 정보를 받아 시뮬레이션 실행\n- 시뮬레이션 결과를 물리 자동차에 전달\n- 물리 자동차는 해당 결과를 실행\n\n---\n\n## 디바이스 드라이버 구현\n\n- 모터 드라이버: ioctl을 통한 i2c 드라이버 사용\n- 터널 디바이스 드라이버: 이중 연결 리스트 기반\n- 기타 장치: 일반적인 gpio 문자 디바이스\n\n---\n\n# 프로젝트 트리 구조\n\n```\n.\n├── driver-real-car\n│   └── driver\n├── config\n│   └── k8s-deploy\n├── exec\n│   ├── cluster_pod_man\n│   └── k8s_car_man\n├── pod\n│   ├── driver\n│   └── tunnel\n└── car\n    ├── common\n    ├── controller\n    ├── driver\n    ├── real-car\n    ├── runner\n    ├── sonic\n    ├── tunnel\n    ├── virt-carcon\n    └── virt-cartun\n```\n\n---\n\n## 디렉토리 설명\n\n### config\nkubernetes pod 배포 설정 파일\n\n### car\n자동차의 디바이스 드라이버 및 제어 프로그램\n\n- **common**: 공통 헤더 파일\n- **controller**: 긴급 수동 제어용 go 언어 및 쉘 스크립트\n- **driver**: 실제 하드웨어 디바이스용 리눅스 디바이스 드라이버\n- **real-car**: 정보 중계용 go 및 쉘 스크립트\n- **runner**: 간단한 회피 알고리즘을 갖춘 가상 자동차 애플리케이션\n- **sonic**: 초음파 테스트용 드라이버\n- **virt-carcon**: 가상 자동차 컨테이너에서 실행되는 제어 스크립트\n- **virt-cartun**: 가상 터널 트리거 스크립트\n- **tunnel**: 터널링 디바이스 드라이버\n\n### driver-real-car\n물리 자동차 디바이스 드라이버 초기 설계 및 터널링 정보 송수신용 스크립트\n\n### exec\n자동차 제어용 쉘 스크립트. 대부분 초기 프로토타입임.\n### car/controller\nshelljs로 호출되던 실제 실행 타겟들이 위치함.\n\n### pod\n이 프로젝트의 초기 및 추상적 구조 설계\n\n## 실험 당시의 구조\n- 실험 당시의 구조는, 드래그 앤 드롭으로 주행 방향 계산 어플리케이션의 실행 위지를 엣지 서버, 혹은 클러스터에 등록된 물리 자동차 기기로 지연 없이 옮기는 것이었습니다.\n\n- 자동차 혹은 엣지 서버를 실행하기 위한 칸으로 드래그 앤 드롭을 하면, car/controller에 위치한 적절한 타겟 스크립트를 shelljs에서 호출, html 웹에서 가상, 물리 자동차의 로그 파일을 읽어서 보여 주는 형태의 웹서버였습니다.\n\n- 실험 당시, edge server를 초기에는 amd64 컴퓨터로 하였으나 네이티브 아키텍처를 서로 일치시켜 불필요한 endianness 변환을 피하기 위해 라즈베리 파이 클러스터를 사용하였고, 실험 말기에는 m! 맥북에 asahilinux kernel + pearl bootloader + pearl 부트로더 repo에 같이 첨부된 debian 이미지로 진행하였습니다.\n\n- tunnel buffer의 최적화가 충분하지 않아 sawtooth pattern이 일부 관찰되었으며, 후속 과제가 확실하게 저지연 통신을 보장하는 것이었습니다.\n\n- 후속 과제로 제대로 이어지지 못한 채 실험이 종료되어 지금 올리는 프로토타입 정도가 남았고, 당시 적절한 요소 제거가 정의되지 않은 배열 기반의 고정 크기 버퍼를 사용하였으나 그 코드는 유실되어 현재는 linked list 기반으로 요소 삽입 공간이 부족할 때 fifo로 요소를 버리는 구현으로 대체하였으나 메트릭 측정은 아직 하지 못했습니다(충분한 엣지 서버 역시 존재하지 않는 것이 문제입니다).\n\n"
    },
    {
      "title": "STM32f769i-DISCOVERY에 대한 인상",
      "subtitle": "기판을 선물받은 후 어떠한 작업을 했어야 했는가",
      "description": null,
      "url": "/embedded/2026-01-19-STM32f769i-DISCOVERY에-대한-인상/",
      "collection": "embedded",
      "relative_path": "2026-01-19-STM32f769i-DISCOVERY에-대한-인상",
      "date": "2025-05-09T15:35:00+09:00",
      "updated": null,
      "keywords": [
        "바이너리 최적화",
        "BusyBox",
        "임베디드 입문"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-hardware",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "--- 왜 임베디드는 어렵다고 하는가? 입문부터 맵다. 오픈소스 조직 Go수다에서 닉네임 \"백엔드는Go밖에못함\"인 익명의 개발자님으로부터 STM32f769i-DISCOVERY를 무료로 선물받았다. STM32f429i-DISCOVERY에 리눅스 포팅에 실패하고 ZephyrOS를 간신히 올린 시점에서, 더 쓸만한 학습용 기판을 택배비까지 받지 않고 기증해 주셨다. 발을 다친 채 집에서 요양하면서 이 기판을 공부해 봤는데, 임베디드 기판 치고는 2MB의 RAM과 16MB의 플래시 메모리를 가졌으며, 외…",
      "search_text": "stm32f769i-discovery에 대한 인상 기판을 선물받은 후 어떠한 작업을 했어야 했는가 바이너리 최적화 busybox 임베디드 입문 embedded embedded embedded-hardware --- 왜 임베디드는 어렵다고 하는가? 입문부터 맵다. 오픈소스 조직 go수다에서 닉네임 \"백엔드는go밖에못함\"인 익명의 개발자님으로부터 stm32f769i-discovery를 무료로 선물받았다. stm32f429i-discovery에 리눅스 포팅에 실패하고 zephyros를 간신히 올린 시점에서, 더 쓸만한 학습용 기판을 택배비까지 받지 않고 기증해 주셨다. 발을 다친 채 집에서 요양하면서 이 기판을 공부해 봤는데, 임베디드 기판 치고는 2mb의 ram과 16mb의 플래시 메모리를 가졌으며, 외… \n\n---\n\n## 왜 임베디드는 어렵다고 하는가? 입문부터 맵다.\n\n오픈소스 조직 go수다에서 닉네임 \"백엔드는go밖에못함\"인 익명의 개발자님으로부터 stm32f769i-discovery를 무료로 선물받았다.\nstm32f429i-discovery에 리눅스 포팅에 실패하고 zephyros를 간신히 올린 시점에서, 더 쓸만한 학습용 기판을 택배비까지 받지 않고 기증해 주셨다.\n발을 다친 채 집에서 요양하면서 이 기판을 공부해 봤는데, 임베디드 기판 치고는 2mb의 ram과 16mb의 플래시 메모리를 가졌으며, 외장 sd카드도 탑재해 있다.\n\n우선은 이 기판에 리눅스부터 올려볼 생각이었고, 실제로 그렇게 하였다. 아래는 기판을 가지고 작업하면서 겪은 문제들이다.\n\n\n## buildroot 설정에서 busybox를 경량화해야 한다\n\n보통 busybox에는 다양한 리눅스 명령어들이 들어가 있다. 보통은 바이너리 크기도 크다.\n그러나 이 기판의 ram은 2mb이다. 우선 욕심내지 말고 이것저것 들어내야 한다.\n\n- chown, chmod 등 관리 편의성을 위한 도구를 모두 지워야 했다\n- 이런 것도 지워야 하는 명령도 지웠다\n- 그럼에도 불구하고 메모리 단편화가 일어나면 말썽을 일으켰다\n\n여러모로 라즈베리 파이같은 차고 넘치는 기판만 쓰다가 이것을 사용하니 현장감이 올라가며 식은땀이 줄줄 났다.\n\n여기서 생각해야 할 것은 경량화이다.\n\n## 바이너리 크기를 최적화해야 한다.\n\nc언어 바이너리를 컴파일할 때에 가장 일반적인 옵션은 `-o2`이다. 그러나 이러한 환경에서는 성능이 문제가 아니고 바이너리가 ram에 안 올라갈 가능성이 있다.\n`-os`로 옵션을 바꿔 크기를 줄이는 것을 우선으로 빌드한다.\n\n또한 리눅스 커널 자체에 포함되는 기능을 줄여 이미지 크기를 줄여야 한다.\n\n사용하지 않을 스택은 제거해라.\n\n- 제네릭 이미지를 위한 없는 하드웨어를 위한 드라이버 제거\n- 사용하지 않을 스택 전체를 제거\n- 용량이 큰 신규 기능은 웬만하면 제거 \n\n\n## sdram에 이미지 인젝션? 성능 아끼려다 키지도 못하는 수가 있다\n\n리눅스는 서버나 고성능 임베디드 기판에 넣을 때는 넉넉하지만, 일반적인 임베디드 기판에게는 매우 무거우며, 그것이 rtos가 훨씬 인기가 좋은 까닭이다.\n기본적으로 리눅스 커널을 아무리 경량화해도 kb 단위로 떨어뜨리는 것은 매우 도전적인 과제이며, 설령 그렇게 해도 sdram에 이미지를 인젝션해서 빠른 부팅을 노릴 틈이 없다.\n얌전하게 u-boot의 성능을 믿고 부팅해 줘야 한다. 또한 이렇게 램 인젝션을 한다고 해도 이런 환경에서 램을 직접 접근 후 부팅하는 명령을 저장할 수 없는 때가 많다.\nu-boot에서 `saveenv`가 듣지 않는 것을 보고 탄식하면 늦다.\n\n## 그럼 어떻게 하면 되나요?\n\n\n대안은 여러가지이지만 두 가지만 소개한다.\n\n### 리눅스를 뼈만 사용하자\n\n사용하고 싶은 기능만 내버려 두고 모두 떼어 버린다. 완성된 uimage 등이 자신의 ram의 절반 이하로 용량이 떨어지면 된다. 통상적으로 프로덕션 시 1mb대로 떨어뜨려 빌드하는 경우가 많다고 들었다.\n가능하면 바이너리 크기는 줄여 주는 것이 유리하다.\n\n### rtos를 사용하자\n\n이것은 내가 stm32f429i-discovery를 사용할 때 써 먹었다. zephyros, freertos 등은 정말로 이미지가 kb 단위이다. 램이 거의 온전히 남아 도는 것을 본다면 당신의 프로젝트 아이디어는 마구 샘솟을 것이다.\n만약 아두이노 수준에서 한두발만 더 나아갔더라도 포트폴리오를 위한 과시가 아니고 실제 장난감을 만들 것이라면 이렇게 하자.\n\n\n\n## 결론\n\n임베디드 업계가 맵다고 하는 것이 빈말이 아니다. 이것이 다른 업계로 따지면 \"스프링으로 hello world 찍기\"나, \"go언어로 쿠버네티스 활성 노드 가져오기\"에 해당하는 단계이다.\n이 진입장벽을 넘지 못한다면 임베디드를 공부하는 데에 아주 애로사항이 생긴다. 갑자기 가이드에서 튀어나오는 hex값, 지옥의 주소 디버깅을 모두 넘어서 자기 장난감을 자기가 만든다면 이제 포트폴리오 **1개**가 완성되는 것이다.\n아주 공부하기 무서운 방향성이지만 취미로 시간을 길게 가진다면 못 할 것도 없다. 가끔 시간이 나면 다루도록 하겠다.\n\n"
    },
    {
      "title": "라즈베리파이 라즈봇",
      "subtitle": "라즈베리파이 실습에 대한 개요",
      "description": null,
      "url": "/embedded/2025-05-09-라즈베리파이-라즈봇/",
      "collection": "embedded",
      "relative_path": "2025-05-09-라즈베리파이-라즈봇",
      "date": "2025-05-09T15:35:00+09:00",
      "updated": null,
      "keywords": [
        "하드웨어 제어",
        "리눅스 디바이스 드라이버",
        "IoT 제어",
        "임베디드 입문"
      ],
      "categories": [
        "embedded"
      ],
      "taxonomy": {
        "category": "embedded",
        "subcategory": "embedded-projects",
        "order": 2
      },
      "difficulty": "intermediate",
      "excerpt": "--- 야붐 AI 비전 로봇 자동차를 위한 지능형 모터 제어 시스템 구축 개요 본 프로젝트에서는 야붐 라즈봇 AI 비전 로봇 자동차를 위한 지능형 모터 제어 시스템을 구현했습니다. 이 시스템은 핀 인터럽트, IOCTL\\-\\ I2C 명령어 변환, GPIO 등을 활용하여 센서 데이터와 미리 정의된 로직에 따라 로봇의 움직임을 정밀하게 제어합니다. 주요 기능 정밀한 장애물 감지 : 초음파와 적외선 센서를 통해 주변 장애물을 정확하게 감지합니다. 충돌을 방지하기 위한 안전 알고리즘을 내장하고 있습니다.…",
      "search_text": "라즈베리파이 라즈봇 라즈베리파이 실습에 대한 개요 하드웨어 제어 리눅스 디바이스 드라이버 iot 제어 임베디드 입문 embedded embedded embedded-projects --- 야붐 ai 비전 로봇 자동차를 위한 지능형 모터 제어 시스템 구축 개요 본 프로젝트에서는 야붐 라즈봇 ai 비전 로봇 자동차를 위한 지능형 모터 제어 시스템을 구현했습니다. 이 시스템은 핀 인터럽트, ioctl\\-\\ i2c 명령어 변환, gpio 등을 활용하여 센서 데이터와 미리 정의된 로직에 따라 로봇의 움직임을 정밀하게 제어합니다. 주요 기능 정밀한 장애물 감지 : 초음파와 적외선 센서를 통해 주변 장애물을 정확하게 감지합니다. 충돌을 방지하기 위한 안전 알고리즘을 내장하고 있습니다.… \n\n---\n\n# 야붐 ai 비전 로봇 자동차를 위한 지능형 모터 제어 시스템 구축\n\n### 개요\n본 프로젝트에서는 야붐 라즈봇 ai 비전 로봇 자동차를 위한 지능형 모터 제어 시스템을 구현했습니다. 이 시스템은 핀 인터럽트, ioctl\\-\\>i2c 명령어 변환, gpio 등을 활용하여 센서 데이터와 미리 정의된 로직에 따라 로봇의 움직임을 정밀하게 제어합니다.\n\n### 주요 기능\n* **정밀한 장애물 감지**:\n    * 초음파와 적외선 센서를 통해 주변 장애물을 정확하게 감지합니다.\n    * 충돌을 방지하기 위한 안전 알고리즘을 내장하고 있습니다.\n* **지능적인 모터 제어 알고리즘**:\n    * 장애물과의 거리에 따라 모터 속도를 자동으로 조절합니다.\n    * 센서 입력에 기반하여 부드럽고 정확한 방향 제어를 수행합니다.\n\n### 설정 방법\n#### 필수 하드웨어\n* 야붐 라즈봇 ai 비전 로봇 자동차 (라즈베리 파이 4 버전)\n* 로봇 하드웨어 사양에 따라 정확하게 구성된 gpio 핀\n\n*현재 ai vision 기능을 사용하지 않고 c 구현만 포함되어 있어서, 카메라가 누락되어도 무방합니다.*\n\n#### 소프트웨어 요구 사항\n* 라즈베리 파이 os\n* c 프로그래밍 언어 (시스템 구현에 사용)\n* gpio 제어 및 센서 입력 처리를 위한 필수 라이브러리\n\n### 핵심 모터 제어 로직\n본 모터 제어 시스템은 다음과 같은 핵심 로직을 기반으로 작동합니다.\n\n1.  **실시간 거리 모니터링**:\n    * 센서로부터 지속적으로 거리 데이터를 읽어옵니다.\n    * 장애물과의 안전 거리를 유지하기 위해 모터 속도를 능동적으로 조절합니다.\n\n2.  **정확한 방향 제어**:\n    * 적외선 센서를 활용하여 로봇의 진행 경로에 있는 장애물을 감지합니다.\n    * 장애물이 감지되면 회피 기동을 위한 정교한 방향 전환 로직을 실행합니다.\n\n3.  **체계적인 오류 처리**:\n    * 예상치 못한 시스템 오류 발생 시 안전하게 작동을 멈추는 보호 메커니즘을 포함합니다.\n\n### 사용 방법 \n1.  github 저장소를 라즈베리 파이에 복제합니다. (https://github.com/gg582/raspberry_pi_raspbot)\n2.  필요한 종속성(dependencies)을 설치합니다.\n3.  적절한 명령행 인수를 사용하여 모터 제어 스크립트를 실행합니다.\n\n**실행 예시:**\n```bash\ncd motor_control_c\n./runner\n```\n### 알려진 문제점\n왼쪽 적외선 센서의 잦은 불량으로 인해 신뢰성이 낮습니다.\n\n### 결론\n본 프로젝트는 gpio 핀과 센서 데이터를 효과적으로 활용하여 로봇 시스템을 제어하는 강력한 솔루션을 제시합니다. 임베디드 시스템 개발에서 철저한 하드웨어 테스트와 적응형 제어 알고리즘의 중요성을 강조합니다.\n# 추가 정보\ngpio 핀 맵 확인: /sys/kernel/debug/gpio 경로를 통해 현재 핀 맵 설정을 확인할 수 있습니다.\n"
    },
    {
      "title": "gg582의 프로필",
      "subtitle": null,
      "description": null,
      "url": "/blog/2025/03/28/gg582.html",
      "collection": "posts",
      "relative_path": "_posts/2025-03-28-gg582의 프로필.md",
      "date": "2025-03-28T13:05:54+09:00",
      "updated": null,
      "keywords": [],
      "categories": [
        "blog"
      ],
      "taxonomy": {},
      "difficulty": null,
      "excerpt": "안녕하세요! 이윤진(@gg582)입니다. Solved.ac 프로필 저에 대해 저는 유닉스/리눅스 시스템 관리, 자동화 스크립트, Docker & Incus, Go 언어 패키지 개발(Tcl/Tk 9.0)에 관심 있는 대학생입니다. 현재 Java와 C 을 배우고 있습니다. 관심 분야 유닉스/리눅스 시스템 관리 자동화 스크립트 Docker & Incus Go 언어 (Tcl/Tk 9.0) Java (학습 중) C (학습 중) 개인적인 이야기 저는 여가 시간에 LP 듣는 것을 좋아합니다. 연락처 이메일:…",
      "search_text": "gg582의 프로필 blog 안녕하세요! 이윤진(@gg582)입니다. solved.ac 프로필 저에 대해 저는 유닉스/리눅스 시스템 관리, 자동화 스크립트, docker & incus, go 언어 패키지 개발(tcl/tk 9.0)에 관심 있는 대학생입니다. 현재 java와 c 을 배우고 있습니다. 관심 분야 유닉스/리눅스 시스템 관리 자동화 스크립트 docker & incus go 언어 (tcl/tk 9.0) java (학습 중) c (학습 중) 개인적인 이야기 저는 여가 시간에 lp 듣는 것을 좋아합니다. 연락처 이메일:… \n\n# 안녕하세요! 이윤진(@gg582)입니다.\n\n[solved.ac 프로필](https://solved.ac/yoonjin67)\n\n## 저에 대해\n\n저는 유닉스/리눅스 시스템 관리, 자동화 스크립트, docker & incus, go 언어 패키지 개발(tcl/tk 9.0)에 관심 있는 대학생입니다. 현재 java와 c#을 배우고 있습니다.\n\n### 관심 분야\n\n  * 유닉스/리눅스 시스템 관리\n  * 자동화 스크립트\n  * docker & incus\n  * go 언어 (tcl/tk 9.0)\n  * java (학습 중)\n  * c# (학습 중)\n\n### 개인적인 이야기\n\n저는 여가 시간에 lp 듣는 것을 좋아합니다.\n\n### 연락처\n\n  * 이메일: [gg582@naver.com](mailto:gg582@naver.com) 또는 [gzblues61@gmail.com](mailto:gzblues61@gmail.com)\n\n## 주요 프로젝트\n\n### incuspeed  incus 컨테이너 관리 도구\n\n이 도구는 원격으로 직관적인 ui의 모바일 앱으로 컨테이너 생성 및 관리 요청을 보내어 애플리케이션 빌드 환경 등을 쉽게 생성할 수 있는 도구입니다. restapi, 동시성 제어, nosql(mongodb), incus, 쉘 스크립팅 등을 잘 조합하여 쉽고 직관적인 코드 설계를 목표로 하였고, 사용자 등록과 컨테이너 초기 설정을 위한 통신은 ssl/tls로 암호화된 https 상에서 키 재활용없는 일회성 aes 암호로 이루어집니다. 각각의 컨테이너는 랜덤 스트링 태그를 통해 구분되어 관리되며, 난수성이 높은 태그는 컨테이너 태그의 무차별 대입 공격을 효과적으로 방어합니다.\n\n### ssh-chatter: 현대판 pc통신\n\nssh-chatter는 현대적이고 깔끔한 tui와 utf-8 공식 지원이 있는 현대판 pc통신입니다.\nssh/telnet이 지원되며 cp437 레트로 인코딩과 utf-8을 모두 지원합니다.\n내장 번역기를 이용해 원하는 언어로 자신의 메시지를 ai 번역할 수 있으며, c언어를 적절히 활용해 성능과 가독성 사이의 두 마리 토끼를 잡았습니다.\n코드의 기본적인 아이디어는 영미권 bbs와 국내 pc 통신 양쪽에서 받았으며 실시간 채팅과 게시물 작성, 상호작용 등이 가능합니다.\n\n### remotecarfrommonet\n\n연구실 인원 전체가 2021-2022년 간 진행한 간략한 실시간 엣지 컴퓨팅에 대한 프로토타입입니다. 실시간 통신 노드 간의 관리를 쉽게 하기 위해 쿠버네티스 배포 전략을 간단하게 활용하였으며, 연구 당시의 구현체는 tcp로 구현되었습니다. 또한, iot와의 접목 연구였던 까닭에 디바이스 드라이버의 구현 역시 포함되어있습니다. 자세한 연구 내용은 별도 포스트를 참고하시길 바랍니다.\n\n### raspberry pi raspbot - rpi4 revision의 yahboom 4wd bot 제어\n\nremotecarfrommonet에서 활용한 사물 인터넷 기기와 동일한 라즈봇의 디바이스 제어 코드의 정돈되지 않은 부분을 보다 면밀하게 확인 후 재작성하여 별도의 사물 인터넷 기기 제어 프로젝트로 분기하였습니다. 초음파 디바이스는 busy-waiting 구현이 아닌 핀 전압값 변화를 통한 인터럽트로 변경되었으며, ir 장치의 값 확인은 왼쪽과 오른쪽을 동시에 고려하여 left, right, both로 직관적인 스트링 형태로 변경하였습니다. 또한 모터 드라이버에 pi\\_cmd\\_io라는, 바퀴의 속도를 사용자 지정으로 섬세하게 제어 가능한 호출을 추가하여 제어 프로젝트로의 성숙도를 높였습니다.\n\n### deltaedit - 비 유니코드 cjk 텍스트 편집기\n\ndeltaedit은 유닉스 계열 운영 체제에서 cjk(중국어, 일본어, 한국어) 언어를 위해 특별히 설계된 경량 비 유니코드 텍스트 편집기입니다. 문제 해결 플랫폼 통합을 위한 내부 브라우저 탭, 스마트 자동 들여쓰기 기능, 구문 강조 지원 및 단일 파일의 올인원 구현을 제공합니다.\n\n### espresso archiver: rle 변형 난독화 프로그램\n\nespresso zip은 파일을 비트 수와 나열 순서로 나누는 아이디어에서 출발한 rle(run-length encoding) 변형 난독화 프로그램입니다. 간단하지만 효과적인 난독화, 가볍고 빠른 처리 속도, 쉬운 이해도를 제공합니다.\n\n### baekjoon 문제 풀이 저장소\n\n이 저장소는 백준 온라인 저지에서 해결한 문제들을 자동으로 푸시하는 저장소입니다. 다양한 프로그래밍 언어로 작성된 문제 풀이 코드를 확인할 수 있습니다.\n\n## 기여 및 연락\n\n저의 프로젝트에 기여하고 싶다면 언제든지 환영합니다! 저장소를 포크하고 새로운 브랜치를 만들어 기능을 추가하거나 버그를 수정하고, 풀 리퀘스트를 보내주세요. 질문, 제안 또는 피드백이 있다면 언제든지 저에게 연락해주세요.\n"
    },
    {
      "title": "[비트마스킹] 비밀 지도-프로그래머스-레벨1",
      "subtitle": "비트마스킹의 기초를 연습해 보자",
      "description": null,
      "url": "/codingtest/2026-01-20-[비트마스킹]-비밀-지도-프로그래머스-레벨1/",
      "collection": "codingtest",
      "relative_path": "2026-01-20-[비트마스킹]-비밀-지도-프로그래머스-레벨1",
      "date": "2025-01-20T14:52:00+09:00",
      "updated": null,
      "keywords": [
        "프로그래머스",
        "알고리즘",
        "비트마스크"
      ],
      "categories": [
        "codingtest"
      ],
      "taxonomy": {
        "category": "codingtest",
        "subcategory": "algorithm-bitmask",
        "order": 2
      },
      "difficulty": "beginner",
      "excerpt": "[1차] 비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \"공백\"(\" \") 또는 \"벽\"(\" \") 두 종류로 이루어져 있다. 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \"지도 1\"과 \"지도 2\"라고 하자. 지…",
      "search_text": "[비트마스킹] 비밀 지도-프로그래머스-레벨1 비트마스킹의 기초를 연습해 보자 프로그래머스 알고리즘 비트마스크 codingtest codingtest algorithm-bitmask [1차] 비밀지도 문제 설명 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다. 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \"공백\"(\" \") 또는 \"벽\"(\" \") 두 종류로 이루어져 있다. 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \"지도 1\"과 \"지도 2\"라고 하자. 지… \n\n## [1차] 비밀지도\n\n### 문제 설명\n\n네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.\n\n1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 \"공백\"(\" \") 또는 \"벽\"(\"#\") 두 종류로 이루어져 있다.\n2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 \"지도 1\"과 \"지도 2\"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.\n3. \"지도 1\"과 \"지도 2\"는 각각 정수 배열로 암호화되어 있다.\n4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\n\n네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.\n\n### 입출력 예제 시각화\n\n<table border=\"1\">\n<tr>\n<th colspan=\"2\">지도 1</th>\n<th></th>\n<th colspan=\"2\">지도 2</th>\n<th></th>\n<th>비밀지도</th>\n</tr>\n<tr>\n<td><code>01001<sub>(2)</sub></code></td>\n<td>9</td>\n<td rowspan=\"5\">or\n\n\n\n( | )</td>\n<td><code>11110<sub>(2)</sub></code></td>\n<td>30</td>\n<td rowspan=\"5\">=</td>\n<td><code>#####</code></td>\n</tr>\n<tr>\n<td><code>10100<sub>(2)</sub></code></td>\n<td>20</td>\n<td><code>00001<sub>(2)</sub></code></td>\n<td>1</td>\n<td><code># # #</code></td>\n</tr>\n<tr>\n<td><code>11100<sub>(2)</sub></code></td>\n<td>28</td>\n<td><code>10101<sub>(2)</sub></code></td>\n<td>21</td>\n<td><code>### #</code></td>\n</tr>\n<tr>\n<td><code>10010<sub>(2)</sub></code></td>\n<td>18</td>\n<td><code>10001<sub>(2)</sub></code></td>\n<td>17</td>\n<td><code>#  ##</code></td>\n</tr>\n<tr>\n<td><code>01011<sub>(2)</sub></code></td>\n<td>11</td>\n<td><code>11100<sub>(2)</sub></code></td>\n<td>28</td>\n<td><code>#####</code></td>\n</tr>\n</table>\n\n### 입력 형식\n\n입력으로 지도의 한 변 크기 `n` 과 2개의 정수 배열 `arr1`, `arr2`가 들어온다.\n\n* 1 ≦ n ≦ 16\n* `arr1`, `arr2`는 길이 n인 정수 배열로 주어진다.\n* 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2<sup>n</sup> - 1을 만족한다.\n\n### 출력 형식\n\n원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.\n\n### 입출력 예제\n\n| n | arr1 | arr2 | 출력 |\n| --- | --- | --- | --- |\n| 5 | [9, 20, 28, 18, 11] | [30, 1, 21, 17, 28] | `[\"#####\",\"# # #\", \"### #\", \"#  ##\", \"#####\"]` |\n| 6 | [46, 33, 33, 22, 31, 50] | [27, 56, 19, 14, 14, 10] | `[\"######\", \"###  #\", \"##  ##\", \" #### \", \" #####\", \"### # \"]` |\n\n## 해설\n\n전형적인 비트마스킹 문제이다.\n많은 경우 서버의 채점 환경은 'little endian'이기 때문에 n - 1번째 비트부터 체크하면서 내려와야 한다.\n만약 그렇게 냈는데 안 됐다면 서버가 'big endian'인 특이 케이스일 수 있으니 0번째 비트부터 체크하면 된다.\n\n격자가 있든 말든 본질은 탐색도 그래프도 아닌 비트마스킹 문제이다.\n그냥 냅다 두 벡터를 or한 새로운 벡터를 만들고, 그냥 for문 돌려서 비트마스킹으로 추출한다.\n\n## 비트 추출 원리\n```c\n(bool)((x >> i) & 1)\n```\n\n이것의 뜻은 x를 i만큼 오른쪽으로 밀고, 그것과 1을 and연산한 후 1비트만큼 잘라내어 불리언으로 쓰겠다는 뜻이다.\n반드시 and 연산하는 둘의 타입이 같아야 일어날지도 모르는 사고를 막을 수 있다.\n\n1. 원하는 비트가 x의 첫 1비트에 올 만큼 밀어준다.\n2. 1과 and 연산을 한다.\n3. (bool)을 씌워 1비트만 잘라낸다.\n\n그렇게 했을 때를 `uint8_t x = 128`일 때 x의 오른쪽에서 8번째 비트를 가져오는 경우로 한번 생각해 보자.\n8비트 부호 없는 정수 128은 이렇게 표현 가능하다.\n\n```\n10000000\n       ^\n       여기가 x의 첫 비트\n```\n\n이 상황에서 비트를 밀어보자.\n```\n10000000\n       ^ x >> 0, (bool)((x >> 0) & 1) == false \n10000000\n      ^  x >> 1, (bool)((x >> 1) & 1) == false  \n10000000\n     ^   x >> 2, (bool)((x >> 2) & 1) == false \n10000000\n    ^    x >> 3, (bool)((x >> 3) & 1) == false \n10000000\n   ^     x >> 4, (bool)((x >> 4) & 1) == false \n10000000\n  ^      x >> 5, (bool)((x >> 5) & 1) == false \n10000000\n ^       x >> 6, (bool)((x >> 6) & 1) == false \n10000000\n^        x >> 7, (bool)((x >> 7) & 1) == true\n```\n\n와 같이 비트가 잘 추출된다.\n이 문제는 주어진 n비트만큼 추출하되 오른쪽부터 왼쪽으로 기계어 어순으로 읽은 후 왼쪽부터 오른쪽으로 사람 어순으로 `'#'=1, ' '=0`으로 가공해서 던져주는 것이다.\n\n## 풀이\n```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring parse_n_bits(int x, int n) {\n    string s;\n    for(int i = n - 1; i >= 0; i--) {\n        if((bool)((x >> i) & 1)) {\n            s += \"#\";\n        } else {\n            s += \" \";\n        }\n    }\n    return s;\n}\n\n\nvector<string> solution(int n, vector<int> arr1, vector<int> arr2) {\n    vector<string> answer;\n    vector<int>    with_or_gate(arr1);\n    for(int i = 0; i < with_or_gate.size(); i++) with_or_gate[i] |= arr2[i];\n\n    for(int i = 0; i < with_or_gate.size(); i++) {\n        answer.push_back(parse_n_bits(with_or_gate[i], n));\n    }\n    return answer;\n}\n```\n\n\n## 참고 사항\n\n매우 난이도가 낮기 때문에 방심할 수 있으나, 언제 비트를 잘라내고 언제 or 연산하는지 유심히 볼 필요가 있다.\n당당하게 날림으로 풀었다가 큰일이 날 수도 있으니 주의하고 또 주의하자.\n"
    }
  ]
}
