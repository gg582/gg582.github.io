---
layout: knowledge-base
title: "[다익스트라][필터링] 대륙별 최적 목적지 찾기 - 규제 경로 필터링"
subtitle: "우회 경로에서도 규제된 국가 간 이동 필터링하기"
date: 2026-02-08 11:53 +0900
categories: [codingtest]
taxonomy:
  category: codingtest
  subcategory: algorithm-dijkstra
  order: 1
difficulty: intermediate
keywords:
  - 다익스트라
  - 그래프
  - 필터링
  - 경로 탐색
  - 규제
relationships:
  related: []
  references: []
  prerequisite: []
  extends: []
  comparison: []
---

# [다익스트라][필터링] 대륙별 최적 목적지 찾기 - 규제 경로 필터링

## Problem Statement

당신은 항공 경로 추천 시스템을 개발하고 있습니다. 특정 대륙 내에서 최적의 목적지를 찾아야 하지만, 일부 국가 간에는 정치적/법적 이유로 **직접 이동뿐만 아니라 경유(우회)도 금지**되어 있습니다.

예를 들어, 북한과 한국 사이의 이동은 직항뿐만 아니라 중간에 다른 나라를 경유하는 경로도 사용할 수 없습니다.

주어진 조건:
- `n`개의 국가가 있으며, 각 국가는 `0`부터 `n-1`까지 번호가 매겨져 있습니다
- `flights` 배열은 `[from, to, cost]` 형태로 항공편 정보를 담고 있습니다 (양방향)
- `restricted` 배열은 `[country1, country2]` 형태로 규제된 국가 쌍을 나타냅니다
- `start` 국가에서 출발하여 최소 비용으로 갈 수 있는 목적지를 찾아야 합니다
- **규제된 국가 쌍이 경로에 연속적으로 나타나면 안 됩니다** (직접 이동 및 우회 모두 금지)

**목표**: `start`에서 출발하여 각 목적지까지 최소 비용으로 갈 수 있는 경로를 찾되, 규제된 국가 간 이동이 포함되지 않은 경로만 고려합니다.

---

## Examples

### Example 1

**Input:**
```
n = 5
flights = [[0,1,100], [0,2,200], [1,2,50], [1,3,300], [2,3,100], [2,4,150], [3,4,50]]
restricted = [[1,3]]
start = 0
```

**Output:**
```
[0, 100, 150, INF, 300]
```

**Explanation:**
- 국가 0: 0 (시작점)
- 국가 1: 100 (0 → 1)
- 국가 2: 150 (0 → 1 → 2)
- 국가 3: INF (모든 경로가 규제됨. 0→1→3은 1-3이 규제, 0→2→3은 비용이 더 큼)
- 국가 4: 300 (0 → 1 → 2 → 4)

국가 1과 3 사이는 규제되어 있으므로 직접 이동(1→3)뿐만 아니라 어떤 경로에서도 1에서 3으로 또는 3에서 1로의 이동이 포함되면 해당 경로를 사용할 수 없습니다.

### Example 2

**Input:**
```
n = 4
flights = [[0,1,100], [1,2,100], [2,3,100], [0,3,500]]
restricted = [[0,1]]
start = 0
```

**Output:**
```
[0, INF, INF, 500]
```

**Explanation:**
- 국가 0: 0 (시작점)
- 국가 1: INF (0→1이 규제됨)
- 국가 2: INF (0→1→2 경로에 규제 구간 포함)
- 국가 3: 500 (0→3 직항만 가능)

---

## Constraints

- `2 <= n <= 100`
- `1 <= flights.length <= n * (n - 1) / 2`
- `flights[i].length == 3`
- `0 <= fromi < toi < n`
- `1 <= cost <= 10000`
- `0 <= restricted.length <= n * (n - 1) / 2`
- `restricted[i].length == 2`
- `0 <= start < n`

---

## 문제 해석

이 문제는 기본적으로 **다익스트라 알고리즘**을 사용하되, 특정 조건(규제 경로)을 필터링해야 하는 변형 문제입니다.

### 핵심 포인트

1. **일반 다익스트라와의 차이점**: 단순히 최단 경로를 찾는 것이 아니라, **규제된 국가 쌍을 연속으로 거치는 경로를 제외**해야 합니다.

2. **우회 경로도 차단**: 문제의 핵심은 직항뿐만 아니라 "우회 경로"도 규제해야 한다는 점입니다. 예를 들어, 북한(1)과 한국(3)이 규제되어 있다면:
   - 직접 이동: 1 → 3 (금지)
   - 우회: 어떤 경로에서도 연속적으로 1 → 3 또는 3 → 1이 나타나면 안 됨

3. **구현 전략**:
   - 다익스트라를 실행할 때 **현재 노드와 다음 노드의 쌍이 규제 목록에 있는지 확인**
   - 규제된 쌍이면 해당 간선(edge)을 사용하지 않음
   - 양방향을 모두 체크해야 함 (1→3과 3→1 모두 규제)

### 알고리즘 설계

```
1. 규제 쌍을 빠르게 조회할 수 있도록 Set 또는 Map에 저장
   - (a, b)와 (b, a) 모두 저장하여 양방향 체크

2. 다익스트라 초기화:
   - dist 배열을 INF로 초기화
   - dist[start] = 0
   - 우선순위 큐에 (0, start) 삽입

3. 다익스트라 실행:
   while (우선순위 큐가 비지 않음):
     current = 큐에서 최소 비용 노드 추출
     
     if (현재 거리 > dist[current]):
       continue  # 이미 더 좋은 경로 발견됨
     
     for (next in current의 인접 노드):
       # 핵심: 규제 체크
       if ((current, next)가 규제됨):
         continue  # 이 간선 사용 불가
       
       new_dist = dist[current] + cost[current][next]
       if (new_dist < dist[next]):
         dist[next] = new_dist
         큐에 (new_dist, next) 삽입

4. dist 배열 반환
```

### 주의사항

- **양방향 체크**: `flights`가 양방향이라면, 규제도 양방향으로 저장해야 합니다
- **자료구조 선택**: 규제 쌍 조회를 O(1)에 할 수 있도록 해시 자료구조 사용
- **INF 처리**: 도달 불가능한 노드는 `INT_MAX / 2` 또는 충분히 큰 값으로 표시

---

## 풀이

다익스트라를 기반으로 규제 경로 필터링 로직을 추가한 C++ 구현입니다.

```cpp
#include <vector>
#include <queue>
#include <unordered_set>
#include <climits>
using namespace std;

typedef pair<int, int> pii;  // {cost, node}

class Solution {
public:
    vector<int> findOptimalDestinations(int n, vector<vector<int>>& flights, 
                                         vector<vector<int>>& restricted, int start) {
        // 규제된 경로를 빠르게 조회하기 위한 set
        unordered_set<long long> restrictedSet;
        for (auto& r : restricted) {
            // 양방향 모두 저장 (해시 충돌 방지를 위해 곱셈 사용)
            restrictedSet.insert((long long)r[0] * 1000 + r[1]);
            restrictedSet.insert((long long)r[1] * 1000 + r[0]);
        }
        
        // 인접 리스트 구성
        vector<vector<pii>> adj(n);
        for (auto& f : flights) {
            adj[f[0]].push_back({f[2], f[1]});  // {cost, destination}
            adj[f[1]].push_back({f[2], f[0]});  // 양방향
        }
        
        // 다익스트라 초기화
        vector<int> dist(n, INT_MAX / 2);
        dist[start] = 0;
        
        priority_queue<pii, vector<pii>, greater<pii>> pq;  // min heap
        pq.push({0, start});
        
        // 다익스트라 실행
        while (!pq.empty()) {
            auto [currentCost, currentNode] = pq.top();
            pq.pop();
            
            // 이미 더 좋은 경로를 찾은 경우 스킵
            if (currentCost > dist[currentNode]) {
                continue;
            }
            
            // 인접 노드 탐색
            for (auto& [edgeCost, nextNode] : adj[currentNode]) {
                // 핵심: 규제 경로 체크
                long long edgeHash = (long long)currentNode * 1000 + nextNode;
                if (restrictedSet.count(edgeHash)) {
                    continue;  // 규제된 경로이므로 사용 불가
                }
                
                int newDist = dist[currentNode] + edgeCost;
                if (newDist < dist[nextNode]) {
                    dist[nextNode] = newDist;
                    pq.push({newDist, nextNode});
                }
            }
        }
        
        return dist;
    }
};
```

### C 언어 버전

C++의 STL을 사용할 수 없는 환경을 위한 구현입니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>

#define MAX_N 100
#define MAX_FLIGHTS 5000
#define INF (INT_MAX / 2)

// 간선 정보
typedef struct {
    int to;
    int cost;
} Edge;

// 우선순위 큐 노드
typedef struct {
    int cost;
    int node;
} PQNode;

// 간단한 우선순위 큐 (배열 기반)
typedef struct {
    PQNode data[MAX_FLIGHTS * 2];
    int size;
} PriorityQueue;

void pq_init(PriorityQueue* pq) {
    pq->size = 0;
}

void pq_push(PriorityQueue* pq, int cost, int node) {
    int i = pq->size++;
    pq->data[i].cost = cost;
    pq->data[i].node = node;
    
    // Min heap 유지
    while (i > 0) {
        int parent = (i - 1) / 2;
        if (pq->data[parent].cost <= pq->data[i].cost) break;
        
        PQNode temp = pq->data[parent];
        pq->data[parent] = pq->data[i];
        pq->data[i] = temp;
        i = parent;
    }
}

PQNode pq_pop(PriorityQueue* pq) {
    PQNode result = pq->data[0];
    pq->data[0] = pq->data[--pq->size];
    
    int i = 0;
    while (true) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int smallest = i;
        
        if (left < pq->size && pq->data[left].cost < pq->data[smallest].cost)
            smallest = left;
        if (right < pq->size && pq->data[right].cost < pq->data[smallest].cost)
            smallest = right;
        
        if (smallest == i) break;
        
        PQNode temp = pq->data[i];
        pq->data[i] = pq->data[smallest];
        pq->data[smallest] = temp;
        i = smallest;
    }
    
    return result;
}

bool pq_empty(PriorityQueue* pq) {
    return pq->size == 0;
}

// 규제 경로 체크 함수
bool isRestricted(int from, int to, int restricted[][2], int restrictedSize) {
    for (int i = 0; i < restrictedSize; i++) {
        if ((restricted[i][0] == from && restricted[i][1] == to) ||
            (restricted[i][0] == to && restricted[i][1] == from)) {
            return true;
        }
    }
    return false;
}

void findOptimalDestinations(int n, int flights[][3], int flightsSize,
                             int restricted[][2], int restrictedSize,
                             int start, int* result) {
    // 인접 리스트 초기화
    Edge adj[MAX_N][MAX_N];
    int adjSize[MAX_N] = {0};
    
    for (int i = 0; i < flightsSize; i++) {
        int from = flights[i][0];
        int to = flights[i][1];
        int cost = flights[i][2];
        
        adj[from][adjSize[from]].to = to;
        adj[from][adjSize[from]].cost = cost;
        adjSize[from]++;
        
        adj[to][adjSize[to]].to = from;
        adj[to][adjSize[to]].cost = cost;
        adjSize[to]++;
    }
    
    // 거리 배열 초기화
    for (int i = 0; i < n; i++) {
        result[i] = INF;
    }
    result[start] = 0;
    
    // 다익스트라 실행
    PriorityQueue pq;
    pq_init(&pq);
    pq_push(&pq, 0, start);
    
    while (!pq_empty(&pq)) {
        PQNode current = pq_pop(&pq);
        int currentNode = current.node;
        int currentCost = current.cost;
        
        if (currentCost > result[currentNode]) {
            continue;
        }
        
        // 인접 노드 탐색
        for (int i = 0; i < adjSize[currentNode]; i++) {
            int nextNode = adj[currentNode][i].to;
            int edgeCost = adj[currentNode][i].cost;
            
            // 규제 경로 체크
            if (isRestricted(currentNode, nextNode, restricted, restrictedSize)) {
                continue;
            }
            
            int newDist = result[currentNode] + edgeCost;
            if (newDist < result[nextNode]) {
                result[nextNode] = newDist;
                pq_push(&pq, newDist, nextNode);
            }
        }
    }
}

// 사용 예제
int main() {
    int n = 5;
    int flights[][3] = {
        {0, 1, 100}, {0, 2, 200}, {1, 2, 50},
        {1, 3, 300}, {2, 3, 100}, {2, 4, 150}, {3, 4, 50}
    };
    int flightsSize = 7;
    
    int restricted[][2] = {{1, 3}};
    int restrictedSize = 1;
    
    int start = 0;
    int result[MAX_N];
    
    findOptimalDestinations(n, flights, flightsSize, restricted, restrictedSize, start, result);
    
    printf("최소 비용:\n");
    for (int i = 0; i < n; i++) {
        if (result[i] == INF) {
            printf("국가 %d: 도달 불가능\n", i);
        } else {
            printf("국가 %d: %d\n", i, result[i]);
        }
    }
    
    return 0;
}
```

---

## 시간 복잡도

- **다익스트라 기본**: O((V + E) log V), 여기서 V는 노드(국가) 수, E는 간선(항공편) 수
- **규제 체크 (C++ 버전)**: O(1) per edge (해시셋 사용)
- **규제 체크 (C 버전)**: O(R) per edge, R은 규제 쌍 수
- **전체 (C++ 버전)**: O((V + E) log V)
- **전체 (C 버전)**: O((V + E) log V + E × R)

최적화를 위해서는 C 버전에서도 해시맵을 구현하거나, 규제 쌍을 2차원 배열로 미리 저장하는 방법을 고려할 수 있습니다.

---

## 공간 복잡도

- 인접 리스트: O(V + E)
- 거리 배열: O(V)
- 우선순위 큐: O(E) (최악의 경우)
- 규제 셋: O(R)
- **전체**: O(V + E + R)

---

## 소감

이 문제는 실제 항공 경로 시스템에서 마주칠 수 있는 현실적인 제약사항을 다룹니다. 북한-한국, 이스라엘-일부 중동 국가처럼 정치적 이유로 직항뿐만 아니라 경유도 제한되는 경우가 실제로 존재합니다.

다익스트라 알고리즘의 기본 구조는 유지하되, **간선을 탐색할 때 필터링 조건을 추가**하는 것이 핵심입니다. 이런 패턴은 다양한 제약 조건이 있는 최단 경로 문제에 응용할 수 있습니다:

- 특정 도시를 반드시 거쳐야 하는 경우
- 특정 시간대에는 사용할 수 없는 경로
- 최대 경유 횟수 제한
- 특정 교통수단 조합 금지

실무에서는 이런 제약사항들이 복합적으로 작용하므로, 기본 알고리즘에 유연하게 조건을 추가할 수 있는 능력이 중요합니다. 

또한 이 문제를 통해 **알고리즘의 본질을 이해하고 변형**하는 연습을 할 수 있습니다. 단순히 외워서 푸는 것이 아니라, 문제의 요구사항에 맞게 알고리즘을 조정하는 것이 진정한 문제 해결 능력입니다.
