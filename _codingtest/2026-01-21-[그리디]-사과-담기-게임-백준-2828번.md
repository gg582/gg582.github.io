---
layout: knowledge-base
title: "[그리디] 사과 담기 게임-백준 2828번"
subtitle: "보이는대로 구현하면 되는 트릭 없는 그리디"
date: 2026-01-21 15:00 +0900
categories: [codingtest]
taxonomy:
  category: codingtest
  subcategory: algorithm-greedy
  order: 1
difficulty: easy
keywords:
  - 정렬
  - 그리디
  - 우선순위 큐
  - 백준
  - 알고리즘
relationships:
  related: []
  references: []
  prerequisite: []
  extends: []
  comparison: []
---


---

<table>
  <thead>
    <tr>
      <th>시간 제한</th>
      <th>메모리 제한</th>
      <th>제출</th>
      <th>정답</th>
      <th>맞힌 사람</th>
      <th>정답 비율</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1 초</td>
      <td>128 MB</td>
      <td>17427</td>
      <td>9061</td>
      <td>7022</td>
      <td>52.821%</td>
    </tr>
  </tbody>
</table>

## 문제
상근이는 오락실에서 바구니를 옮기는 오래된 게임을 한다. 스크린은 N칸으로 나누어져 있다. 스크린의 아래쪽에는 M칸을 차지하는 바구니가 있다. `(M<N)` 플레이어는 게임을 하는 중에 바구니를 왼쪽이나 오른쪽으로 이동할 수 있다. 하지만, 바구니는 스크린의 경계를 넘어가면 안 된다. 가장 처음에 바구니는 왼쪽 M칸을 차지하고 있다.

스크린의 위에서 사과 여러 개가 떨어진다. 각 사과는 N칸중 한 칸의 상단에서 떨어지기 시작하며, 스크린의 바닥에 닿을때까지 직선으로 떨어진다. 한 사과가 바닥에 닿는 즉시, 다른 사과가 떨어지기 시작한다.

바구니가 사과가 떨어지는 칸을 차지하고 있다면, 바구니는 그 사과가 바닥에 닿을 때, 사과를 담을 수 있다. 상근이는 사과를 모두 담으려고 한다. 이때, 바구니의 이동 거리의 최솟값을 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 M이 주어진다. `(1 ≤ M < N ≤ 10)`  
둘째 줄에 떨어지는 사과의 개수 J가 주어진다. `(1 ≤ J ≤ 20)`
다음 J개 줄에는 사과가 떨어지는 위치가 순서대로 주어진다.

## 출력

모든 사과를 담기 위해서 바구니가 이동해야 하는 거리의 최솟값을 출력한다.

## 예제 입력 1

```

5 1
3
1
5
3

```

## 예제 출력 1

```

6

```

## 예제 입력 2

```

5 2
3
1
5
3

```

## 예제 출력 2

```

4

```

## 문제를 풀 때 중요한 점

### 핵심 구조: 슬라이딩 윈도우

### 바구니의 이동
* 바구니의 양쪽 끝을 잡고 위치를 움직인다.


### 사과 위치에 따른 대응

* **오른쪽으로 벗어남 (`사과 > 오른쪽 끝`)**:
* (사과 위치 - 오른쪽 끝)만큼 바구니를 오른쪽으로 민다.
* 밀어낸 거리만큼 이동 거리에 더한다.

---

* **왼쪽으로 벗어남 (`사과 < 왼쪽 끝`)**:
* (왼쪽 끝 - 사과 위치)만큼 바구니를 왼쪽으로 민다.
* 밀어낸 거리만큼 이동 거리에 더한다.

---

* **범위 안 (`왼쪽 끝 <= 사과 <= 오른쪽 끝`)**:
* 아무것도 하지 않는다.


* 사람이 사고하는 방식 그대로 따라가라. 컴퓨터공학적 기교가 필요없다.
* 바구니의 끝점을 사과에 맞춰서 **아슬하게 사과를 받는 것이 최적이다.**

## 풀이

```cpp
#include <iostream>

int main() {
  int screen_width, basket_width;
  std::cin >> screen_width >> basket_width;

  int basket_startpoint = 1;
  int answer = 0;

  int apples_len;
  std::cin >> apples_len;

  for (int i = 0; i < apples_len; i++) {
    int dest;
    std::cin >> dest;

    // current basket range
    int basket_endpoint = basket_startpoint + basket_width - 1;

    if (dest > basket_endpoint) {
      // move right
      int move = dest - basket_endpoint;
      answer += move;
      basket_startpoint += move;
    }
    else if (dest < basket_startpoint) {
      // move left
      int move = basket_startpoint - dest;
      answer += move;
      basket_startpoint -= move;
    }
    // in range -> skip
  }

  std::cout << answer;
  return 0;
}
```

## 결론

이런 문제는 발상까지가 오래 걸리지 구현은 얼마 걸리지 않는다.
그리디 특유의 단순하고 기교 없는 발상을 몸에 익히는 것은 마치 어린아이의 그림을 다시 배우는 것과 비슷하다.

피카소가 어린아이처럼 다시 그리는데 수십 년이 걸렸다고 하지만, 이건 코드다. 어린아이의 코드처럼 짜는 것은 몇 주 단기 완성도 가능할 것이다.
반복해서 사고방식을 따라가자.
